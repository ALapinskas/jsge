/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./modules/assetsm/dist/assetsm.min.js":
/*!*********************************************!*\
  !*** ./modules/assetsm/dist/assetsm.min.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AssetsManager)\n/* harmony export */ });\nconst PROGRESS_EVENT_TYPE={loadstart:\"loadstart\",progress:\"progress\",abort:\"abort\",error:\"error\",load:\"load\",timeout:\"timeout\"};class Loader{#e;#t;#s=new Map;#i=new Map;constructor(e,t){this.#e=e,this.#t=(e,s,...i)=>{const r=t(e,s,...i);if(r instanceof Promise)return r.then((t=>this.#r(t,e)));Exception(\"uploadMethod should be instance of Promise and return upload result value\")}}#r=(e,t)=>new Promise(((s,i)=>{e&&0!==e.length||Warning(\"uploadMethod for \"+this.#e+\" should return Promise with upload value\"),this.#o(t,e),this.#a(t),s()}));#o(e,t){this.#i.set(e,t)}#a(e){this.#s.delete(e)}get filesWaitingForUpload(){return this.#s.size}get loadingQueue(){return this.#s}get uploadMethod(){return this.#t}_addFile=(e,t)=>{this.#s.has(e)&&Warning(\"File \"+this.#e+\" with key \"+e+\" is already added\"),this.#s.set(e,t)};_isFileInQueue=e=>this.#s.has(e);_getFile=e=>this.#i.get(e)}class AssetsManager{#n=new EventTarget;#d=new Map;#l=0;constructor(){this.registerLoader(\"Audio\",this._loadAudio),this.registerLoader(\"Image\",this._loadImage),this.registerLoader(\"TileMap\",this._loadTileMap)}get filesWaitingForUpload(){let e=0;return Array.from(this.#d.values()).map((t=>e+=t.filesWaitingForUpload)),e}registerLoader=(e,t=this._defaultUploadMethod)=>{const s=this.#d.get(e)||new Loader(e,t);this[\"add\"+e]=(t,s)=>{this.addFile(e,t,s)},this[\"get\"+e]=t=>this.getFile(e,t),this[\"is\"+e+[\"InQueue\"]]=t=>this.isFileInQueue(e,t),this.#d.set(e,s)};preload(){return this.#h(),new Promise(((e,t)=>{this.#u().then((()=>{this.filesWaitingForUpload?this.#u().then((()=>{this.#c(),e()})):(this.#c(),e())}))}))}#u(){const e=Array.from(this.#d.values()).map((e=>Promise.allSettled(Array.from(e.loadingQueue.entries()).map((t=>e.uploadMethod(t[0],t[1]))))));return Promise.all(e)}addEventListener(e,t,...s){PROGRESS_EVENT_TYPE[e]?this.#n.addEventListener(e,t,...s):Warning(\"Event type should be one of the ProgressEvent.type\")}removeEventListener(e,t,...s){this.#n.removeEventListener(e,t,...s)}#p=(e,t)=>{const{firstgid:s,source:i}=e;return this.#g(i),fetch(t+i).then((e=>e.json())).then((e=>{const{name:i,image:r}=e;return i&&r&&!this.isImageInQueue(i)&&this.addImage(i,t?t+r:r,e),e.gid=s,Promise.resolve(e)})).catch((()=>{const e=new Error(\"Can't load related tileset \",i);return Promise.reject(e)}))};_defaultUploadMethod=(e,t)=>fetch(t);_loadTileMap=(e,t)=>(this.#m(t),fetch(t).then((e=>e.json())).then((e=>{let s,i=t.split(\"/\"),r=i.length;if(i[r-1].includes(\".tmj\")||i[r-1].includes(\".json\")?(i.pop(),s=i.join(\"/\")+\"/\"):(i[r-2].includes(\".tmj\")||i[r-2].includes(\".json\"))&&(i.splice(r-2,2),s=i.join(\"/\")+\"/\"),e.tilesets&&e.tilesets.length>0){const t=[];return e.tilesets.forEach(((e,i)=>{const r=this.#p(e,s).then((e=>(this.#E(),Promise.resolve(e))));t.push(r)})),Promise.all(t).then((t=>{for(let s=0;s<t.length;s++){const i=t[s];e.tilesets[s].data=i}return Promise.resolve(e)}))}})).catch((e=>(e.message.includes(\"JSON.parse:\")&&(e=new Error(\"Can't load tilemap \"+t)),this.#f(e),Promise.reject(e)))));_loadAudio=(e,t)=>new Promise(((e,s)=>{const i=new Audio(t);i.addEventListener(\"loadeddata\",(()=>{this.#E(),e(i)})),i.addEventListener(\"error\",(()=>{const e=new Error(\"Can't load audio \"+t);this.#f(e),s(e)}))}));_loadImage=(e,t)=>new Promise(((e,s)=>{const i=new Image;i.onload=()=>{createImageBitmap(i).then((t=>{this.#E(),e(t)}))},i.onerror=()=>{const e=new Error(\"Can't load image \"+t);this.#f(e),s(e)},i.src=t}));#g(e){e.includes(\".tsj\")||e.includes(\".json\")||Exception(\"Related Tileset file type is not correct, only .tsj or .json files are supported\")}#m(e){e.includes(\".tmj\")||e.includes(\".json\")||Exception(\"Tilemap file type is not correct, only .tmj or .json files are supported\")}addFile(e,t,s){const i=this.#d.get(e);i?(this.#L(t,s),i._addFile(t,s)):Exception(\"Loader for \"+e+\" is not registered!\")}isFileInQueue(e,t){const s=this.#d.get(e);if(s)return s._isFileInQueue(t);Exception(\"Loader for \"+e+\" is not registered!\")}getFile(e,t){const s=this.#d.get(e);if(s)return s._getFile(t);Exception(\"Loader for \"+e+\" is not registered!\")}#L(e,t){const s=\"fileKey and url should be provided\";e&&0!==e.trim().length||Exception(s),t&&0!==t.trim().length||Exception(s)}#h(){let e=this.filesWaitingForUpload;this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart,{total:e}))}#c(){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load))}#E(){const e=this.filesWaitingForUpload;this.#l+=1,this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress,{lengthComputable:!0,loaded:this.#l,total:e}))}#f(e){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.error,{error:e}))}}function Exception(e){throw new Error(e)}function Warning(e){console.warn(e)}\n\n//# sourceURL=webpack://jsge/./modules/assetsm/dist/assetsm.min.js?");

/***/ }),

/***/ "./node_modules/assetsm/dist/assetsm.min.js":
/*!**************************************************!*\
  !*** ./node_modules/assetsm/dist/assetsm.min.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AssetsManager)\n/* harmony export */ });\nconst PROGRESS_EVENT_TYPE={loadstart:\"loadstart\",progress:\"progress\",abort:\"abort\",error:\"error\",load:\"load\",timeout:\"timeout\"};class Loader{#e;#t;#s=new Map;#i=new Map;constructor(e,t){this.#e=e,this.#t=(e,s,...i)=>{const r=t(e,s,...i);if(r instanceof Promise)return r.then((t=>this.#r(t,e)));Exception(\"uploadMethod should be instance of Promise and return upload result value\")}}#r=(e,t)=>new Promise(((s,i)=>{e&&0!==e.length||Warning(\"uploadMethod for \"+this.#e+\" should return Promise with upload value\"),this.#o(t,e),this.#a(t),s()}));#o(e,t){this.#i.set(e,t)}#a(e){this.#s.delete(e)}get filesWaitingForUpload(){return this.#s.size}get loadingQueue(){return this.#s}get uploadMethod(){return this.#t}_addFile=(e,t)=>{this.#s.has(e)&&Warning(\"File \"+this.#e+\" with key \"+e+\" is already added\"),this.#s.set(e,t)};_isFileInQueue=e=>this.#s.has(e);_getFile=e=>this.#i.get(e)}class AssetsManager{#n=new EventTarget;#d=new Map;#l=0;constructor(){this.registerLoader(\"Audio\",this._loadAudio),this.registerLoader(\"Image\",this._loadImage),this.registerLoader(\"TileMap\",this._loadTileMap)}get filesWaitingForUpload(){let e=0;return Array.from(this.#d.values()).map((t=>e+=t.filesWaitingForUpload)),e}registerLoader=(e,t=this._defaultUploadMethod)=>{const s=this.#d.get(e)||new Loader(e,t);this[\"add\"+e]=(t,s)=>{this.addFile(e,t,s)},this[\"get\"+e]=t=>this.getFile(e,t),this[\"is\"+e+[\"InQueue\"]]=t=>this.isFileInQueue(e,t),this.#d.set(e,s)};preload(){return this.#h(),new Promise(((e,t)=>{this.#u().then((()=>{this.filesWaitingForUpload?this.#u().then((()=>{this.#c(),e()})):(this.#c(),e())}))}))}#u(){const e=Array.from(this.#d.values()).map((e=>Promise.allSettled(Array.from(e.loadingQueue.entries()).map((t=>e.uploadMethod(t[0],t[1]))))));return Promise.all(e)}addEventListener(e,t,...s){PROGRESS_EVENT_TYPE[e]?this.#n.addEventListener(e,t,...s):Warning(\"Event type should be one of the ProgressEvent.type\")}removeEventListener(e,t,...s){this.#n.removeEventListener(e,t,...s)}#p=(e,t)=>{const{firstgid:s,source:i}=e;return this.#g(i),fetch(t+i).then((e=>e.json())).then((e=>{const{name:i,image:r}=e;return i&&r&&!this.isImageInQueue(i)&&this.addImage(i,t?t+r:r,e),e.gid=s,Promise.resolve(e)})).catch((()=>{const e=new Error(\"Can't load related tileset \",i);return Promise.reject(e)}))};_defaultUploadMethod=(e,t)=>fetch(t);_loadTileMap=(e,t)=>(this.#m(t),fetch(t).then((e=>e.json())).then((e=>{let s,i=t.split(\"/\"),r=i.length;if(i[r-1].includes(\".tmj\")||i[r-1].includes(\".json\")?(i.pop(),s=i.join(\"/\")+\"/\"):(i[r-2].includes(\".tmj\")||i[r-2].includes(\".json\"))&&(i.splice(r-2,2),s=i.join(\"/\")+\"/\"),e.tilesets&&e.tilesets.length>0){const t=[];return e.tilesets.forEach(((e,i)=>{const r=this.#p(e,s).then((e=>(this.#E(),Promise.resolve(e))));t.push(r)})),Promise.all(t).then((t=>{for(let s=0;s<t.length;s++){const i=t[s];e.tilesets[s].data=i}return Promise.resolve(e)}))}})).catch((e=>(e.message.includes(\"JSON.parse:\")&&(e=new Error(\"Can't load tilemap \"+t)),this.#f(e),Promise.reject(e)))));_loadAudio=(e,t)=>new Promise(((e,s)=>{const i=new Audio(t);i.addEventListener(\"loadeddata\",(()=>{this.#E(),e(i)})),i.addEventListener(\"error\",(()=>{const e=new Error(\"Can't load audio \"+t);this.#f(e),s(e)}))}));_loadImage=(e,t)=>new Promise(((e,s)=>{const i=new Image;i.onload=()=>{createImageBitmap(i).then((t=>{this.#E(),e(t)}))},i.onerror=()=>{const e=new Error(\"Can't load image \"+t);this.#f(e),s(e)},i.src=t}));#g(e){e.includes(\".tsj\")||e.includes(\".json\")||Exception(\"Related Tileset file type is not correct, only .tsj or .json files are supported\")}#m(e){e.includes(\".tmj\")||e.includes(\".json\")||Exception(\"Tilemap file type is not correct, only .tmj or .json files are supported\")}addFile(e,t,s){const i=this.#d.get(e);i?(this.#L(t,s),i._addFile(t,s)):Exception(\"Loader for \"+e+\" is not registered!\")}isFileInQueue(e,t){const s=this.#d.get(e);if(s)return s._isFileInQueue(t);Exception(\"Loader for \"+e+\" is not registered!\")}getFile(e,t){const s=this.#d.get(e);if(s)return s._getFile(t);Exception(\"Loader for \"+e+\" is not registered!\")}#L(e,t){const s=\"fileKey and url should be provided\";e&&0!==e.trim().length||Exception(s),t&&0!==t.trim().length||Exception(s)}#h(){let e=this.filesWaitingForUpload;this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart,{total:e}))}#c(){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load))}#E(){const e=this.filesWaitingForUpload;this.#l+=1,this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress,{lengthComputable:!0,loaded:this.#l,total:e}))}#f(e){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.error,{error:e}))}}function Exception(e){throw new Error(e)}function Warning(e){console.warn(e)}\n\n//# sourceURL=webpack://jsge/./node_modules/assetsm/dist/assetsm.min.js?");

/***/ }),

/***/ "./src/base/AnimationEventImageObj.js":
/*!********************************************!*\
  !*** ./src/base/AnimationEventImageObj.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnimationEventImageObj\": () => (/* binding */ AnimationEventImageObj)\n/* harmony export */ });\nclass AnimationEventImageObj {\n    #eventName;\n    /**\n     * @type {Array<number>}\n     */\n    #animationSpriteIndexes;\n    /**\n     * @type {number}\n     */\n    #currentSpriteIndex;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {boolean}\n     */\n    #isRepeated;\n    \n    constructor(eventName, animationSpriteIndexes, isRepeated = false, currentSpriteIndex, isActive = false) {\n        this.#eventName = eventName;\n        this.#animationSpriteIndexes = animationSpriteIndexes;\n        this.#currentSpriteIndex = currentSpriteIndex ? currentSpriteIndex : 0;\n        this.#isActive = isActive;\n        this.#isRepeated = isRepeated;\n    }\n\n    get isActive() {\n        return this.#isActive;\n    }\n\n    get currentSprite() {\n        return this.#animationSpriteIndexes[this.#currentSpriteIndex];\n    }\n\n    get isLastSprite() {\n        return (this.#animationSpriteIndexes.length - 1) === this.#currentSpriteIndex;\n    }\n\n    iterateSprite() {\n        if (!this.isLastSprite) {\n            this.#currentSpriteIndex = this.#currentSpriteIndex + 1;\n        } else {\n            if (!this.#isRepeated) {\n                this.#isActive = false;\n            } else {\n                this.#currentSpriteIndex = 0;\n            }\n        }\n    }\n\n    activateAnimation = () => {\n        this.#isActive = true;\n        this.#currentSpriteIndex = 0;\n    };\n\n    deactivateAnimation = () => {\n        this.#isActive = false;\n    };\n}\n\n//# sourceURL=webpack://jsge/./src/base/AnimationEventImageObj.js?");

/***/ }),

/***/ "./src/base/DrawCircleObject.js":
/*!**************************************!*\
  !*** ./src/base/DrawCircleObject.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawCircleObject\": () => (/* binding */ DrawCircleObject)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n/**\r\n * Conus object to draw.\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawCircleObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #radius;\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    #vertices;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(x, y, radius, bgColor) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CIRCLE, x, y, bgColor);\r\n        this.#radius = radius;\r\n        this.#vertices = this._calculateConusVertices(radius);\r\n    }\r\n\r\n    /**\r\n     * Array of [x,y] cords.\r\n     * @type {Array<number>}\r\n     */\r\n    get vertices () {\r\n        return this.#vertices;\r\n    }\r\n\r\n    set vertices(value) {\r\n        this.#vertices = value;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get radius() {\r\n        return this.#radius;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawCircleObject.js?");

/***/ }),

/***/ "./src/base/DrawConusObject.js":
/*!*************************************!*\
  !*** ./src/base/DrawConusObject.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawConusObject\": () => (/* binding */ DrawConusObject)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n/**\r\n * Conus object to draw.\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawConusObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #radius;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #angle;\r\n\r\n    /**\r\n     * Array of [x,y] cords.\r\n     * @type {Array<number>}\r\n     */\r\n    #vertices;\r\n    #fade_min;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(x, y, radius, bgColor, angle, fade = 0) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CONUS, x, y, bgColor);\r\n        this.#radius = radius;\r\n        this.#angle = angle;\r\n        this.#fade_min = fade;\r\n        this.#vertices = this._calculateConusVertices(radius, angle);\r\n    }\r\n\r\n    /**\r\n     * Array of [x,y] cords.\r\n     * @type {Array<number>}\r\n     */\r\n    get vertices () {\r\n        return this.#vertices;\r\n    }\r\n\r\n    set vertices(value) {\r\n        this.#vertices = value;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get radius() {\r\n        return this.#radius;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get angle() {\r\n        return this.#angle;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get fade_min() {\r\n        return this.#fade_min;\r\n    }\r\n\r\n    /**\r\n     * @param {number} value - fade start pos in px\r\n     */\r\n    set fade_min(value) {\r\n        this.#fade_min = value;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawConusObject.js?");

/***/ }),

/***/ "./src/base/DrawImageObject.js":
/*!*************************************!*\
  !*** ./src/base/DrawImageObject.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawImageObject\": () => (/* binding */ DrawImageObject)\n/* harmony export */ });\n/* harmony import */ var _AnimationEventImageObj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationEventImageObj.js */ \"./src/base/AnimationEventImageObj.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n/**\r\n * Image object to draw\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawImageObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_2__.DrawShapeObject {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #w;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #h;\r\n    /**\r\n     * Image sprite key\r\n     * @type {string}\r\n     */\r\n    #key;\r\n    /**\r\n     * @type {EventTarget}\r\n     */\r\n    #emitter;\r\n    /**\r\n     * @type {Map<string, AnimationEventImageObj>}\r\n     */\r\n    #animations;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #imageIndex;\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #vertices;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(mapX, mapY, width, height, key, imageIndex = 0, boundaries) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.DRAW_TYPE.IMAGE, mapX, mapY);\r\n        this.#key = key;\r\n        this.#emitter = new EventTarget();\r\n        this.#animations = new Map();\r\n        this.#imageIndex = imageIndex;\r\n        this.#w = width;\r\n        this.#h = height;\r\n        this.#vertices = boundaries ? this._convertVerticesArray(boundaries) : this._calculateRectVertices(width, height);\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get width() {\r\n        return this.#w;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get height() {\r\n        return this.#h;\r\n    }\r\n\r\n    set width(w) {\r\n        this.#w = w;\r\n    }\r\n\r\n    set height(h) {\r\n        this.#h = h;\r\n    }\r\n\r\n    /**\r\n     * A key should match an image loaded through AssetsManager\r\n     * @type {string}\r\n     */\r\n    get key() {\r\n        return this.#key;\r\n    }\r\n\r\n    /**\r\n     * Current image index\r\n     * @type {number}\r\n     */\r\n    get imageIndex() {\r\n        return this.#imageIndex;\r\n    }\r\n\r\n    set imageIndex(value) {\r\n        this.#imageIndex = value;\r\n    }\r\n\r\n    /**\r\n     * Determines if image is animated or not\r\n     * @type {boolean}\r\n     */\r\n    get isAnimations() {\r\n        return this.#animations.size > 0;\r\n    }\r\n\r\n    /**\r\n     * @deprecated - use .vertices instead \r\n     * @type {Array<Array<number>>}\r\n     */\r\n    get boundaries() {\r\n        return this.#vertices;\r\n    }\r\n\r\n    get vertices() {\r\n        return this.#vertices;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    _processActiveAnimations() {\r\n        for (let animationEvent of this.#animations.values()) {\r\n            if (animationEvent.isActive) {\r\n                animationEvent.iterateSprite();\r\n                this.#imageIndex = animationEvent.currentSprite;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emit event\r\n     * @param {string} eventName \r\n     * @param  {...any} eventParams \r\n     */\r\n    emit(eventName, ...eventParams) {\r\n        const event = new Event(eventName);\r\n        event.data = [...eventParams];\r\n        this.#emitter.dispatchEvent(event);\r\n    }\r\n\r\n    /**\r\n     * Subscribe\r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*} options \r\n     */\r\n    addEventListener(eventName, listener, options) {\r\n        this.#emitter.addEventListener(eventName, listener, options);\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe\r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*} options \r\n     */\r\n    removeEventListener(eventName, listener, options) {\r\n        this.#emitter.removeEventListener(eventName, listener, options);\r\n    }\r\n\r\n    /**\r\n     * Adds image animations\r\n     * @param { string } eventName -animation name\r\n     * @param { Array<number> } animationSpriteIndexes - animation image indexes\r\n     * @param { boolean } [isRepeated = false] - animation is circled or not, circled animation could be stopped only with stopRepeatedAnimation();\r\n     */\r\n    addAnimation (eventName, animationSpriteIndexes, isRepeated) {\r\n        const animationEvent = new _AnimationEventImageObj_js__WEBPACK_IMPORTED_MODULE_0__.AnimationEventImageObj(eventName, animationSpriteIndexes, isRepeated);\r\n        this.#animations.set(eventName, animationEvent);\r\n        this.addEventListener(eventName, this.#activateAnimation);\r\n    }\r\n\r\n    #activateAnimation = (event) => {\r\n        const animationEvent = this.#animations.get(event.type);\r\n        animationEvent.activateAnimation();\r\n        this.#imageIndex = animationEvent.currentSprite;\r\n    }; \r\n\r\n    /**\r\n     *\r\n     * @param {string} eventName - animation name\r\n     */\r\n    stopRepeatedAnimation (eventName) {\r\n        this.#animations.get(eventName).deactivateAnimation();\r\n    }\r\n\r\n    /**\r\n     * Removes animations\r\n     */\r\n    removeAllAnimations() {\r\n        for (let [eventName, animationEvent] of this.#animations.entries()) {\r\n            this.removeEventListener(eventName, animationEvent.activateAnimation);\r\n            animationEvent.deactivateAnimation();\r\n        }\r\n        this.#animations.clear();\r\n        this.#animations = undefined;\r\n    }\r\n\r\n    destroy() {\r\n        this.removeAllAnimations();\r\n        super.destroy();\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawImageObject.js?");

/***/ }),

/***/ "./src/base/DrawLineObject.js":
/*!************************************!*\
  !*** ./src/base/DrawLineObject.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawLineObject\": () => (/* binding */ DrawLineObject)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n/**\r\n * Line object to draw.\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawLineObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #vertices;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(vertices, bgColor) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.LINE, vertices[0][0], vertices[0][1], bgColor);\r\n        this.#vertices = vertices;\r\n    }\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    get vertices () {\r\n        return this.#vertices;\r\n    }\r\n\r\n    set vertices(value) {\r\n        this.#vertices = value;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawLineObject.js?");

/***/ }),

/***/ "./src/base/DrawObjectFactory.js":
/*!***************************************!*\
  !*** ./src/base/DrawObjectFactory.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawObjectFactory\": () => (/* binding */ DrawObjectFactory)\n/* harmony export */ });\n/* harmony import */ var _DrawRectObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawRectObject.js */ \"./src/base/DrawRectObject.js\");\n/* harmony import */ var _DrawTextObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawTextObject.js */ \"./src/base/DrawTextObject.js\");\n/* harmony import */ var _DrawConusObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DrawConusObject.js */ \"./src/base/DrawConusObject.js\");\n/* harmony import */ var _DrawImageObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawImageObject.js */ \"./src/base/DrawImageObject.js\");\n/* harmony import */ var _DrawLineObject_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawLineObject.js */ \"./src/base/DrawLineObject.js\");\n/* harmony import */ var _DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DrawPolygonObject.js */ \"./src/base/DrawPolygonObject.js\");\n/* harmony import */ var _DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawCircleObject.js */ \"./src/base/DrawCircleObject.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Creates drawObjects instances.<br>\r\n * accessible via ScreenPage.draw <br>\r\n * @see {@link ScreenPage} a part of ScreenPage\r\n */\r\nclass DrawObjectFactory {\r\n\r\n    /**\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @param {string} backgroundColor - rgba(r,g,b,a)\r\n     * @returns {DrawRectObject}\r\n     */\r\n    rect(x, y, width, height, backgroundColor) {\r\n        return new _DrawRectObject_js__WEBPACK_IMPORTED_MODULE_0__.DrawRectObject(x, y, width, height, backgroundColor); \r\n    }\r\n\r\n    /**\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {string} text \r\n     * @param {string} font - size fontFamily\r\n     * @param {string} color - rgba(r,g,b,a)\r\n     * @returns {DrawTextObject}\r\n     */\r\n    text(x, y, text, font, color) {\r\n        return new _DrawTextObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawTextObject(x, y, text, font, color);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} radius \r\n     * @param {string} bgColor - rgba(r,g,b,a)\r\n     * @param {number=} angle\r\n     * @param {number=} [fade=0] (0 - 1)\r\n     * @returns {DrawConusObject}\r\n     */\r\n    conus(x, y, radius, bgColor, angle, fade = 0) {\r\n        return new _DrawConusObject_js__WEBPACK_IMPORTED_MODULE_2__.DrawConusObject(x, y, radius, bgColor, angle, fade);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} radius \r\n     * @param {string} bgColor - rgba(r,g,b,a)\r\n     * @returns {DrawCircleObject}\r\n     */\r\n    circle(x, y, radius, bgColor) {\r\n        return new _DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_6__.DrawCircleObject(x, y, radius, bgColor);\r\n    }\r\n\r\n    /**\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @param {string} key \r\n     * @param {number} [imageIndex = 0]\r\n     * @param {Array<{x:Number, y:Number}>=} boundaries \r\n     * @returns {DrawImageObject}\r\n     */\r\n    image(x, y, width, height, key, imageIndex = 0, boundaries) {\r\n        return new _DrawImageObject_js__WEBPACK_IMPORTED_MODULE_3__.DrawImageObject(x, y, width, height, key, imageIndex, boundaries);\r\n    }\r\n\r\n    /**\r\n     * @param {Array<number>} vertices \r\n     * @param {string} color - rgba(r,g,b,a)\r\n     * @returns {DrawLineObject}\r\n     */\r\n    line(vertices, color) {\r\n        return new _DrawLineObject_js__WEBPACK_IMPORTED_MODULE_4__.DrawLineObject(vertices, color);\r\n    }\r\n\r\n    /**\r\n     * @param {Array<{x:number, y:number}>} vertices - should go in anticlockwise order\r\n     * @param {string} bgColor - rgba(r,g,b,a)\r\n     * @returns {DrawPolygonObject}\r\n     */\r\n    polygon(vertices, bgColor) {\r\n        return new _DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_5__.DrawPolygonObject(vertices, bgColor);\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawObjectFactory.js?");

/***/ }),

/***/ "./src/base/DrawPolygonObject.js":
/*!***************************************!*\
  !*** ./src/base/DrawPolygonObject.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawPolygonObject\": () => (/* binding */ DrawPolygonObject)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n/**\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawPolygonObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #vertices;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(vertices, bgColor) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.POLYGON, vertices[0].x, vertices[0].y, bgColor);\r\n        this.#vertices = this._convertVerticesArray(vertices);\r\n    }\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    get vertices () {\r\n        return this.#vertices;\r\n    }\r\n\r\n    set vertices(value) {\r\n        this.#vertices = value;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawPolygonObject.js?");

/***/ }),

/***/ "./src/base/DrawRectObject.js":
/*!************************************!*\
  !*** ./src/base/DrawRectObject.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawRectObject\": () => (/* binding */ DrawRectObject)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n/**\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawRectObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_1__.DrawShapeObject {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #w;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #h;\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #vertices;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(x, y, w, h, bgColor) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.RECTANGLE, x, y, bgColor);\r\n        this.#w = w;\r\n        this.#h = h;\r\n        this.#vertices = this._calculateRectVertices(w,h);\r\n    }\r\n\r\n    /**\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    get vertices () {\r\n        return this.#vertices;\r\n    }\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get width() {\r\n        return this.#w;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get height() {\r\n        return this.#h;\r\n    }\r\n\r\n    set width(w) {\r\n        this.#w = w;\r\n    }\r\n\r\n    set height(h) {\r\n        this.#h = h;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawRectObject.js?");

/***/ }),

/***/ "./src/base/DrawShapeObject.js":
/*!*************************************!*\
  !*** ./src/base/DrawShapeObject.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawShapeObject\": () => (/* binding */ DrawShapeObject)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./src/index.js\");\n\r\n\r\n\r\n/**\r\n * A base draw object.\r\n */\r\nclass DrawShapeObject {\r\n    #x;\r\n    #y;\r\n    #bg;\r\n    /**\r\n     * @type {string}\r\n     * @enum {CONST.DRAW_TYPE}\r\n     */\r\n    #type;\r\n    /**\r\n     * Is used for blending pixel arithmetic\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc.\r\n     * @type {Array<number>}\r\n     */\r\n    #blendFunc;\r\n    \r\n    /**\r\n     * @type {number}\r\n     */\r\n    #sortIndex = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #rotation = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #id = _index_js__WEBPACK_IMPORTED_MODULE_1__.utils.generateUniqId();\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isRemoved = false;\r\n    /**\r\n     * @type {undefined | number | null}\r\n     */\r\n    #attachedMaskId;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isOffsetTurnedOff;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(type, mapX, mapY, bgColor) {\r\n        this.#x = mapX;\r\n        this.#y = mapY;\r\n        this.#bg = bgColor;\r\n        this.#type = type;\r\n    }\r\n\r\n    /**\r\n     * Background color as rgba(r,g,b,a).\r\n     * @type {string}\r\n     */\r\n    get bgColor() {\r\n        return this.#bg;\r\n    }\r\n\r\n    set bgColor(value) {\r\n        this.#bg = value;\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     * @enum {CONST.DRAW_TYPE}\r\n     */\r\n    get type() {\r\n        return this.#type;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get x() {\r\n        return this.#x;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get y () {\r\n        return this.#y;\r\n    }\r\n\r\n    set x(posX) {\r\n        this.#x = posX;\r\n    }\r\n\r\n    set y(posY) {\r\n        this.#y = posY;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get sortIndex () {\r\n        return this.#sortIndex;\r\n    }\r\n\r\n    set sortIndex(value) {\r\n        this.#sortIndex = value;\r\n    }\r\n\r\n    get blendFunc () {\r\n        return this.#blendFunc;\r\n    }\r\n\r\n    set blendFunc(value) {\r\n        this.#blendFunc = value;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get rotation() {\r\n        return this.#rotation;\r\n    }\r\n\r\n    set rotation(value) {\r\n        this.#rotation = value;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get id() {\r\n        return this.#id;\r\n    }\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    get isRemoved() {\r\n        return this.#isRemoved;\r\n    }\r\n\r\n    /**\r\n     * Destroy object on next render iteration.\r\n     */\r\n    destroy() {\r\n        this.#isRemoved = true;\r\n    }\r\n\r\n    get isMaskAttached() {\r\n        return !!this.#attachedMaskId;\r\n    }\r\n\r\n    get _maskId() {\r\n        return this.#attachedMaskId;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {DrawShapeObject} mask \r\n     */\r\n    setMask(mask) {\r\n        this.#attachedMaskId = mask.id;\r\n    }\r\n\r\n    removeMask() {\r\n        this.#attachedMaskId = null;\r\n    }\r\n    get isOffsetTurnedOff() {\r\n        return this.#isOffsetTurnedOff;\r\n    }\r\n\r\n    turnOffOffset() {\r\n        this.#isOffsetTurnedOff = true;\r\n    }\r\n    /**\r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    _calculateRectVertices = (width, height) => {\r\n        const halfW = width/2,\r\n            halfH = height/2;\r\n        return [[-halfW, -halfH], [halfW, -halfH], [halfW, halfH], [-halfW, halfH]];\r\n    };\r\n\r\n    /**\r\n     * @param {number} radius \r\n     * @param {number} [angle = 2 * Math.PI]\r\n     * @param {number} [step = Math.PI/12] \r\n     * @returns {Array<number>}\r\n     * @ignore\r\n     */\r\n    _calculateConusVertices(radius, angle = 2*Math.PI, step = Math.PI/14) {\r\n        let conusPolygonCoords = [0, 0];\r\n\r\n        for (let r = 0; r <= angle; r += step) {\r\n            let x2 = Math.cos(r) * radius,\r\n                y2 = Math.sin(r) * radius;\r\n\r\n            conusPolygonCoords.push(x2, y2);\r\n        }\r\n\r\n        return conusPolygonCoords;\r\n    }\r\n\r\n    /**\r\n     * @param {Array<Array<number>> | Array<{x:number, y:number}>} boundaries\r\n     * @returns {Array<Array<number>>}\r\n     * @ignore\r\n     */\r\n    _convertVerticesArray(boundaries) {\r\n        if (typeof boundaries[0].x !== \"undefined\" && typeof boundaries[0].y !== \"undefined\") {\r\n            return _index_js__WEBPACK_IMPORTED_MODULE_1__.utils.verticesArrayToArrayNumbers(boundaries);\r\n        } else {\r\n            return boundaries;\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawShapeObject.js?");

/***/ }),

/***/ "./src/base/DrawTextObject.js":
/*!************************************!*\
  !*** ./src/base/DrawTextObject.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawTextObject\": () => (/* binding */ DrawTextObject)\n/* harmony export */ });\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n/* harmony import */ var _Primitives_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Primitives.js */ \"./src/base/Primitives.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n\r\n\r\n\r\n\r\n/**\r\n * @extends DrawShapeObject\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nclass DrawTextObject extends _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_0__.DrawShapeObject {\r\n    #font;\r\n    #textAlign;\r\n    #textBaseline;\r\n    #fillStyle;\r\n    #strokeStyle;\r\n    #text;\r\n    #textMetrics;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(mapX, mapY, text, font, fillStyle) {\r\n        super(_constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.DRAW_TYPE.TEXT, mapX, mapY);\r\n        this.#text = text;\r\n        this.#font = font;\r\n        this.#fillStyle = fillStyle;\r\n        this.#textMetrics;\r\n    }\r\n\r\n    /**\r\n     * Rectangle text box.\r\n     * @type {Rectangle}\r\n     */\r\n    get boundariesBox() {\r\n        const width = this.textMetrics ? this.textMetrics.width : 300,\r\n            height = this.textMetrics ? this.textMetrics.actualBoundingBoxAscent + /*this.textMetrics.actualBoundingBoxDescent*/ 5: 30;\r\n        return new _Primitives_js__WEBPACK_IMPORTED_MODULE_1__.Rectangle(this.x, this.y - height, width, height);\r\n    }\r\n\r\n    get vertices() {\r\n        const bb = this.boundariesBox;\r\n        return this._calculateRectVertices(bb.width, bb.height);\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get text() {\r\n        return this.#text;\r\n    }\r\n\r\n    set text(value) {\r\n        this.#text = value;\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get font() {\r\n        return this.#font;\r\n    }\r\n\r\n    set font(value) {\r\n        this.#font = value;\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get textAlign() {\r\n        return this.#textAlign;\r\n    }\r\n\r\n    set textAlign(value) {\r\n        this.#textAlign = value;\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get textBaseline() {\r\n        return this.#textBaseline;\r\n    }\r\n\r\n    set textBaseline(value) {\r\n        this.#textBaseline = value;\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get fillStyle() {\r\n        return this.#fillStyle;\r\n    }\r\n\r\n    set fillStyle(value) {\r\n        this.#fillStyle = value;\r\n    }\r\n\r\n    /**\r\n     * @type {string}\r\n     */\r\n    get strokeStyle() {\r\n        return this.#strokeStyle;\r\n    }\r\n\r\n    set strokeStyle(value) {\r\n        this.#strokeStyle = value;\r\n    }\r\n\r\n    /**\r\n     * @type {TextMetrics}\r\n     */\r\n    get textMetrics() {\r\n        return this.#textMetrics;\r\n    }\r\n\r\n    set _textMetrics(value) {\r\n        this.#textMetrics = value;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/DrawTextObject.js?");

/***/ }),

/***/ "./src/base/Events/SystemEvent.js":
/*!****************************************!*\
  !*** ./src/base/Events/SystemEvent.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SystemEvent\": () => (/* binding */ SystemEvent)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Exception.js */ \"./src/base/Exception.js\");\n\n\n\nclass SystemEvent extends Event {\n    #data;\n    constructor(eventValue, data){\n        super(eventValue);\n        if (!this.#isEventExist(eventValue)) {\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.UNEXPECTED_EVENT_NAME, \", Please check if event is exist\");\n        }\n        this.#data = data;\n    }\n\n    #isEventExist(eventValue) {\n        return Object.values(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT).find(eventVal => eventVal === eventValue);\n    }\n\n    get data () {\n        return this.#data;\n    }\n}\n\n//# sourceURL=webpack://jsge/./src/base/Events/SystemEvent.js?");

/***/ }),

/***/ "./src/base/Exception.js":
/*!*******************************!*\
  !*** ./src/base/Exception.js ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Exception\": () => (/* binding */ Exception),\n/* harmony export */   \"Warning\": () => (/* binding */ Warning)\n/* harmony export */ });\nfunction Exception (code, message) {\n    throw new Error(code + \": \" + message);\n}\n\nfunction Warning (code, message) {\n    console.warn(code, message);\n}\n\n//# sourceURL=webpack://jsge/./src/base/Exception.js?");

/***/ }),

/***/ "./src/base/Logger.js":
/*!****************************!*\
  !*** ./src/base/Logger.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Logger\": () => (/* binding */ Logger)\n/* harmony export */ });\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../configs.js */ \"./src/configs.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n\n\n\nclass Logger {\n    static debug(...args) {\n        if (_configs_js__WEBPACK_IMPORTED_MODULE_0__.SystemSettings.mode === _constants_js__WEBPACK_IMPORTED_MODULE_1__.CONST.MODE.DEBUG)\n            args.forEach(message => console.log(message));\n    }\n}\n\n//# sourceURL=webpack://jsge/./src/base/Logger.js?");

/***/ }),

/***/ "./src/base/Primitives.js":
/*!********************************!*\
  !*** ./src/base/Primitives.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rectangle\": () => (/* binding */ Rectangle),\n/* harmony export */   \"Vector\": () => (/* binding */ Vector),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex)\n/* harmony export */ });\nclass Vertex {\n    #x;\n    #y;\n    constructor(x, y) {\n        this.#x = x;\n        this.#y = y;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n}\n\nclass Rectangle {\n    #x;\n    #y;\n    #w;\n    #h;\n    constructor(x, y, w, h) {\n        this.#x = x;\n        this.#y = y;\n        this.#w = w;\n        this.#h = h; \n    }\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n    /**\n     * @type {number}\n     */\n    get y() {\n        return this.#y;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n}\n\nclass Vector {\n    #x;\n    #y;\n    constructor(x1, y1, x2, y2) {\n        this.#x = x2 - x1;\n        this.#y = y2 - y1;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n\n    get length() {\n        return Math.sqrt(Math.pow(this.#x, 2) + Math.pow(this.#y, 2));\n    }\n\n    get tetaAngle() {\n        return Math.atan2(this.#y, this.#x);\n    }\n}\n\n\n\n//# sourceURL=webpack://jsge/./src/base/Primitives.js?");

/***/ }),

/***/ "./src/base/RenderInterface.js":
/*!*************************************!*\
  !*** ./src/base/RenderInterface.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RenderInterface\": () => (/* binding */ RenderInterface)\n/* harmony export */ });\n/* harmony import */ var _TiledRenderLayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TiledRenderLayer.js */ \"./src/base/TiledRenderLayer.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _WebGlInterface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGlInterface.js */ \"./src/base/WebGlInterface.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../configs.js */ \"./src/configs.js\");\n/* harmony import */ var _ScreenPageData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ScreenPageData.js */ \"./src/base/ScreenPageData.js\");\n/* harmony import */ var _modules_assetsm_dist_assetsm_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../modules/assetsm/dist/assetsm.min.js */ \"./modules/assetsm/dist/assetsm.min.js\");\n/* harmony import */ var _DrawImageObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DrawImageObject.js */ \"./src/base/DrawImageObject.js\");\n/* harmony import */ var _DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DrawCircleObject.js */ \"./src/base/DrawCircleObject.js\");\n/* harmony import */ var _DrawConusObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DrawConusObject.js */ \"./src/base/DrawConusObject.js\");\n/* harmony import */ var _DrawLineObject_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DrawLineObject.js */ \"./src/base/DrawLineObject.js\");\n/* harmony import */ var _DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./DrawPolygonObject.js */ \"./src/base/DrawPolygonObject.js\");\n/* harmony import */ var _DrawRectObject_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DrawRectObject.js */ \"./src/base/DrawRectObject.js\");\n/* harmony import */ var _DrawTextObject_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./DrawTextObject.js */ \"./src/base/DrawTextObject.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import { calculateBufferData } from \"../wa/release.js\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst INDEX_TOP_LINE = 0,\r\n    INDEX_RIGHT_LINE = 1,\r\n    INDEX_BOTTOM_LINE = 2,\r\n    INDEX_LEFT_LINE = 3;\r\n\r\nconst INDEX_X1 = 0,\r\n    INDEX_Y1 = 1,\r\n    INDEX_X2 = 2,\r\n    INDEX_Y2 = 3;\r\n\r\n/**\r\n * Canvas view represents each canvas on the page<br> \r\n * Should be created via ScreenPage.createCanvasView(),<br>\r\n * Contains draw logic and holds DrawObjects and Tile\r\n * Can retrieved by ScreenPage.getView()\r\n * @see {@link ScreenPage} a part of ScreenPage\r\n * @hideconstructor\r\n */\r\nclass RenderInterface {\r\n    /**\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    #canvas;\r\n    /**\r\n     * @type {WebGLRenderingContext}\r\n     */\r\n    #drawContext;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isCleared;\r\n    /**\r\n     * @type {WebGlInterface}\r\n     */\r\n    #webGlInterface;\r\n\r\n    /**\r\n     * SystemInterface.systemSettings\r\n     * @type {SystemSettings}\r\n     */\r\n    #systemSettingsReference;\r\n    /**\r\n     * @type {ScreenPageData}\r\n     */\r\n    #screenPageData;\r\n    /**\r\n     * A reference to the systemInterface.loader\r\n     * @type {AssetsManager}\r\n     */\r\n    #loaderReference;\r\n    #bindRenderLayerMethod;\r\n\r\n    constructor(systemSettings, loader) {\r\n        this.#isCleared = false;\r\n        this.#canvas = document.createElement(\"canvas\");\r\n        this.#drawContext = this.#canvas.getContext(\"webgl\", {stencil: true});\r\n\r\n        this.#systemSettingsReference = systemSettings;\r\n        this.#loaderReference = loader;\r\n\r\n        this.#screenPageData = new _ScreenPageData_js__WEBPACK_IMPORTED_MODULE_5__.ScreenPageData();\r\n        this.#webGlInterface = new _WebGlInterface_js__WEBPACK_IMPORTED_MODULE_3__.WebGlInterface(this.#drawContext, this.#systemSettingsReference.gameOptions.checkWebGlErrors);\r\n        this.#bindRenderLayerMethod = this.systemSettings.gameOptions.optimization === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT ? this.#bindRenderLayerWM : this.#bindRenderLayer;\r\n    }\r\n\r\n    get screenPageData() {\r\n        return this.#screenPageData;\r\n    }\r\n\r\n    get systemSettings() {\r\n        return this.#systemSettingsReference;\r\n    }\r\n\r\n    get loader() {\r\n        return this.#loaderReference;\r\n    }\r\n\r\n    get canvas() {\r\n        return this.#canvas;\r\n    }\r\n\r\n    get drawContext() {\r\n        return this.#drawContext;\r\n    }\r\n\r\n    initiateContext() {\r\n        return Promise.all([this.#webGlInterface._initiateImagesDrawProgram(),\r\n            this.#webGlInterface._initPrimitivesDrawProgram(), this.#webGlInterface._initWebGlAttributes()]);\r\n    }\r\n\r\n    clearContext() {\r\n        this.#webGlInterface._clearView();\r\n    }\r\n\r\n    setCanvasSize(width, height) {\r\n        this.#canvas.width = width;\r\n        this.#canvas.height = height;\r\n        if (this.#webGlInterface) {\r\n            this.#webGlInterface._fixCanvasSize(width, height);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {Promise<void>}\r\n     */\r\n    async render() {\r\n        return new Promise(async(resolve, reject) => {\r\n            //if (!this._isCleared) {\r\n            //    this.#clearWebGlContext();\r\n            //}\r\n            /*const renderLayers = this._renderLayers;\r\n            if (renderLayers.length !== 0) {\r\n                let renderLayerPromises = [];\r\n                for (const layer of renderLayers) {\r\n                    renderLayerPromises.push(this.#bindRenderLayerMethod(layer));\r\n                }\r\n                const bindResults = await Promise.allSettled(renderLayerPromises);\r\n                bindResults.forEach((result) => {\r\n                    if (result.status === \"rejected\") {\r\n                        reject(\"reason: \" + result.reason);\r\n                    }\r\n                });\r\n                await this.#webGlInterface._executeTileImagesDraw();\r\n            }*/\r\n            \r\n            const renderObjects = this.screenPageData.renderObjects;\r\n            if (renderObjects.length !== 0) {\r\n                let renderObjectsPromises = [];\r\n                //this.#checkCollisions(view.renderObjects);\r\n                for (let i = 0; i < renderObjects.length; i++) {\r\n                    const object = renderObjects[i];\r\n                    if (object.isRemoved) {\r\n                        renderObjects.splice(i, 1);\r\n                        i--;\r\n                    }\r\n                    //if (object.isAnimations) {\r\n                    //    object._processActiveAnimations();\r\n                    //}\r\n                    const promise = await this._bindRenderObject(object).catch((err) => {\r\n                        reject(err);\r\n                    });\r\n                    renderObjectsPromises.push(promise);\r\n                }\r\n                if (this.systemSettings.gameOptions.boundaries.drawLayerBoundaries) {\r\n                    renderObjectsPromises.push(this.#drawBoundariesWebGl().catch((err) => {\r\n                        reject(err);\r\n                    })); \r\n                }\r\n                //if (key === CONST.LAYERS.BOUNDARIES) {\r\n                //    renderObjectsPromises.push(this.#drawBoundariesWebGl().catch((err) => {\r\n                //        reject(err);\r\n                //    }));\r\n                //}\r\n                const bindResults = await Promise.allSettled(renderObjectsPromises);\r\n                bindResults.forEach((result) => {\r\n                    if (result.status === \"rejected\") {\r\n                        reject(result.reason);\r\n                    }\r\n                });\r\n\r\n                //await this.#webGlInterface._executeImagesDraw();\r\n\r\n                this.#postRenderActions();\r\n                    \r\n                this._isCleared = false;\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    _setCanvasSize(width, height) {\r\n        if (this.#webGlInterface) {\r\n            this.#webGlInterface._fixCanvasSize(width, height);\r\n        }\r\n    }\r\n\r\n    set _isCleared(value) {\r\n        this.#isCleared = value;\r\n    }\r\n\r\n    get _isCleared() {\r\n        return this.#isCleared;\r\n    }\r\n\r\n    _createBoundariesPrecalculations() {\r\n        //const promises = [];\r\n        //for (const layer of this.#renderLayers) {\r\n        //    promises.push(this.#layerBoundariesPrecalculation(layer).catch((err) => {\r\n        //        Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);\r\n        //    }));\r\n        //}\r\n        //return promises;\r\n    }\r\n\r\n    #clearWebGlContext() {\r\n        this.#webGlInterface._clearView();\r\n        this.#isCleared = true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {TiledRenderLayer} renderLayer \r\n     * @returns {Promise<void>}\r\n     */\r\n    #bindRenderLayerWM(renderLayer) {\r\n        return new Promise((resolve, reject) => {\r\n            const tilemap = this.loader.getTileMap(renderLayer.tileMapKey),\r\n                tilesets = tilemap.tilesets,\r\n                tilesetImages = tilesets.map((tileset) => this.loader.getImage(tileset.data.name)),\r\n                layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\r\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                setBoundaries = false;//, //renderLayer.setBoundaries,\r\n                //[ worldW, worldH ] = this.screenPageData.worldDimensions,\r\n                //[ canvasW, canvasH ] = this.screenPageData.drawDimensions,\r\n                //[ xOffset, yOffset ] = this.screenPageData.worldOffset;\r\n                \r\n            if (!layerData) {\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\r\n                reject();\r\n            }\r\n            for (let i = 0; i <= tilesets.length - 1; i++) {\r\n                const tileset = tilesets[i].data,\r\n                    //tilesetImages = this.loader.getTilesetImageArray(tileset.name),\r\n                    tilewidth = tileset.tilewidth,\r\n                    tileheight = tileset.tileheight,\r\n                    //atlasRows = tileset.imageheight / tileheight,\r\n                    atlasColumns = tileset.imagewidth / tilewidth,\r\n                    layerCols = layerData.width,\r\n                    layerRows = layerData.height,\r\n                    //visibleCols = Math.ceil(canvasW / tilewidth),\r\n                    //visibleRows = Math.ceil(canvasH / tileheight),\r\n                    //offsetCols = layerCols - visibleCols,\r\n                    //offsetRows = layerRows - visibleRows,\r\n                    atlasImage = tilesetImages[i],\r\n                    atlasWidth = atlasImage.width,\r\n                    atlasHeight = atlasImage.height;\r\n                    \r\n                //const [verticesBufferData, texturesBufferData] = calculateBufferData(layerRows, layerCols, layerData.data, dtwidth, dtheight, tilewidth, tileheight, atlasColumns, atlasWidth, atlasHeight, setBoundaries);\r\n                \r\n                this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tileset.name);\r\n                if (setBoundaries) {\r\n                    this.screenPageData._mergeBoundaries();\r\n                    renderLayer.setBoundaries = false;\r\n                }\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {TiledRenderLayer} renderLayer \r\n     * @returns {Promise<void>}\r\n     */\r\n    #bindRenderLayer(renderLayer) {\r\n        return new Promise((resolve, reject) => {\r\n            const tilemap = this.loader.getTileMap(renderLayer.tileMapKey),\r\n                tilesets = tilemap.tilesets,\r\n                tilesetImages = tilesets.map((tileset) => this.loader.getImage(tileset.data.name)),\r\n                layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\r\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                tilewidth = dtwidth,\r\n                tileheight = dtheight,\r\n                [ settingsWorldWidth, settingsWorldHeight ] = this.screenPageData.worldDimensions,\r\n                [ canvasW, canvasH ] = this.screenPageData.canvasDimensions,\r\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : this.screenPageData.worldOffset,\r\n                boundariesCalculations = this.systemSettings.gameOptions.render.boundaries.realtimeCalculations,\r\n                setBoundaries = renderLayer.setBoundaries && boundariesCalculations;\r\n                \r\n            let boundariesRowsIndexes = new Map(),\r\n                boundaries = [];\r\n\r\n            if (!layerData) {\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\r\n                reject();\r\n            }\r\n            \r\n            for (let i = 0; i < tilesets.length; i++) {\r\n                const tileset = tilesets[i].data,\r\n                    firstgid = tilesets[i].firstgid,\r\n                    nextTileset = tilesets[i + 1],\r\n                    nextgid = nextTileset ? nextTileset.firstgid : null,\r\n                    tilesetwidth = tileset.tilewidth,\r\n                    tilesetheight = tileset.tileheight,\r\n                    atlasImage = tilesetImages[i],\r\n                    //atlasWidth = atlasImage.width,\r\n                    //atlasHeight = atlasImage.height,\r\n                    atlasWidth = tileset.imagewidth,\r\n                    atlasHeight = tileset.imageheight,\r\n                    //atlasRows = atlasHeight / tileheight,\r\n                    atlasColumns = Math.floor(atlasWidth / tilesetwidth),\r\n                    layerCols = layerData.width,\r\n                    layerRows = layerData.height,\r\n                    worldW = tilewidth * layerCols,\r\n                    worldH = tileheight * layerRows,\r\n                    moduloTop = yOffset % tileheight,\r\n                    moduleLeft = xOffset % tilewidth,\r\n                    skipRowsTop = yOffset !== 0 ? Math.floor(yOffset / tileheight) : 0,\r\n                    skipColsLeft = xOffset !== 0 ? Math.floor(xOffset / tilewidth) : 0,\r\n                    // sometimes canvasW/H may be bigger than world itself\r\n                    screenRows = worldH > canvasH ? Math.ceil(canvasH / tileheight) + 1 : layerRows,\r\n                    screenCols = worldW > canvasW ? Math.ceil(canvasW / tilewidth) + 1 : layerCols,\r\n                    skipColsRight = layerCols - screenCols - skipColsLeft,\r\n\r\n                    verticesBufferData = [],\r\n                    texturesBufferData = [];\r\n                if (setBoundaries) {\r\n                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\r\n                        (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\r\n                        this.screenPageData._setWorldDimensions(worldW, worldH);\r\n                    }\r\n                    \r\n                    // boundaries cleanups every draw circle, we need to set world boundaries again\r\n                    if (this.screenPageData.isWorldBoundariesEnabled) {\r\n                        this.screenPageData._setMapBoundaries();\r\n                    }\r\n                }\r\n\r\n                let mapIndex = skipRowsTop * layerCols;\r\n\r\n                for (let row = 0; row < screenRows; row++) {\r\n                    mapIndex += skipColsLeft;\r\n                    let currentRowIndexes = new Map();\r\n\r\n                    for (let col = 0; col < screenCols; col++) {\r\n                        let tile = layerData.data[mapIndex];\r\n                        //if (tile !== 0)\r\n                        if (tile >= firstgid && (nextgid === null || tile < nextgid)) {\r\n                            const mapPosX = col * dtwidth - moduleLeft,\r\n                                mapPosY = row * dtheight - moduloTop;\r\n\r\n                            tile -= firstgid;\r\n                            const atlasPosX = tile % atlasColumns * tilesetwidth,\r\n                                atlasPosY = Math.floor(tile / atlasColumns) * tilesetheight,\r\n                                vecX1 = mapPosX,\r\n                                vecY1 = mapPosY,\r\n                                vecX2 = mapPosX + tilesetwidth,\r\n                                vecY2 = mapPosY + tilesetheight,\r\n                                texX1 = 1 / atlasWidth * atlasPosX,\r\n                                texY1 = 1 / atlasHeight * atlasPosY,\r\n                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),\r\n                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);\r\n                            verticesBufferData.push(\r\n                                vecX1, vecY1,\r\n                                vecX2, vecY1,\r\n                                vecX1, vecY2,\r\n                                vecX1, vecY2,\r\n                                vecX2, vecY1,\r\n                                vecX2, vecY2);\r\n                            texturesBufferData.push(\r\n                                texX1, texY1,\r\n                                texX2, texY1,\r\n                                texX1, texY2,\r\n                                texX1, texY2,\r\n                                texX2, texY1,\r\n                                texX2, texY2\r\n                            );\r\n                            \r\n                            if (setBoundaries) {\r\n                                let rightLine = [ mapPosX + tilesetwidth, mapPosY, mapPosX + tilesetwidth, mapPosY + tilesetheight ],\r\n                                    bottomLine = [ mapPosX + tilesetwidth, mapPosY + tilesetheight, mapPosX, mapPosY + tilesetheight ],\r\n                                    topLine = [ mapPosX, mapPosY, mapPosX + tilesetwidth, mapPosY],\r\n                                    leftLine = [ mapPosX, mapPosY + tilesetheight, mapPosX, mapPosY ],\r\n                                    currentAddedCellIndexes = [null, null, null, null];\r\n                                \r\n                                const topRow = row !== 0 ? boundariesRowsIndexes.get(row - 1) : undefined;\r\n                                if (topRow ) {\r\n                                    const topCellIndexes = topRow.get(col);\r\n                                    if (topCellIndexes) {\r\n                                        //remove double lines from top\r\n                                        const bottomTopCellIndex = topCellIndexes[INDEX_BOTTOM_LINE],\r\n                                            bottomTopCell = boundaries[bottomTopCellIndex];\r\n                                        if (bottomTopCell) {\r\n                                            const bottomTopCellX1 = bottomTopCell[INDEX_X1],\r\n                                                bottomTopCellY1 = bottomTopCell[INDEX_Y1],\r\n                                                bottomTopCellX2 = bottomTopCell[INDEX_X2],\r\n                                                bottomTopCellY2 = bottomTopCell[INDEX_Y2],\r\n                                                topX1 = topLine[INDEX_X1],\r\n                                                topY1 = topLine[INDEX_Y1],\r\n                                                topX2 = topLine[INDEX_X2],\r\n                                                topY2 = topLine[INDEX_Y2];\r\n                                            \r\n                                            if (topX1 === bottomTopCellX2 && topY1 === bottomTopCellY2 &&\r\n                                                topX2 === bottomTopCellX1 && topY2 === bottomTopCellY1) {\r\n                                                boundaries[bottomTopCellIndex] = undefined;\r\n                                                topLine = undefined;\r\n                                            }\r\n                                        }\r\n\r\n                                        // merge line from top right\r\n                                        const rightTopCellIndex = topCellIndexes[INDEX_RIGHT_LINE],\r\n                                            rightTopCell = boundaries[rightTopCellIndex];\r\n                                        if (rightTopCell) {\r\n                                            const rightTopCellX1 = rightTopCell[INDEX_X1],\r\n                                                rightTopCellY1 = rightTopCell[INDEX_Y1],\r\n                                                rightTopCellX2 = rightTopCell[INDEX_X2],\r\n                                                rightX1 = rightLine[INDEX_X1],\r\n                                                rightX2 = rightLine[INDEX_X2];\r\n                                            if (rightTopCellX1 === rightX2 && rightTopCellX2 === rightX1) {\r\n                                                boundaries[rightTopCellIndex] = undefined;\r\n                                                rightLine[INDEX_X1] = rightTopCellX1;\r\n                                                rightLine[INDEX_Y1] = rightTopCellY1;\r\n                                            }\r\n                                        }\r\n                                        // merge line from top left\r\n                                        const leftTopCellIndex = topCellIndexes[INDEX_LEFT_LINE],\r\n                                            leftTopCell = boundaries[leftTopCellIndex];\r\n                                        if (leftTopCell) {\r\n                                            const leftTopCellX1 = leftTopCell[INDEX_X1],\r\n                                                leftTopCellX2 = leftTopCell[INDEX_X2],\r\n                                                leftTopCellY2 = leftTopCell[INDEX_Y2],\r\n                                                leftX1 = leftLine[INDEX_X1],\r\n                                                leftX2 = leftLine[INDEX_X2];\r\n                                            if (leftTopCellX1 === leftX2 && leftTopCellX2 === leftX1) {\r\n                                                boundaries[leftTopCellIndex] = undefined;\r\n                                                leftLine[INDEX_X2] = leftTopCellX2;\r\n                                                leftLine[INDEX_Y2] = leftTopCellY2;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                const leftCellIndexes = col !== 0 ? currentRowIndexes.get(col - 1) : undefined;\r\n                                if (leftCellIndexes) {\r\n\r\n                                    //remove double lines from left\r\n                                    const rightLeftCellIndex = leftCellIndexes[INDEX_RIGHT_LINE],\r\n                                        rightLeftCell = boundaries[rightLeftCellIndex],\r\n                                        rightLeftCellX1 = rightLeftCell[INDEX_X1],\r\n                                        rightLeftCellY1 = rightLeftCell[INDEX_Y1],\r\n                                        rightLeftCellX2 = rightLeftCell[INDEX_X2],\r\n                                        rightLeftCellY2 = rightLeftCell[INDEX_Y2],\r\n                                        leftX1 = leftLine[INDEX_X1],\r\n                                        leftY1 = leftLine[INDEX_Y1],\r\n                                        leftX2 = leftLine[INDEX_X2],\r\n                                        leftY2 = leftLine[INDEX_Y2];\r\n\r\n                                    if (leftX1 === rightLeftCellX2 && leftY1 === rightLeftCellY2 &&\r\n                                        leftX2 === rightLeftCellX1 && leftY2 === rightLeftCellY1) {\r\n                                        boundaries[rightLeftCellIndex] = undefined;\r\n                                        leftLine = undefined;\r\n                                    }\r\n\r\n                                    //merge long lines from left top\r\n                                    const topLeftCellIndex = leftCellIndexes[INDEX_TOP_LINE],\r\n                                        topLeftCell = boundaries[topLeftCellIndex];\r\n                                    if (topLeftCell && topLine) {\r\n                                        const topLeftCellX1 = topLeftCell[INDEX_X1],\r\n                                            topLeftCellY1 = topLeftCell[INDEX_Y1],\r\n                                            topLeftCellY2 = topLeftCell[INDEX_Y2],\r\n                                            topY1 = topLine[INDEX_Y1],\r\n                                            topY2 = topLine[INDEX_Y2];\r\n                                        if (topLeftCellY1 === topY2 && topLeftCellY2 === topY1 ) {\r\n                                            boundaries[topLeftCellIndex] = undefined;\r\n                                            topLine[INDEX_X1] = topLeftCellX1;\r\n                                            topLine[INDEX_Y1] = topLeftCellY1;\r\n                                        }\r\n                                    }\r\n\r\n                                    // merge long lines from left bottom\r\n                                    const bottomLeftCellIndex = leftCellIndexes[INDEX_BOTTOM_LINE],\r\n                                        bottomLeftCell = boundaries[bottomLeftCellIndex];\r\n                                    if (bottomLeftCell) {\r\n                                        const bottomLeftCellY1 = bottomLeftCell[INDEX_Y1],\r\n                                            bottomLeftCellX2 = bottomLeftCell[INDEX_X2],\r\n                                            bottomLeftCellY2 = bottomLeftCell[INDEX_Y2],\r\n                                            bottomY1 = bottomLine[INDEX_Y1],\r\n                                            bottomY2 = bottomLine[INDEX_Y2];\r\n                                        if (bottomLeftCellY1 === bottomY2 && bottomLeftCellY2 === bottomY1 ) {\r\n                                            boundaries[bottomLeftCellIndex] = undefined;\r\n                                            //opposite direction\r\n                                            bottomLine[INDEX_X2] = bottomLeftCellX2;\r\n                                            bottomLine[INDEX_Y2] = bottomLeftCellY2;\r\n                                        }\r\n                                    }\r\n\r\n                                }\r\n\r\n                                if (topLine) {\r\n                                    boundaries.push(topLine);\r\n                                    currentAddedCellIndexes[INDEX_TOP_LINE] = boundaries.length - 1;\r\n                                }\r\n                                boundaries.push(rightLine);\r\n                                currentAddedCellIndexes[INDEX_RIGHT_LINE] = boundaries.length - 1;\r\n                                boundaries.push(bottomLine);\r\n                                currentAddedCellIndexes[INDEX_BOTTOM_LINE] = boundaries.length - 1;\r\n                                if (leftLine) {\r\n                                    boundaries.push(leftLine);\r\n                                    currentAddedCellIndexes[INDEX_LEFT_LINE] = boundaries.length - 1;\r\n                                }\r\n                                //save values indexes cols info\r\n                                currentRowIndexes.set(col, currentAddedCellIndexes);\r\n                            }\r\n\r\n                        }\r\n                        mapIndex++;\r\n                    }\r\n                    if (currentRowIndexes.size > 0) {\r\n                        //save values indexes rows info\r\n                        boundariesRowsIndexes.set(row, currentRowIndexes);\r\n                    }\r\n                    mapIndex += skipColsRight;\r\n                }\r\n                if (verticesBufferData.length > 0 && texturesBufferData.length > 0) {\r\n                    this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tileset.name, renderLayer._maskId);\r\n                }\r\n            }\r\n            \r\n            if (setBoundaries) {\r\n                // filter undefined value\r\n                const filtered = boundaries.filter(array => array);\r\n                this.screenPageData._addBoundariesArray(filtered);\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    #postRenderActions() {\r\n        const images = this.screenPageData.getObjectsByInstance(_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_7__.DrawImageObject);\r\n        for (let i = 0; i < images.length; i++) {\r\n            const object = images[i];\r\n            if (object.isAnimations) {\r\n                object._processActiveAnimations();\r\n            }\r\n        }\r\n    }\r\n\r\n    #bindTileImages(verticesBufferData, texturesBufferData, atlasImage, image_name, shapeMaskId, drawMask, rotation, translation) {\r\n        this.#webGlInterface._bindTileImages(verticesBufferData, texturesBufferData, atlasImage, image_name, shapeMaskId, drawMask, rotation, translation);\r\n    }\r\n\r\n    //#clearTileMapPromises() {\r\n    //    this.#bindTileMapPromises = [];\r\n    //}\r\n\r\n    /**\r\n     * \r\n     * @param {TiledRenderLayer} renderLayer \r\n     * @returns {Promise<void>}\r\n     */\r\n    #layerBoundariesPrecalculation(renderLayer) {\r\n        return new Promise((resolve, reject) => {\r\n            if (renderLayer.setBoundaries) {\r\n                const tilemap = this.loader.getTileMap(renderLayer.tileMapKey),\r\n                    tilesets = tilemap.tilesets,\r\n                    layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\r\n                    { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                    tilewidth = dtwidth,\r\n                    tileheight = dtheight,\r\n                    [ settingsWorldWidth, settingsWorldHeight ] = this.screenPageData.worldDimensions;\r\n                \r\n                let boundaries = [];\r\n\r\n                if (!layerData) {\r\n                    (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\r\n                    reject();\r\n                }\r\n                \r\n                for (let i = 0; i < tilesets.length; i++) {\r\n                    const layerCols = layerData.width,\r\n                        layerRows = layerData.height,\r\n                        worldW = tilewidth * layerCols,\r\n                        worldH = tileheight * layerRows;\r\n\r\n                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\r\n                        (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_2__.WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\r\n                        this.screenPageData._setWorldDimensions(worldW, worldH);\r\n                    }\r\n                    \r\n                    if (this.screenPageData.isWorldBoundariesEnabled) {\r\n                        this.screenPageData._setWholeWorldMapBoundaries();\r\n                    }\r\n\r\n                    //calculate boundaries\r\n                    let mapIndex = 0;\r\n\r\n                    for (let row = 0; row < layerRows; row++) {\r\n                        for (let col = 0; col < layerCols; col++) {\r\n                            let tile = layerData.data[mapIndex],\r\n                                mapPosX = col * tilewidth,\r\n                                mapPosY = row * tileheight;\r\n                            if (tile !== 0) {\r\n                                tile -= 1;\r\n                                \r\n                                boundaries.push([mapPosX, mapPosY, mapPosX + tilewidth, mapPosY]);\r\n                                boundaries.push([mapPosX + tilewidth, mapPosY, mapPosX + tilewidth, mapPosY + tileheight]);\r\n                                boundaries.push([mapPosX + tilewidth, mapPosY + tileheight, mapPosX, mapPosY + tileheight]);\r\n                                boundaries.push([mapPosX, mapPosY + tileheight, mapPosX, mapPosY ]);\r\n    \r\n                            }\r\n                            mapIndex++;\r\n                        }\r\n                    }\r\n                }\r\n                this.screenPageData._setWholeMapBoundaries(boundaries);\r\n                this.screenPageData._mergeBoundaries(true);\r\n                console.warn(\"precalculated boundaries set\");\r\n                console.log(this.screenPageData.getWholeWorldBoundaries());\r\n                resolve();\r\n            } else {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | TiledRenderLayer} renderObject \r\n     * @returns {Promise<void>}\r\n     */\r\n    _bindRenderObject(renderObject) {\r\n        if (renderObject instanceof _TiledRenderLayer_js__WEBPACK_IMPORTED_MODULE_0__.TiledRenderLayer) {\r\n            return this.#bindRenderLayerMethod(renderObject)\r\n                .then(() => this.#webGlInterface._executeTileImagesDraw());\r\n        } else {\r\n            return new Promise((resolve) => {\r\n                const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : this.screenPageData.worldOffset,\r\n                    x = renderObject.x - xOffset,\r\n                    y = renderObject.y - yOffset;\r\n\r\n                if (renderObject.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.DRAW_TYPE.IMAGE) {\r\n                    const atlasImage = this.loader.getImage(renderObject.key),\r\n                        animationIndex = renderObject.imageIndex;\r\n                    let imageX = 0,\r\n                        imageY = 0;\r\n                    if (animationIndex !== 0) {\r\n                        const imageColsNumber = atlasImage.width / renderObject.width;\r\n                        imageX = animationIndex % imageColsNumber * renderObject.width,\r\n                        imageY = Math.floor(animationIndex / imageColsNumber) * renderObject.height;\r\n                    }\r\n                    const posX = x - renderObject.width / 2,\r\n                        posY = y - renderObject.height / 2;\r\n                    const vecX1 = posX,\r\n                        vecY1 = posY,\r\n                        vecX2 = vecX1 + renderObject.width,\r\n                        vecY2 = vecY1 + renderObject.height,\r\n                        texX1 = 1 / atlasImage.width * imageX,\r\n                        texY1 = 1 / atlasImage.height * imageY,\r\n                        texX2 = texX1 + (1 / atlasImage.width * renderObject.width),\r\n                        texY2 = texY1 + (1 / atlasImage.height * renderObject.height);\r\n                    const verticesBufferData = [\r\n                            vecX1, vecY1,\r\n                            vecX2, vecY1,\r\n                            vecX1, vecY2,\r\n                            vecX1, vecY2,\r\n                            vecX2, vecY1,\r\n                            vecX2, vecY2\r\n                        ],\r\n                        texturesBufferData = [\r\n                            texX1, texY1,\r\n                            texX2, texY1,\r\n                            texX1, texY2,\r\n                            texX1, texY2,\r\n                            texX2, texY1,\r\n                            texX2, texY2\r\n                        ];\r\n                    this.#webGlInterface._bindAndDrawTileImages(verticesBufferData, texturesBufferData, atlasImage, renderObject.key, renderObject.rotation, [x, y], [1, 1], renderObject._maskId);\r\n                    if (renderObject.vertices && this.systemSettings.gameOptions.boundaries.drawObjectBoundaries) {\r\n                        const shiftX = x,// - renderObject.boundaries[0],\r\n                            shiftY = y,// - renderObject.boundaries[1],\r\n                            rotation = renderObject.rotation ? renderObject.rotation : 0;\r\n                        this.#webGlInterface._drawPolygon(renderObject.vertices, this.systemSettings.gameOptions.boundaries.boundariesColor, this.systemSettings.gameOptions.boundaries.boundariesWidth, rotation, [shiftX, shiftY]);\r\n                    }\r\n                    //ctx.restore();\r\n                } else if (renderObject.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.DRAW_TYPE.TEXT) {\r\n                    this.#webGlInterface._bindText(x, y, renderObject);\r\n                } else if (renderObject.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.DRAW_TYPE.CIRCLE || renderObject.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.DRAW_TYPE.CONUS) {\r\n                    this.#webGlInterface._bindConus(renderObject, renderObject.rotation, [x, y]);\r\n                } else if (renderObject.type === _constants_js__WEBPACK_IMPORTED_MODULE_2__.CONST.DRAW_TYPE.LINE) {\r\n                    this.#webGlInterface._drawLines(renderObject.vertices, renderObject.bgColor, this.systemSettings.gameOptions.boundariesWidth, renderObject.rotation, [x, y]);\r\n                } else {\r\n                    this.#webGlInterface._bindPrimitives(renderObject, renderObject.rotation, [x, y]);\r\n                }\r\n                return resolve();\r\n            });\r\n        }\r\n    }\r\n\r\n    //#clearRenderObjectPromises() {\r\n    //    this.#bindRenderObjectPromises = [];\r\n    //}\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    #drawBoundariesWebGl() {\r\n        return new Promise((resolve) => {\r\n            const b = this.screenPageData.getBoundaries(),\r\n                len = b.length,\r\n                linesArray = [];\r\n        \r\n            for (let i = 0; i < len; i++) {\r\n                const item = b[i];\r\n                linesArray.push(item[0], item[1]);\r\n                linesArray.push(item[2], item[3]);\r\n            }\r\n            this.#webGlInterface._drawLines(linesArray, this.systemSettings.gameOptions.boundaries.boundariesColor, this.systemSettings.gameOptions.boundaries.boundariesWidth);\r\n            resolve();\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/RenderInterface.js?");

/***/ }),

/***/ "./src/base/ScreenPage.js":
/*!********************************!*\
  !*** ./src/base/ScreenPage.js ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScreenPage\": () => (/* binding */ ScreenPage)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _ScreenPageData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ScreenPageData.js */ \"./src/base/ScreenPageData.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n/* harmony import */ var _Logger_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Logger.js */ \"./src/base/Logger.js\");\n/* harmony import */ var _modules_assetsm_dist_assetsm_min_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../modules/assetsm/dist/assetsm.min.js */ \"./modules/assetsm/dist/assetsm.min.js\");\n/* harmony import */ var _TiledRenderLayer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TiledRenderLayer.js */ \"./src/base/TiledRenderLayer.js\");\n/* harmony import */ var _RenderInterface_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RenderInterface.js */ \"./src/base/RenderInterface.js\");\n/* harmony import */ var _DrawObjectFactory_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DrawObjectFactory.js */ \"./src/base/DrawObjectFactory.js\");\n/* harmony import */ var _DrawCircleObject_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DrawCircleObject.js */ \"./src/base/DrawCircleObject.js\");\n/* harmony import */ var _DrawConusObject_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DrawConusObject.js */ \"./src/base/DrawConusObject.js\");\n/* harmony import */ var _DrawImageObject_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DrawImageObject.js */ \"./src/base/DrawImageObject.js\");\n/* harmony import */ var _DrawLineObject_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./DrawLineObject.js */ \"./src/base/DrawLineObject.js\");\n/* harmony import */ var _DrawPolygonObject_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DrawPolygonObject.js */ \"./src/base/DrawPolygonObject.js\");\n/* harmony import */ var _DrawRectObject_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./DrawRectObject.js */ \"./src/base/DrawRectObject.js\");\n/* harmony import */ var _DrawTextObject_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./DrawTextObject.js */ \"./src/base/DrawTextObject.js\");\n/* harmony import */ var _SystemInterface_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./SystemInterface.js */ \"./src/base/SystemInterface.js\");\n/* harmony import */ var _SystemAudioInterface_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./SystemAudioInterface.js */ \"./src/base/SystemAudioInterface.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../configs.js */ \"./src/configs.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../utils.js */ \"./src/utils.js\");\n/* harmony import */ var _Primitives_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Primitives.js */ \"./src/base/Primitives.js\");\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Represents the page of the game,<br>\r\n * Register and holds CanvasInterface.<br>\r\n * Contains pages logic.<br>\r\n * Instances should be created and registered with System.registerPage() factory method\r\n * \r\n * @see {@link System} instances of this class holds by the System class\r\n * @hideconstructor\r\n */\r\nclass ScreenPage {\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #name;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isInitiated = false;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isActive;\r\n    /**\r\n     * @type {SystemInterface}\r\n     */\r\n    #systemReference;\r\n    /**\r\n     * @type {RenderInterface}\r\n     */\r\n    #renderInterface;\r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    #tempFPStime;\r\n    /**\r\n     * @type {NodeJS.Timer}\r\n     */\r\n    #fpsAverageCountTimer;\r\n    /**\r\n     * @type {EventTarget}\r\n     */\r\n    #emitter = new EventTarget();\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isBoundariesPrecalculations = false;\r\n    #minCircleTime;\r\n\r\n    constructor() {\r\n        this.#isActive = false;\r\n        //this.#views = new Map();\r\n        this.#tempFPStime = [];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param  {...any} eventParams \r\n     */\r\n    emit = (eventName, ...eventParams) => {\r\n        const event = new Event(eventName);\r\n        event.data = [...eventParams];\r\n        this.#emitter.dispatchEvent(event);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    addEventListener = (eventName, listener, options) => {\r\n        this.#emitter.addEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    removeEventListener = (eventName, listener, options) => {\r\n        this.#emitter.removeEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * Register stage\r\n     * @param {string} name\r\n     * @param {SystemInterface} system \r\n     * @ignore\r\n     */\r\n    _register(name, system) {\r\n        this.#name = name;\r\n        this.#systemReference = system;\r\n        this.#isBoundariesPrecalculations = this.systemSettings.gameOptions.render.boundaries.wholeWorldPrecalculations;\r\n        this.#minCircleTime = this.systemSettings.gameOptions.render.minCircleTime;\r\n        this.#renderInterface = new _RenderInterface_js__WEBPACK_IMPORTED_MODULE_6__.RenderInterface(this.#systemReference.systemSettings, this.loader);\r\n        this.#setWorldDimensions();\r\n        this.#setCanvasSize();\r\n        this.register();\r\n    }\r\n\r\n    /**\r\n     * Initialization stage\r\n     * @ignore\r\n     */\r\n    _init() {\r\n        this.init();\r\n        this.#isInitiated = true;\r\n    }\r\n\r\n    /**\r\n     * @tutorial screen_pages_stages\r\n     * Custom logic for register stage\r\n     */\r\n    register() {}\r\n    /**\r\n     * @tutorial screen_pages_stages\r\n     * Custom logic for init stage\r\n     */\r\n    init() {}\r\n    /**\r\n     * Custom logic for start stage\r\n     * @param {Object=} options\r\n     */\r\n    start(options) {}\r\n    /**\r\n     * @tutorial screen_pages_stages\r\n     * Custom logic for stop stage\r\n     */\r\n    stop() {}\r\n    /**\r\n     * Custom logic for resize stage\r\n     */\r\n    resize() {}\r\n\r\n    /**\r\n     * @tutorial assets_manager\r\n     * @type {AssetsManager}\r\n     */\r\n    get loader() {\r\n        return this.#systemReference.loader;\r\n    }\r\n\r\n    /**\r\n     * @type {DrawObjectFactory}\r\n     */\r\n    get draw() {\r\n        return this.#systemReference.drawObjectFactory;\r\n    }\r\n\r\n    /**\r\n     * Creates new canvas layer\r\n     * and set it to the #views\r\n     * @param {string} name\r\n     * @param {boolean} [isOffsetTurnedOff = false] - determines if offset is affected on this layer or not\r\n     * @returns {CanvasView}\r\n     */\r\n    createCanvasView = (name, isOffsetTurnedOff = false) => {\r\n        if (name && name.trim().length > 0) {\r\n            console.warn(\"createCanvasView is deprecated\");\r\n            //const newView = new CanvasView(name, this.#system.systemSettings, this.#screenPageData, this.loader, this.system.webGlInterface, isOffsetTurnedOff);\r\n            //this.#views.set(name, newView);\r\n            return {};//newView;\r\n        } else\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.UNEXPECTED_INPUT_PARAMS);\r\n    };\r\n\r\n    /**\r\n     * Attach all canvas elements from the #views to container\r\n     * @param {HTMLElement} container\r\n     * @ignore\r\n     */\r\n    _attachViewsToContainer(container) {\r\n        this.#attachElementToContainer(this.canvasHtmlElement, container);\r\n        //for (const view of this.#views.values()) {\r\n        //    this.#attachElementToContainer(view.canvas, container);\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * Add render object to the view\r\n     * @param {string} canvasKey \r\n     * @param { DrawConusObject | DrawImageObject | \r\n     *          DrawLineObject | DrawPolygonObject | \r\n     *          DrawRectObject | DrawCircleObject | \r\n     *          DrawTextObject } renderObject \r\n     */\r\n    addRenderObject = (canvasKey, renderObject) => {\r\n        if (!canvasKey) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CANVAS_KEY_NOT_SPECIFIED, \", should pass canvasKey as 3rd parameter\");\r\n        //} else if (!this.#views.has(canvasKey)) {\r\n        //    Exception(ERROR_CODES.CANVAS_WITH_KEY_NOT_EXIST, \", should create canvas view, with \" + canvasKey + \" key first\");\r\n        } else {\r\n            //const view = this.#views.get(canvasKey);\r\n            const data = this.screenPageData;\r\n            data._renderObject = renderObject;\r\n            data._sortRenderObjectsBySortIndex();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Add render layer to the view\r\n     * @param {string} canvasKey \r\n     * @param {string} layerKey \r\n     * @param {string} tileMapKey \r\n     * @param {boolean=} setBoundaries \r\n     * @param {DrawShapeObject=} shapeMask\r\n     */\r\n    addRenderLayer = (canvasKey, layerKey, tileMapKey, setBoundaries, shapeMask) => {\r\n        if (!canvasKey) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CANVAS_KEY_NOT_SPECIFIED, \", should pass canvasKey as 3rd parameter\");\r\n        //} else if (!this.#views.has(canvasKey)) {\r\n        //    Exception(ERROR_CODES.CANVAS_WITH_KEY_NOT_EXIST, \", should create canvas view, with \" + canvasKey + \" key first\");\r\n        } else {\r\n            //const view = this.#views.get(canvasKey);\r\n            const data = this.screenPageData;\r\n            data._renderObject = new _TiledRenderLayer_js__WEBPACK_IMPORTED_MODULE_5__.TiledRenderLayer(layerKey, tileMapKey, setBoundaries, shapeMask);\r\n            if (setBoundaries && this.systemSettings.gameOptions.render.boundaries.mapBoundariesEnabled) {\r\n                data._enableMapBoundaries();\r\n            }\r\n            data._sortRenderObjectsBySortIndex();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determines if this page render is Active or not\r\n     * @type {boolean}\r\n     */\r\n    get isActive() {\r\n        return this.#isActive;\r\n    }\r\n\r\n    /**\r\n     * Determines if this page is initialized or not\r\n     * @type {boolean}\r\n     */\r\n    get isInitiated() {\r\n        return this.#isInitiated;\r\n    }\r\n\r\n    /**\r\n     * Current page name\r\n     * @type {string}\r\n     */\r\n    get name () {\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * Determines if all added files was loaded or not\r\n     * @returns {boolean}\r\n     */\r\n    isAllFilesLoaded = () => {\r\n        return this.loader.filesWaitingForUpload === 0;\r\n    };\r\n\r\n    /**\r\n     * @type {ScreenPageData}\r\n     */\r\n    get screenPageData() {\r\n        return this.#renderInterface.screenPageData;\r\n    }\r\n\r\n    /**\r\n     * @type {SystemSettings}\r\n     */\r\n    get systemSettings() {\r\n        return this.#systemReference.systemSettings;\r\n    }\r\n\r\n    /**\r\n     * @type {SystemAudioInterface}\r\n     */\r\n    get audio() {\r\n        return this.#systemReference.audio;\r\n    }\r\n\r\n    /**\r\n     * @type {SystemInterface}\r\n     */\r\n    get system() {\r\n        return this.#systemReference;\r\n    }\r\n\r\n    get canvasHtmlElement() {\r\n        return this.#renderInterface.canvas;\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    get canvasInterface() {\r\n        return this.#renderInterface;\r\n    }\r\n    \r\n    /**\r\n     * @method\r\n     * @param {string} key \r\n     * @returns {CanvasView | undefined}\r\n     */\r\n    getView = (key) => {\r\n        console.warn(\"ScreenPage.getView() is deprecated. Use ScreenPage.canvas instead\");\r\n        return;\r\n        /*\r\n        const ctx = this.#views.get(key);\r\n        if (ctx) {\r\n            return this.#views.get(key);\r\n        } else {\r\n            Exception(ERROR_CODES.CANVAS_WITH_KEY_NOT_EXIST, \", cannot find canvas with key \" + key);\r\n        }*/\r\n    };\r\n\r\n    /**\r\n     * Start page render\r\n     * @param {Object=} options \r\n     * @ignore\r\n     */\r\n    _start(options) {\r\n        this.#isActive = true;\r\n        window.addEventListener(\"resize\", this._resize);\r\n        this._resize();\r\n        //if (this.#views.size > 0) {\r\n            requestAnimationFrame(this.#render);\r\n        //}\r\n        this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.START_PAGE);\r\n        this.start(options);\r\n    }\r\n\r\n    /**\r\n     * Stop page render\r\n     * @ignore\r\n     */\r\n    _stop() {\r\n        this.#isActive = false;\r\n        window.removeEventListener(\"resize\", this._resize);\r\n        this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.STOP_PAGE);\r\n        this.#removeCanvasFromDom();\r\n        clearInterval(this.#fpsAverageCountTimer);\r\n        this.stop();\r\n    }\r\n\r\n    /**\r\n     * Resize event\r\n     * @ignore\r\n     */\r\n    _resize = () => {\r\n        this.#setCanvasSize();\r\n        this.resize();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {HTMLCanvasElement} htmlElement \r\n     * @param {HTMLElement} container \r\n     */\r\n    #attachElementToContainer(htmlElement, container) {\r\n        container.appendChild(htmlElement);\r\n    }\r\n\r\n    #removeCanvasFromDom() {\r\n        for (const canvas of document.getElementsByTagName(\"canvas\")) {\r\n            canvas.remove();\r\n        }\r\n        //for (const view of this.#views.values()) {\r\n        //        document.getElementById(view.canvas.id).remove();\r\n        //    }\r\n    }\r\n\r\n    #setWorldDimensions() {\r\n        const width = this.systemSettings.worldSize ? this.systemSettings.worldSize.width : 0,\r\n            height = this.systemSettings.worldSize ? this.systemSettings.worldSize.height : 0;\r\n            \r\n        this.screenPageData._setWorldDimensions(width, height);\r\n    }\r\n\r\n    #isPolygonToObjectsCollision(x, y, polygonVertices, polygonRotation, objects) {\r\n        const len = objects.length;\r\n        let collisions = [];\r\n        for (let i = 0; i < len; i++) {\r\n            const mapObject = objects[i],\r\n                drawMapObjectType = mapObject.type;\r\n\r\n            let coll;\r\n            \r\n            switch(drawMapObjectType) {\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.TEXT:\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.RECTANGLE:\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CONUS:\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.IMAGE:\r\n                coll = this.#isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject);\r\n                break;\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CIRCLE:\r\n                console.warn(\"isObjectCollision.circle check is not implemented yet!\");\r\n                break;\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.LINE:\r\n                console.warn(\"isObjectCollision.line check is not implemented, please use rect instead\");\r\n                break;\r\n            default:\r\n                console.warn(\"unknown object type!\");\r\n            }\r\n            if (coll) {\r\n                collisions.push(coll);\r\n            }\r\n        }\r\n        if (collisions.length > 0) {\r\n            return this.#takeTheClosestCollision(collisions);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {Array<Array<number>>} polygon\r\n     * @param {number} rotation \r\n     * @returns {{x:number, y:number, p:number} | boolean}\r\n     */\r\n    #isPolygonToBoundariesCollision(x, y, polygon, rotation) {\r\n        //console.log(\"angle: \", rotation);\r\n        //console.log(\"boundaries before calculations: \");\r\n        //console.log(polygon);\r\n        const mapObjects = this.screenPageData.getBoundaries(),\r\n            [mapOffsetX, mapOffsetY] = this.screenPageData.worldOffset,\r\n            xWithOffset = x - mapOffsetX,\r\n            yWithOffset = y - mapOffsetY,\r\n            polygonWithOffsetAndRotation = polygon.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, rotation))),\r\n            len = mapObjects.length;\r\n            \r\n        for (let i = 0; i < len; i+=1) {\r\n            const item = mapObjects[i];\r\n            const object = {\r\n                    x1: item[0],\r\n                    y1: item[1],\r\n                    x2: item[2],\r\n                    y2: item[3]\r\n                },\r\n                intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_18__.isPolygonLineIntersect)(polygonWithOffsetAndRotation, object);\r\n            if (intersect) {\r\n                //console.log(\"rotation: \", rotation);\r\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                //console.log(\"intersect: \", intersect);\r\n                return intersect;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    #takeTheClosestCollision(collisions) {\r\n        return collisions.sort((a,b) => a.p < b.p)[0];\r\n    }\r\n\r\n    #isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject) {\r\n        const [mapOffsetX, mapOffsetY] = this.screenPageData.worldOffset,\r\n            xWithOffset = x - mapOffsetX,\r\n            yWithOffset = y - mapOffsetY,\r\n            mapObjXWithOffset = mapObject.x - mapOffsetX,\r\n            mapObjYWithOffset = mapObject.y - mapOffsetY,\r\n            mapObjVertices = mapObject.vertices, \r\n            mapObjRotation = mapObject.rotation,\r\n            polygonWithOffsetAndRotation = polygonVertices.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, polygonRotation))),\r\n            len = mapObjVertices.length;\r\n        //console.log(\"map object check:\");\r\n        //console.log(mapObject);\r\n        for (let i = 0; i < len; i+=1) {\r\n            const mapObjFirstVertex = mapObjVertices[i];\r\n            let mapObjNextVertex = mapObjVertices[i + 1];\r\n            if (!mapObjNextVertex) {\r\n                mapObjNextVertex = mapObjVertices[0];\r\n            }\r\n            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\r\n                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\r\n                edge = {\r\n                    x1: vertex[0],\r\n                    y1: vertex[1],\r\n                    x2: nextVertex[0],\r\n                    y2: nextVertex[1]\r\n                },\r\n                intersect = (0,_utils_js__WEBPACK_IMPORTED_MODULE_18__.isPolygonLineIntersect)(polygonWithOffsetAndRotation, edge);\r\n            if (intersect) {\r\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                //console.log(\"intersect: \", intersect);\r\n                return intersect;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    #calculateShiftedVertexPos(vertex, centerX, centerY, rotation) {\r\n        const vector = new _Primitives_js__WEBPACK_IMPORTED_MODULE_19__.Vector(0, 0, vertex[0], vertex[1]),\r\n            vertexAngle = (0,_utils_js__WEBPACK_IMPORTED_MODULE_18__.angle_2points)(0, 0, vertex[0], vertex[1]),\r\n            len = vector.length;\r\n        //console.log(\"coords without rotation: \");\r\n        //console.log(x + vertex.x);\r\n        //console.log(y + vertex.y);\r\n        //console.log(\"len: \", len);\r\n        //console.log(\"angle: \", rotation);\r\n        const newX = centerX + (len * Math.cos(rotation + vertexAngle)),\r\n            newY = centerY + (len * Math.sin(rotation + vertexAngle));\r\n        return [newX, newY];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {DrawImageObject} drawObject \r\n     * @returns {{x:number, y:number, p:number} | boolean}\r\n     */\r\n    isBoundariesCollision = (x, y, drawObject) => {\r\n        const drawObjectType = drawObject.type,\r\n            vertices = drawObject.vertices;\r\n        switch(drawObjectType) {\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.TEXT:\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.RECTANGLE:\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CONUS:\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.IMAGE:\r\n            return this.#isPolygonToBoundariesCollision(x, y, vertices, drawObject.rotation);\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CIRCLE:\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\r\n            break;\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.LINE:\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\r\n            break;\r\n        default:\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {DrawImageObject} drawObject\r\n     * @param {Array<DrawImageObject>} objects - objects array to check\r\n     * @returns {{x:number, y:number, p:number} | boolean} - the closest collision\r\n     */\r\n    isObjectsCollision = (x, y, drawObject, objects) => {\r\n        const drawObjectType = drawObject.type,\r\n            drawObjectBoundaries = drawObject.vertices;\r\n        switch(drawObjectType) {\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.TEXT:\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.RECTANGLE:\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CONUS:\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.IMAGE:\r\n            return this.#isPolygonToObjectsCollision(x, y, drawObjectBoundaries, drawObject.rotation, objects);\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CIRCLE:\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\r\n            break;\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.LINE:\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\r\n            break;\r\n        default:\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\r\n        }\r\n        return false;\r\n    };\r\n\r\n    #checkCollisions(renderObjects) {\r\n        const boundaries = this.screenPageData.getBoundaries(),\r\n            boundariesLen = boundaries.length,\r\n            objectsLen = renderObjects.length;\r\n        //console.log(this.screenPageData.worldOffset);\r\n        for (let i = 0; i < objectsLen; i++) {\r\n            const renderObject = renderObjects[i];\r\n            for (let j = 0; j < objectsLen; j++) {\r\n                if (i === j) {\r\n                    continue;\r\n                }\r\n                // const renderObjectCheck = renderObjects[j];\r\n                // check object - object collisions\r\n            }\r\n\r\n            for (let k = 0; k < boundariesLen; k+=1) {\r\n                const item = boundaries[k],\r\n                    object = {\r\n                        x1: item[0],\r\n                        y1: item[1],\r\n                        x2: item[2],\r\n                        y2: item[3]\r\n                    };\r\n                const objectBoundaries = object.boundaries;\r\n                if (objectBoundaries) {\r\n                    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_18__.isPolygonLineIntersect)(objectBoundaries, object)) {\r\n                        this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.GAME.BOUNDARIES_COLLISION, renderObject);\r\n                    }\r\n                } else {\r\n                    if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_18__.isPointLineIntersect)({ x: renderObject.x, y: renderObject.y }, object)) {\r\n                        this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.GAME.BOUNDARIES_COLLISION, renderObject);\r\n                        console.log(\"boundaries collision detected\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    #setCanvasSize() {\r\n        const canvasWidth = this.systemSettings.canvasMaxSize.width && (this.systemSettings.canvasMaxSize.width < window.innerWidth) ? this.systemSettings.canvasMaxSize.width : window.innerWidth,\r\n            canvasHeight = this.systemSettings.canvasMaxSize.height && (this.systemSettings.canvasMaxSize.height < window.innerHeight) ? this.systemSettings.canvasMaxSize.height : window.innerHeight;\r\n        this.screenPageData._setCanvasDimensions(canvasWidth, canvasHeight);\r\n        this.#renderInterface.setCanvasSize(canvasWidth, canvasHeight)\r\n        //for (const view of this.#views.values()) {\r\n        //    view._setCanvasSize(canvasWidth, canvasHeight);\r\n        //}\r\n    }\r\n\r\n    #countFPSaverage() {\r\n        const timeLeft = this.systemSettings.gameOptions.render.averageFPStime,\r\n            steps = this.#tempFPStime.length;\r\n        let fullTime = 0;\r\n\r\n        for(let i = 0; i < steps; i++) {\r\n            const timeStep = this.#tempFPStime[i];\r\n            fullTime += timeStep;\r\n        }\r\n        console.log(\"FPS average for \", timeLeft/1000, \"sec, is \", fullTime / steps);\r\n\r\n        // cleanup\r\n        this.#tempFPStime = [];\r\n    }\r\n\r\n    #render = async (/*time*/) => {\r\n        _Logger_js__WEBPACK_IMPORTED_MODULE_3__.Logger.debug(\"_render \" + this.name + \" class\");\r\n        if (this.#isActive) {\r\n            switch (this.systemSettings.gameOptions.library) {\r\n            case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.LIBRARY.WEBGL:\r\n                if (this.isAllFilesLoaded()) {\r\n                    //render\r\n                    await this.#prepareViews();\r\n                } else {\r\n                    (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.ASSETS_NOT_READY, \"Is page initialization phase missed?\");\r\n                    this.#isActive = false;\r\n                }\r\n                // wait for the end of the execution stack, before start next iteration\r\n                setTimeout(() => requestAnimationFrame(this.#drawViews));\r\n                break;\r\n            }\r\n            this.#fpsAverageCountTimer = setInterval(() => this.#countFPSaverage(), this.systemSettings.gameOptions.render.averageFPStime);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    #prepareViews() {\r\n        return new Promise((resolve, reject) => {\r\n            let viewPromises = [];\r\n            const isBoundariesPrecalculations = this.#isBoundariesPrecalculations;\r\n            viewPromises.push(this.#renderInterface.initiateContext());\r\n            if (isBoundariesPrecalculations) {\r\n                console.warn(\"isBoundariesPrecalculations() is turned off\");\r\n                //for (const view of this.#views.values()) {\r\n                //viewPromises.push(this.#renderInterface._createBoundariesPrecalculations());\r\n                //}\r\n            }\r\n            Promise.allSettled(viewPromises).then((drawingResults) => {\r\n                drawingResults.forEach((result) => {\r\n                    if (result.status === \"rejected\") {\r\n                        const error = result.reason;\r\n                        (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.UNHANDLED_DRAW_ISSUE, error);\r\n                        reject(error);\r\n                    }\r\n                });\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    #drawViews = async (/*drawTime*/) => {\r\n        const pt0 = performance.now(),\r\n            minCircleTime = this.#minCircleTime;\r\n            \r\n        let viewPromises = [];\r\n        this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.START);\r\n        this.screenPageData._clearBoundaries();\r\n        this.#renderInterface.clearContext();\r\n        \r\n        //for (const [key, view] of this.#views.entries()) {\r\n        //    const render = await view.render(key);\r\n        //    viewPromises.push(render);\r\n        //}\r\n        const render = await this.#renderInterface.render();\r\n        viewPromises.push(render);\r\n        Promise.allSettled(viewPromises).then((drawingResults) => {\r\n            drawingResults.forEach((result) => {\r\n                if (result.status === \"rejected\") {\r\n                    (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.UNHANDLED_DRAW_ISSUE, result.reason);\r\n                    this.#isActive = false;\r\n                }\r\n            });\r\n            const r_time = performance.now() - pt0,\r\n                r_time_less = minCircleTime - r_time,\r\n                wait_time = r_time_less > 0 ? r_time_less : 0,\r\n                fps = 1000 / (r_time + wait_time);\r\n            //console.log(\"draw circle done, take: \", (r_time), \" ms\");\r\n            //console.log(\"fps: \", fps);\r\n            this.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.SYSTEM.RENDER.END);\r\n            this.#tempFPStime.push(fps);\r\n            if (this.#isActive) {\r\n                setTimeout(() => requestAnimationFrame(this.#drawViews), wait_time);\r\n            }\r\n        });\r\n    };\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/ScreenPage.js?");

/***/ }),

/***/ "./src/base/ScreenPageData.js":
/*!************************************!*\
  !*** ./src/base/ScreenPageData.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScreenPageData\": () => (/* binding */ ScreenPageData)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n\r\n\r\n/**\r\n * An interface for common views data such as\r\n * boundaries, world dimensions, options\r\n * accessible via ScreenPage.screenPageData \r\n * @see {@link ScreenPage} a part of ScreenPage\r\n * @hideconstructor\r\n */\r\nclass ScreenPageData {\r\n    #worldWidth;\r\n    #worldHeight;\r\n    #viewWidth;\r\n    #viewHeight;\r\n    #xOffset = 0;\r\n    #yOffset = 0;\r\n    #centerX = 0;\r\n    #centerY = 0;\r\n    #rotate = 0;\r\n    /**\r\n     * current screen boundaries, recalculated every render circle\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #boundaries = [];\r\n\r\n    /**\r\n     * whole world boundaries, calculated once on prepare stage\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #wholeWorldBoundaries = [];\r\n    /**\r\n     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | TiledRenderLayer>}\r\n     */\r\n    #renderObjects = [];\r\n    \r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isOffsetTurnedOff;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isWorldBoundariesEnabled = false;\r\n\r\n    /**\r\n     * \r\n     * @returns {boolean}\r\n     */\r\n    isOffsetTurnedOff() {\r\n        return this.#isOffsetTurnedOff;\r\n    }\r\n    set mapRotate(value) {\r\n        this.#rotate = value;\r\n    }\r\n\r\n    /**\r\n     * Add a Boundaries line\r\n     * @param {{x1:number,y1:number,x2:number, y2:number}} boundaries \r\n     */\r\n    #addBoundaries(boundaries) {\r\n        this.#boundaries.push([boundaries.x1, boundaries.y1, boundaries.x2, boundaries.y2]);\r\n    }\r\n\r\n    /**\r\n     * Add array of boundaries lines\r\n     * @param {Array<Array<number>>} boundaries \r\n     * @ignore\r\n     */\r\n    _addBoundariesArray(boundaries) {\r\n        this.#boundaries.push(...boundaries);\r\n    }\r\n\r\n    /**\r\n     * Clear map boundaries\r\n     * @ignore\r\n     */\r\n    _clearBoundaries() {\r\n        this.#boundaries = [];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @ignore\r\n     */\r\n    _setWorldDimensions(width, height) {\r\n        this.#worldWidth = width;\r\n        this.#worldHeight = height;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @ignore\r\n     */\r\n    _setCanvasDimensions(width, height) {\r\n        this.#viewWidth = width;\r\n        this.#viewHeight = height;\r\n    }\r\n\r\n    /**\r\n     * Set map borders\r\n     * @ignore\r\n     */\r\n    _setMapBoundaries() {\r\n        const [w, h] = [this.#worldWidth, this.#worldHeight];\r\n        if (!w || !h) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map boundaries.\");\r\n        }\r\n        this.#addBoundaries({x1: 0, y1: 0, x2: w, y2: 0});\r\n        this.#addBoundaries({x1: w, y1: 0, x2: w, y2: h});\r\n        this.#addBoundaries({x1: w, y1: h, x2: 0, y2: h});\r\n        this.#addBoundaries({x1: 0, y1: h, x2: 0, y2: 0});\r\n    }\r\n\r\n    _setWholeWorldMapBoundaries() {\r\n        const [w, h] = [this.#worldWidth, this.#worldHeight];\r\n        if (!w || !h) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map boundaries.\");\r\n        }\r\n        this.#wholeWorldBoundaries.push([0, 0, w, 0]);\r\n        this.#wholeWorldBoundaries.push([w, 0, w, h]);\r\n        this.#wholeWorldBoundaries.push([w, h, 0, h]);\r\n        this.#wholeWorldBoundaries.push([0, h, 0, 0]);\r\n    }\r\n\r\n    /**\r\n     * Merge same boundaries\r\n     * @ignore\r\n     */\r\n    _mergeBoundaries(isWholeMapBoundaries = false) {\r\n        const boundaries = isWholeMapBoundaries ? this.getWholeWorldBoundaries() : this.getBoundaries(),\r\n            boundariesSet = new Set(boundaries);\r\n        for (const line of boundariesSet.values()) {\r\n            const lineX1 = line[0],\r\n                lineY1 = line[1],\r\n                lineX2 = line[2],\r\n                lineY2 = line[3];\r\n            for (const line2 of boundariesSet.values()) {\r\n                const line2X1 = line2[0],\r\n                    line2Y1 = line2[1],\r\n                    line2X2 = line2[2],\r\n                    line2Y2 = line2[3];\r\n                if (lineX1 === line2X2 && lineY1 === line2Y2 &&\r\n                    lineX2 === line2X1 && lineY2 === line2Y1) {\r\n                    //remove double lines\r\n                    boundariesSet.delete(line);\r\n                    boundariesSet.delete(line2);\r\n                }\r\n                if (lineX2 === line2X1 && lineY2 === line2Y1 && (lineX1 === line2X2 || lineY1 === line2Y2)) {\r\n                    //merge lines\r\n                    line2[0] = lineX1;\r\n                    line2[1] = lineY1;\r\n                    boundariesSet.delete(line);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isWholeMapBoundaries) {\r\n            this.#boundaries = Array.from(boundariesSet);\r\n        } else {\r\n            this.#wholeWorldBoundaries = Array.from(boundariesSet);\r\n        }\r\n        boundariesSet.clear();\r\n    }\r\n\r\n    _setWholeMapBoundaries(boundaries) {\r\n        this.#wholeWorldBoundaries.push(...boundaries);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    _enableMapBoundaries() {\r\n        this.#isWorldBoundariesEnabled = true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getBoundaries() {\r\n        return this.#boundaries;\r\n    }\r\n\r\n    getWholeWorldBoundaries() {\r\n        return this.#wholeWorldBoundaries;\r\n    }\r\n\r\n    get isWorldBoundariesEnabled() {\r\n        return this.#isWorldBoundariesEnabled;\r\n    }\r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    get canvasDimensions() {\r\n        return [this.#viewWidth, this.#viewHeight];\r\n    }\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    get worldDimensions() {\r\n        return [this.#worldWidth, this.#worldHeight];\r\n    }\r\n    \r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    get worldOffset() {\r\n        return [this.#xOffset, this.#yOffset];\r\n    }\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    get mapCenter() {\r\n        return [this.#centerX, this.#centerY];\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get mapRotate() {\r\n        return this.#rotate;\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {number} x \r\n     * @param {number} y \r\n     */\r\n    centerCameraPosition = (x, y) => {\r\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\r\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\r\n            [mapWidth, mapHeight] = this.worldDimensions,\r\n            halfScreenWidth = canvasWidth/2,\r\n            halfScreenHeight = canvasHeight/2,\r\n            currentCenterX = halfScreenWidth - mapOffsetX,\r\n            currentCenterY = halfScreenHeight - mapOffsetY;\r\n        if (currentCenterX < x) {\r\n            if (x < mapWidth - halfScreenWidth) {\r\n                const newXOffset = x - halfScreenWidth;\r\n                if (newXOffset >= 0)\r\n                    this.#xOffset = Math.round(newXOffset);\r\n            } else if (mapWidth > canvasWidth) {\r\n                const newXOffset = mapWidth - canvasWidth;\r\n                this.#xOffset = Math.round(newXOffset);\r\n            }\r\n        }\r\n        if (currentCenterY < y) {\r\n            if (y < mapHeight - halfScreenHeight) {\r\n                const newYOffset = y - halfScreenHeight;\r\n                if (newYOffset >= 0)\r\n                    this.#yOffset = Math.round(newYOffset);\r\n            } else if (mapHeight > canvasHeight) {\r\n                const newYOffset = mapHeight - canvasHeight;\r\n                this.#yOffset = Math.round(newYOffset);\r\n            }\r\n        }\r\n\r\n        this.#centerX = x;\r\n        this.#centerY = y;\r\n        //Logger.debug(\"center camera position, offset: \", this.worldOffset);\r\n        //Logger.debug(\"center: \", this.mapCenter);   \r\n    };\r\n\r\n    personRotatedCenterCamera = (x, y, rotationAngle) => {\r\n        console.log(\"new centering algorithm\");\r\n        /*\r\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\r\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\r\n            [mapWidth, mapHeight] = this.worldDimensions,\r\n            halfScreenWidth = canvasWidth/2,\r\n            halfScreenHeight = canvasHeight/2,\r\n            currentCenterX = halfScreenWidth - mapOffsetX,\r\n            currentCenterY = halfScreenHeight - mapOffsetY;\r\n        if (currentCenterX < x) {\r\n            if (x < mapWidth - halfScreenWidth) {\r\n                const newXOffset = x - halfScreenWidth;\r\n                if (newXOffset >= 0)\r\n                    this.#xOffset = Math.round(newXOffset);\r\n            } else if (mapWidth > canvasWidth) {\r\n                const newXOffset = mapWidth - canvasWidth;\r\n                this.#xOffset = Math.round(newXOffset);\r\n            }\r\n        }\r\n        if (currentCenterY < y) {\r\n            if (y < mapHeight - halfScreenHeight) {\r\n                const newYOffset = y - halfScreenHeight;\r\n                if (newYOffset >= 0)\r\n                    this.#yOffset = Math.round(newYOffset);\r\n            } else if (mapHeight > canvasHeight) {\r\n                const newYOffset = mapHeight - canvasHeight;\r\n                this.#yOffset = Math.round(newYOffset);\r\n            }\r\n        }\r\n\r\n        this.#centerX = x;\r\n        this.#centerY = y;\r\n        Logger.debug(\"center camera position, offset: \", this.worldOffset);\r\n        Logger.debug(\"center: \", this.mapCenter);   \r\n        */\r\n    };\r\n\r\n    /**\r\n     * a getter to retrieve all attached renderObjects\r\n     */\r\n    get renderObjects() {\r\n        return this.#renderObjects;\r\n    }\r\n\r\n     /**\r\n     * Retrieve specific objects instances\r\n     * @param {Object} instance - drawObjectInstance to retrieve \r\n     * @returns {Array<Object>}\r\n     */\r\n    getObjectsByInstance(instance) {\r\n        return this.#renderObjects.filter((object) => object instanceof instance);\r\n    }\r\n\r\n    _sortRenderObjectsBySortIndex() {\r\n        this.#renderObjects = this.#renderObjects.sort((obj1, obj2) => obj2.sortIndex - obj1.sortIndex);\r\n    }\r\n\r\n    set _renderObject(object) {\r\n        this.#renderObjects.push(object);\r\n    } \r\n\r\n    set _renderObjects(objects) {\r\n        this.#renderObjects = objects;\r\n    } \r\n}\n\n//# sourceURL=webpack://jsge/./src/base/ScreenPageData.js?");

/***/ }),

/***/ "./src/base/System.js":
/*!****************************!*\
  !*** ./src/base/System.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"System\": () => (/* binding */ System)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n/* harmony import */ var _ScreenPage_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScreenPage.js */ \"./src/base/ScreenPage.js\");\n/* harmony import */ var _SystemInterface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SystemInterface.js */ \"./src/base/SystemInterface.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../configs.js */ \"./src/configs.js\");\n/* harmony import */ var _design_LoadingScreen_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../design/LoadingScreen.js */ \"./src/design/LoadingScreen.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst loadingPageName = \"loadingPage\";\r\n/**\r\n * A main app class, <br>\r\n * Holder class for ScreenPage,<br>\r\n * can register new ScreenPages,<br>\r\n * init and preload data for them,<br>\r\n */\r\nclass System {\r\n    #registeredPages;\r\n    /**\r\n     * @type {SystemInterface}\r\n     */\r\n    #system;\r\n    /**\r\n     * @type {HTMLElement}\r\n     */\r\n    #canvasContainer\r\n    /**\r\n     * @param {SystemSettings} systemSettings - holds system settings\r\n     * @param {HTMLElement} [canvasContainer] - If it is not passed, system will create div element and attach it to body\r\n     */\r\n    constructor(systemSettings, canvasContainer) {\r\n        if (!systemSettings) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\r\n        }\r\n        this.#registeredPages = new Map();\r\n\r\n        if (!canvasContainer) {\r\n            canvasContainer = document.createElement(\"div\");\r\n            document.body.appendChild(canvasContainer);\r\n            this.#canvasContainer = canvasContainer;\r\n        }\r\n\r\n        this.#system = new _SystemInterface_js__WEBPACK_IMPORTED_MODULE_3__.SystemInterface(systemSettings, this._startScreenPage, this._stopScreenPage);\r\n        \r\n        this.registerPage(loadingPageName, _design_LoadingScreen_js__WEBPACK_IMPORTED_MODULE_5__.LoadingScreen);\r\n\r\n        this.#system.loader.addEventListener(\"loadstart\", this.#loadStart);\r\n        this.#system.loader.addEventListener(\"progress\", this.#loadProgress);\r\n        this.#system.loader.addEventListener(\"load\", this.#loadComplete);\r\n    }\r\n\r\n    /**\r\n     * @type {SystemInterface}\r\n     */\r\n    get system() {\r\n        return this.#system;\r\n    }\r\n\r\n    /**\r\n     * A main factory method for create ScreenPage instances, <br>\r\n     * register them in a System and call ScreenPage.register() stage\r\n     * @param {string} screenPageName\r\n     * @param {ScreenPage} screen \r\n     */\r\n    registerPage(screenPageName, screen) {\r\n        if (screenPageName && typeof screenPageName === \"string\" && screenPageName.trim().length > 0) {\r\n            const page = new screen();\r\n            page._register(screenPageName, this.system);\r\n            this.#registeredPages.set(screenPageName, page);\r\n        } else {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, \"valid class name should be provided\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {string} screenPageName\r\n     * @param {Object} [options] - options\r\n     */\r\n    _startScreenPage = (screenPageName, options) => {\r\n        if (this.#registeredPages.has(screenPageName)) {\r\n            const page = this.#registeredPages.get(screenPageName);\r\n            if (page.isInitiated === false) {\r\n                page._init();\r\n            }\r\n            page._attachViewsToContainer(this.#canvasContainer);\r\n            page._start(options);\r\n        } else {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.VIEW_NOT_EXIST, \"View \" + screenPageName + \" is not registered!\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @method\r\n     * @param {string} screenPageName\r\n     */\r\n    _stopScreenPage = (screenPageName) => {\r\n        if (this.#registeredPages.has(screenPageName)) {\r\n            this.#registeredPages.get(screenPageName)._stop();\r\n        } else {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.VIEW_NOT_EXIST, \"View \" + screenPageName + \" is not registered!\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Preloads assets for all registered pages\r\n     * @return {Promise<void>}\r\n     */\r\n    preloadAllData() {\r\n        return this.#system.loader.preload();\r\n    }\r\n\r\n    #loadStart = (event) => {\r\n        this.#system.startScreenPage(loadingPageName, {total: event.total});\r\n    };\r\n\r\n    #loadProgress = (event) => {\r\n        const uploaded = event.loaded,\r\n            left = event.total,\r\n            loadingPage = this.#registeredPages.get(loadingPageName);\r\n            \r\n        loadingPage._progress(uploaded, left);\r\n    };\r\n\r\n    #loadComplete = () => {\r\n        this.#system.stopScreenPage(loadingPageName);\r\n    };\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/System.js?");

/***/ }),

/***/ "./src/base/SystemAudioInterface.js":
/*!******************************************!*\
  !*** ./src/base/SystemAudioInterface.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SystemAudioInterface\": () => (/* binding */ SystemAudioInterface)\n/* harmony export */ });\n/* harmony import */ var _modules_assetsm_dist_assetsm_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../modules/assetsm/dist/assetsm.min.js */ \"./modules/assetsm/dist/assetsm.min.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n\n\n\n\n/**\n * An audio interface, <br>\n * controls all application audio,<br>\n * holds and retrieves audio, changes volume<br> \n * accessible via ScreenPage.audio\n * @see {@link ScreenPage} a part of ScreenPage\n * @hideconstructor\n */\nclass SystemAudioInterface {\n    #volume = 0.5;\n    #audio = new Map();\n    /**\n     * @type {AssetsManager}\n     */\n    #loaderReference;\n\n    constructor(loader) {\n        this.#loaderReference = loader;\n    }\n\n    /**\n     * Original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudio = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            return audio;\n        } else {\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_REGISTERED, \"\");\n            return null;\n        }\n    };\n\n    /**\n     * Clone of original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudioCloned = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            const audioCloned = audio.cloneNode();\n            audioCloned.volume = this.#volume;\n            return audioCloned;\n        } else {\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_1__.WARNING_CODES.AUDIO_NOT_REGISTERED);\n            return null;\n        }\n    };\n\n    set volume(value) {\n        this.#volume = value;\n        this.#updateTracksVolumes(value);\n    }\n    /**\n     * Used to set or get audio volume, \n     * value should be from 0 to 1\n     * @type {number}\n     */\n    get volume() {\n        return this.#volume;\n    }\n\n    #updateTracksVolumes(value) {\n        for (const track of this.#audio.values()) {\n            if (track) {\n                track.volume = value;\n            }\n        }\n    }\n\n    /**\n     * Register audio in the system\n     * @param {string} name\n     */\n    registerAudio(name) {\n        let mediaElement = this.#loaderReference.getAudio(name);\n        this.#audio.set(name, mediaElement);\n    }\n}\n\n//# sourceURL=webpack://jsge/./src/base/SystemAudioInterface.js?");

/***/ }),

/***/ "./src/base/SystemInterface.js":
/*!*************************************!*\
  !*** ./src/base/SystemInterface.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SystemInterface\": () => (/* binding */ SystemInterface)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n/* harmony import */ var _SystemSocketConnection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SystemSocketConnection.js */ \"./src/base/SystemSocketConnection.js\");\n/* harmony import */ var _SystemAudioInterface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SystemAudioInterface.js */ \"./src/base/SystemAudioInterface.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../configs.js */ \"./src/configs.js\");\n/* harmony import */ var _node_modules_assetsm_dist_assetsm_min_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../node_modules/assetsm/dist/assetsm.min.js */ \"./node_modules/assetsm/dist/assetsm.min.js\");\n/* harmony import */ var _DrawObjectFactory_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DrawObjectFactory.js */ \"./src/base/DrawObjectFactory.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Public interface for a System<br>\r\n * Can be used to start/stop ScreenPage render, <br>\r\n * And provides access to SystemSettings, SystemSocketConnection and SystemAudioInterface <br>\r\n * accessible via ScreenPage.system and System.system\r\n * @see {@link System} a part of System class instance\r\n * @see {@link ScreenPage} a part of ScreenPage class instance\r\n */\r\nclass SystemInterface {\r\n    #systemSettings;\r\n    #systemServerConnection;\r\n    #systemAudioInterface;\r\n    #loader = new _node_modules_assetsm_dist_assetsm_min_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\r\n    #drawObjectFactory = new _DrawObjectFactory_js__WEBPACK_IMPORTED_MODULE_6__.DrawObjectFactory();\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    #modules = new Map();\r\n    constructor(systemSettings, _startScreenPage, _stopScreenPage) {\r\n        if (!systemSettings) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\r\n        }\r\n        this.#systemSettings = systemSettings;\r\n        this.#systemAudioInterface = new _SystemAudioInterface_js__WEBPACK_IMPORTED_MODULE_3__.SystemAudioInterface(this.loader);\r\n        this.#systemServerConnection = new _SystemSocketConnection_js__WEBPACK_IMPORTED_MODULE_2__.SystemSocketConnection(systemSettings);\r\n        this.startScreenPage = _startScreenPage;\r\n        this.stopScreenPage = _stopScreenPage;\r\n    }\r\n\r\n    /**\r\n     * @type { SystemSocketConnection }\r\n     */\r\n    get network () {\r\n        return this.#systemServerConnection;\r\n    }\r\n\r\n    /**\r\n     * @type { SystemSettings }\r\n     */\r\n    get systemSettings() {\r\n        return this.#systemSettings;\r\n    }\r\n\r\n    /**\r\n     * @type { SystemAudioInterface }\r\n     */\r\n    get audio() {\r\n        return this.#systemAudioInterface;\r\n    }\r\n\r\n    get loader() {\r\n        return this.#loader;\r\n    }\r\n\r\n    get drawObjectFactory() {\r\n        return this.#drawObjectFactory;\r\n    }\r\n\r\n    get modules() {\r\n        return this.#modules;\r\n    }\r\n\r\n    installModule = (moduleKey, moduleClass, ...args) => {\r\n        const moduleInstance = new moduleClass(this, ...args);\r\n        this.#modules.set(moduleKey, moduleInstance);\r\n        return moduleInstance;\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @param {string} createInstanceKey \r\n     * @param {*} createInstanceMethod \r\n     */\r\n    registerDrawObject(createInstanceKey, createInstanceMethod) {\r\n        this.#drawObjectFactory[createInstanceKey] = createInstanceMethod;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/SystemInterface.js?");

/***/ }),

/***/ "./src/base/SystemSocketConnection.js":
/*!********************************************!*\
  !*** ./src/base/SystemSocketConnection.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SystemSocketConnection\": () => (/* binding */ SystemSocketConnection)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n/* harmony import */ var _Logger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Logger.js */ \"./src/base/Logger.js\");\n/* harmony import */ var _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Events/SystemEvent.js */ \"./src/base/Events/SystemEvent.js\");\n\n\n\n\n\n/**\n * Represents Socket connection\n */\nclass SystemSocketConnection extends EventTarget {\n    #systemSettings;\n    #socket;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(systemSettings) {\n        super();\n        if (!systemSettings) {\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_1__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\n        }\n        this.#systemSettings = systemSettings;\n    }\n\n    init() {\n        __webpack_require__.e(/*! import() */ \"vendors-node_modules_socket_io-client_build_esm_index_js\").then(__webpack_require__.bind(__webpack_require__, /*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\")).then((module) => {\n            this.#socket = module.io(this.#systemSettings.network.address, {withCredentials: true});\n            \n            this.#registerSocketListeners();\n        });\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get isServerConnected () {\n        if (this.#socket && this.#socket.connected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    get playerId() {\n        return this.#socket.id;\n    }\n\n    sendGatherRoomsInfo() {\n        this.#socket.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.ROOMS_INFO_REQUEST);\n    }\n\n    sendCreateOrJoinRoom(roomName, map) {\n        this.#socket.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CREATE_OR_JOIN, roomName , map);\n    }\n\n    sendMessage(message) {\n        this.#socket.emit(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CLIENT_MESSAGE, message);\n    }\n\n    #onConnect = () => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"connected, socket id: \" + this.#socket.id);\n        this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onDisconnect = (reason) => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"server disconnected, reason: \" + reason);\n        this.dispatchEvent(new Event(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onData = (event) => {\n        console.warn(\"server data: \", event);\n    };\n\n    #onMessage = (message) => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"received new message from server: \" + message);\n        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.SERVER_MESSAGE, message));\n    };\n\n    #onRoomsInfo = (rooms) => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"received roomsInfo \" + rooms);\n        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.ROOMS_INFO, rooms));\n    };\n\n    #onCreateNewRoom = (room, map) => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"CLIENT SOCKET: Created room  \" + room);\n        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CREATED, {room, map}));\n    };\n\n    #onRoomIsFull = (room) => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"CLIENT SOCKET: Room is full, can't join: \" + room);\n        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.FULL, {room}));\n    };\n\n    #onJoinedToRoom = (room, map) => {\n        _Logger_js__WEBPACK_IMPORTED_MODULE_2__.Logger.debug(\"CLIENT SOCKET: Joined to room: \" + room, \", map: \", map);\n        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.JOINED, {room, map}));\n    };\n\n    #onUnjoinedFromRoom = (playerId) => {\n        this.dispatchEvent(new _Events_SystemEvent_js__WEBPACK_IMPORTED_MODULE_3__.SystemEvent(_constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.DISCONNECTED, {playerId}));\n    };\n\n    #registerSocketListeners() {\n        this.#socket.on(\"connect\", this.#onConnect);\n        this.#socket.on(\"disconnect\", this.#onDisconnect);\n        this.#socket.on(\"data\", this.#onData);\n\n        this.#socket.on(\"roomsInfo\", this.#onRoomsInfo);\n    \n        this.#socket.on(\"created\", this.#onCreateNewRoom);\n    \n        this.#socket.on(\"full\", this.#onRoomIsFull);\n    \n        this.#socket.on(\"joined\", this.#onJoinedToRoom);\n    \n        this.#socket.on(\"log\", function(array) {\n            console.log.apply(console, array);\n        });\n    \n        this.#socket.on(\"message\", this.#onMessage);\n    \n        this.#socket.on(\"removed\", function(message) {\n            console.log(\"removed message\");\n            console.log(message);\n        });\n\n        this.#socket.on(\"disconnected\", this.#onUnjoinedFromRoom);\n\n        addEventListener(\"beforeunload\", this.#disconnect);\n    }\n\n    #disconnect = () => {\n        this.#socket.disconnect();\n    };\n}\n\n//# sourceURL=webpack://jsge/./src/base/SystemSocketConnection.js?");

/***/ }),

/***/ "./src/base/TiledRenderLayer.js":
/*!**************************************!*\
  !*** ./src/base/TiledRenderLayer.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TiledRenderLayer\": () => (/* binding */ TiledRenderLayer)\n/* harmony export */ });\n/* harmony import */ var _DrawShapeObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DrawShapeObject.js */ \"./src/base/DrawShapeObject.js\");\n\r\n\r\nclass TiledRenderLayer {\r\n    #layerKey;\r\n    #tileMapKey;\r\n    #setBoundaries;\r\n    #drawBoundaries;\r\n    #attachedMaskId;\r\n    #isOffsetTurnedOff;\r\n\r\n    constructor(layerKey, tileMapKey, setBoundaries = false, shapeMask) {\r\n        this.#layerKey = layerKey;\r\n        this.#tileMapKey = tileMapKey;\r\n        this.#setBoundaries = setBoundaries;\r\n        this.#drawBoundaries = setBoundaries ? setBoundaries : false;\r\n        if (shapeMask) {\r\n            this.setMask(shapeMask);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A layer name.\r\n     * @type {string}\r\n     */\r\n    get layerKey() {\r\n        return this.#layerKey;\r\n    }\r\n\r\n    /**\r\n     * A tilemap layer key, should match key from the tilemap.\r\n     * @type {string}\r\n     */\r\n    get tileMapKey() {\r\n        return this.#tileMapKey;\r\n    }\r\n\r\n    /**\r\n     * Should the layer borders used as boundaries, or not\r\n     * Can be set in ScreenPage.addRenderLayer() method.\r\n     * @type {boolean}\r\n     */\r\n    get setBoundaries() {\r\n        return this.#setBoundaries;\r\n    }\r\n\r\n    /**\r\n     * Should draw a boundaries helper, or not\r\n     * Can be set in SystemSettings.\r\n     * @type {boolean}\r\n     */\r\n    get drawBoundaries() {\r\n        return this.#drawBoundaries;\r\n    }\r\n\r\n    set drawBoundaries(value) {\r\n        this.#drawBoundaries = value;\r\n    }\r\n\r\n    get _maskId() {\r\n        return this.#attachedMaskId;\r\n    }\r\n    /**\r\n     * \r\n     * @param {DrawShapeObject} mask \r\n     */\r\n    setMask(mask) {\r\n        this.#attachedMaskId = mask.id;\r\n    }\r\n\r\n    removeMask() {\r\n        this.#attachedMaskId = null;\r\n    }\r\n\r\n    get isOffsetTurnedOff() {\r\n        return this.#isOffsetTurnedOff;\r\n    }\r\n    turnOffOffset() {\r\n        this.#isOffsetTurnedOff = true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://jsge/./src/base/TiledRenderLayer.js?");

/***/ }),

/***/ "./src/base/WebGlDrawProgramData.js":
/*!******************************************!*\
  !*** ./src/base/WebGlDrawProgramData.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebGlDrawProgramData\": () => (/* binding */ WebGlDrawProgramData)\n/* harmony export */ });\nclass WebGlDrawProgramData {\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #programName;\r\n    /**\r\n     * @type {number[]}\r\n     */\r\n    #vectors;\r\n    /**\r\n     * @type {number[]}\r\n     */ \r\n    #textures;\r\n    /**\r\n     * @type {}\r\n     */ \r\n    #image;\r\n    /**\r\n     * @type {string}\r\n     */ \r\n    #imageName;\r\n    /**\r\n     * @type {string[]}\r\n     */\r\n    #drawMask;\r\n    /**\r\n     * @type {number}\r\n     */ \r\n    #rotation;\r\n    /**\r\n     * @type {number[]}\r\n     */ \r\n    #translation;\r\n    /**\r\n     * @type {number[]}\r\n     */ \r\n    #scale;\r\n    /**\r\n     * @type {number}\r\n     */ \r\n    #programVerticesNum;\r\n    /**\r\n     * @type {number | undefined}\r\n     */\r\n    #shapeMaskId\r\n\r\n    constructor(programName, vectors, textures, image, imageName, shapeMaskId, drawMask = [\"SRC_ALPHA\", \"ONE_MINUS_SRC_ALPHA\"], rotation = 0, translation = [0,0], scale = [1, 1]) {\r\n        this.#programName = programName;\r\n        this.#vectors = vectors;\r\n        this.#textures = textures;\r\n        this.#image = image;\r\n        this.#imageName = imageName;\r\n        this.#shapeMaskId = shapeMaskId;\r\n        this.#drawMask = drawMask;\r\n        this.#rotation = rotation;\r\n        this.#translation = translation;\r\n        this.#scale = scale;\r\n        this.#programVerticesNum = vectors.length / 2;\r\n    }\r\n\r\n    get programName() {\r\n        return this.#programName;\r\n    }\r\n    \r\n    get vectors() {\r\n        return this.#vectors;\r\n    }\r\n    \r\n    get textures() {\r\n        return this.#textures;\r\n    }\r\n    \r\n    get image() {\r\n        return this.#image;\r\n    }\r\n    \r\n    get imageName() {\r\n        return this.#imageName;\r\n    }\r\n    \r\n    get drawMask() {\r\n        return this.#drawMask;\r\n    }\r\n    \r\n    get rotation() {\r\n        return this.#rotation;\r\n    }\r\n    \r\n    get translation() {\r\n        return this.#translation;\r\n    }\r\n    \r\n    get scale() {\r\n        return this.#scale;\r\n    }\r\n\r\n    get programVerticesNum() {\r\n        return this.#programVerticesNum;\r\n    }\r\n\r\n    get shapeMaskId() {\r\n        return this.#shapeMaskId;\r\n    }\r\n    \r\n    isProgramDataCanBeMerged(imageName, shapeMaskId, drawMask = [\"SRC_ALPHA\", \"ONE_MINUS_SRC_ALPHA\"], rotation = 0, translation = [0,0], scale = [1, 1]) {\r\n\r\n        if (this.imageName === imageName \r\n            && this.shapeMaskId === shapeMaskId\r\n            && this.drawMask[0] === drawMask[0] \r\n            && this.drawMask[1] === drawMask[1]\r\n            && this.rotation === rotation\r\n            && this.translation[0] === translation[0]\r\n            && this.translation[1] === translation[1]\r\n            && this.scale[0] === scale[0]\r\n            && this.scale[1] === scale[1]) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    mergeProgramData(vectors, textures) {\r\n        this.#vectors.push(...vectors);\r\n        this.#textures.push(...textures);\r\n        this.#programVerticesNum = this.#vectors.length / 2; \r\n    }\r\n\r\n}\r\n\n\n//# sourceURL=webpack://jsge/./src/base/WebGlDrawProgramData.js?");

/***/ }),

/***/ "./src/base/WebGlInterface.js":
/*!************************************!*\
  !*** ./src/base/WebGlInterface.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebGlInterface\": () => (/* binding */ WebGlInterface)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ \"./src/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./src/utils.js\");\n/* harmony import */ var _Exception_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Exception.js */ \"./src/base/Exception.js\");\n/* harmony import */ var _WebGlDrawProgramData_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGlDrawProgramData.js */ \"./src/base/WebGlDrawProgramData.js\");\n\r\n\r\n\r\n\r\n\r\nclass WebGlInterface {\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #vertexShaderSource;\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #fragmentShaderSource;\r\n    /**\r\n     * @type {Map<string, WebGLProgram>}\r\n     */\r\n    #programs;\r\n    /**\r\n     * @type {Array<WebGlDrawProgramData>}\r\n     */\r\n    #programsData;\r\n    /**\r\n     * @type {Map<string, Object>}\r\n     */\r\n    #coordsLocations;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #verticesNumber;\r\n    /**\r\n     * @type {WebGLRenderingContext}\r\n     */\r\n    #gl;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #debug;\r\n    /**\r\n     * @type  {Map<string, number>}\r\n     */\r\n    #images_bind;\r\n    /**\r\n     * @type {WebGLBuffer | null}\r\n     */\r\n    #positionBuffer;\r\n    /**\r\n     * @type {WebGLBuffer | null}\r\n     */\r\n    #texCoordBuffer;\r\n\r\n    constructor(context, debug) {\r\n        if (!context || !(context instanceof WebGLRenderingContext)) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.UNEXPECTED_INPUT_PARAMS, \" context parameter should be specified and equal to WebGLRenderingContext\");\r\n        }\r\n        \r\n        this.#gl = context;\r\n        this.#debug = debug;\r\n        this.#programs = new Map();\r\n        this.#programsData = [];\r\n        this.#coordsLocations = new Map();\r\n        this.#images_bind = new Map();\r\n        this.#verticesNumber = 0;\r\n        this.#positionBuffer = this.#gl.createBuffer();\r\n        this.#texCoordBuffer = this.#gl.createBuffer();\r\n    }\r\n\r\n    _fixCanvasSize(width, height) {\r\n        this.#gl.viewport(0, 0, width, height);\r\n    }\r\n\r\n    _initiateImagesDrawProgram() {\r\n        this.#vertexShaderSource = `\r\n            attribute vec2 a_texCoord;\r\n\r\n            attribute vec2 a_position;\r\n\r\n            uniform vec2 u_translation;\r\n            uniform float u_rotation;\r\n            uniform vec2 u_scale;\r\n\r\n            uniform vec2 u_resolution;\r\n\r\n            varying vec2 v_texCoord;\r\n\r\n            void main(void) {\r\n                float c = cos(-u_rotation);\r\n                float s = sin(-u_rotation);\r\n\r\n                mat3 translationMatrix1 = mat3(\r\n                    1, 0, 0,\r\n                    0, 1, 0,\r\n                    u_translation.x, u_translation.y, 1\r\n                );\r\n\r\n                mat3 translationMatrix2 = mat3(\r\n                    1, 0, 0,\r\n                    0, 1, 0,\r\n                    -u_translation.x, -u_translation.y, 1\r\n                );\r\n                \r\n                mat3 rotationMatrix = mat3(\r\n                    c, -s, 0,\r\n                    s, c, 0,\r\n                    0, 0, 1\r\n                );\r\n\r\n                mat3 scalingMatrix = mat3(\r\n                    u_scale.x, 0, 0,\r\n                    0, u_scale.y, 0,\r\n                    0, 0, 1\r\n                );\r\n\r\n                mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\r\n                //Scale\r\n                // vec2 scaledPosition = a_position * u_scale;\r\n                // Rotate the position\r\n                // vec2 rotatedPosition = vec2(\r\n                //    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\r\n                //    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\r\n                //);\r\n                \r\n                //vec2 position = rotatedPosition + u_translation;\r\n                vec2 position = (matrix * vec3(a_position, 1)).xy;\r\n\r\n                //convert position from pixels to 0.0 to 1.0\r\n                vec2 zeroToOne = position / u_resolution;\r\n\r\n                //convert from 0->1 to 0->2\r\n                vec2 zeroToTwo = zeroToOne * 2.0;\r\n\r\n                //convert from 0->2 to -1->+1\r\n                vec2 clipSpace = zeroToTwo - 1.0;\r\n\r\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n                \r\n                v_texCoord = a_texCoord;\r\n            }\r\n        `;\r\n        this.#fragmentShaderSource = `\r\n            precision mediump float;\r\n\r\n            uniform sampler2D u_image;\r\n\r\n            //texCoords passed in from the vertex shader\r\n            varying vec2 v_texCoord;\r\n\r\n            void main() {\r\n                vec4 color = texture2D(u_image, v_texCoord);\r\n                gl_FragColor = color;\r\n            }\r\n        `;\r\n        const program = this.#initProgram(),\r\n            programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES;\r\n\r\n        this.#setProgram(programName, program);\r\n\r\n        const gl = this.#gl,\r\n            translationLocation = gl.getUniformLocation(program, \"u_translation\"),\r\n            rotationRotation = gl.getUniformLocation(program, \"u_rotation\"),\r\n            scaleLocation = gl.getUniformLocation(program, \"u_scale\"),\r\n            resolutionUniformLocation = gl.getUniformLocation(program, \"u_resolution\"),\r\n            positionAttributeLocation = gl.getAttribLocation(program, \"a_position\"),\r\n            texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\"),\r\n            u_imageLocation = gl.getUniformLocation(program, \"u_image\");\r\n\r\n        gl.enable(gl.BLEND);\r\n        // turn attribute on\r\n\r\n        this.#coordsLocations.set(programName, {\r\n            translationLocation,\r\n            rotationRotation,\r\n            scaleLocation,\r\n            resolutionUniformLocation,\r\n            positionAttributeLocation,\r\n            texCoordLocation,\r\n            u_imageLocation\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n\r\n    _initPrimitivesDrawProgram() {\r\n        this.#vertexShaderSource = `\r\n            precision mediump float;\r\n\r\n            attribute vec2 a_position;\r\n\r\n            uniform vec2 u_translation;\r\n            uniform float u_rotation;\r\n            uniform vec2 u_scale;\r\n\r\n            uniform vec2 u_resolution;\r\n\r\n            void main(void) {\r\n                float c = cos(-u_rotation);\r\n                float s = sin(-u_rotation);\r\n\r\n                mat3 translationMatrix1 = mat3(\r\n                    1, 0, 0,\r\n                    0, 1, 0,\r\n                    u_translation.x, u_translation.y, 1\r\n                );\r\n\r\n                //mat3 translationMatrix2 = mat3(\r\n                //    1, 0, 0,\r\n                //    0, 1, 0,\r\n                //    -u_translation.x, -u_translation.y, 1\r\n                //);\r\n                \r\n                mat3 rotationMatrix = mat3(\r\n                    c, -s, 0,\r\n                    s, c, 0,\r\n                    0, 0, 1\r\n                );\r\n\r\n                mat3 scalingMatrix = mat3(\r\n                    u_scale.x, 0, 0,\r\n                    0, u_scale.y, 0,\r\n                    0, 0, 1\r\n                );\r\n\r\n                //mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\r\n\r\n                mat3 matrix = translationMatrix1 * rotationMatrix * scalingMatrix;\r\n\r\n                //Scale\r\n                // vec2 scaledPosition = a_position * u_scale;\r\n                // Rotate the position\r\n                // vec2 rotatedPosition = vec2(\r\n                //    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\r\n                //    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\r\n                //);\r\n                \r\n                //vec2 position = rotatedPosition + u_translation;\r\n                vec2 position = (matrix * vec3(a_position, 1)).xy;\r\n\r\n                //convert position from pixels to 0.0 to 1.0\r\n                vec2 zeroToOne = position / u_resolution;\r\n\r\n                //convert from 0->1 to 0->2\r\n                vec2 zeroToTwo = zeroToOne * 2.0;\r\n\r\n                //convert from 0->2 to -1->+1\r\n                vec2 clipSpace = zeroToTwo - 1.0;\r\n\r\n                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n            }\r\n        `;\r\n        this.#fragmentShaderSource = `\r\n            precision mediump float;\r\n\r\n            uniform vec4 u_color;\r\n            uniform float u_fade_min; \r\n            uniform float u_fade_max;\r\n            uniform vec2 a_position;\r\n            uniform vec2 u_resolution;\r\n            uniform vec2 u_translation;\r\n            \r\n            void main(void) {\r\n                vec4 p = u_color;\r\n                if (u_fade_min > 0.0) {\r\n                    vec2 fix_tr = vec2(u_translation.x, u_resolution.y - u_translation.y); \r\n                    float distance = distance(fix_tr.xy, gl_FragCoord.xy);\r\n                    if (u_fade_min <= distance && distance <= u_fade_max) {\r\n                        float percent = ((distance - u_fade_max) / (u_fade_min - u_fade_max)) * 100.0;\r\n                        p.a = u_color.a * (percent / 100.0);\r\n                    }\r\n                }\r\n\r\n                gl_FragColor = p;\r\n            }\r\n        `;\r\n        const program = this.#initProgram(),\r\n            programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES;\r\n        this.#setProgram(programName, program);\r\n\r\n        const gl = this.#gl,\r\n            translationLocation = gl.getUniformLocation(program, \"u_translation\"),\r\n            rotationRotation = gl.getUniformLocation(program, \"u_rotation\"),\r\n            scaleLocation = gl.getUniformLocation(program, \"u_scale\"),\r\n            resolutionUniformLocation = gl.getUniformLocation(program, \"u_resolution\"),\r\n            colorUniformLocation = gl.getUniformLocation(program, \"u_color\"),\r\n            positionAttributeLocation = gl.getAttribLocation(program, \"a_position\"),\r\n            fadeMinLocation = gl.getUniformLocation(program, \"u_fade_min\"),\r\n            fadeMaxLocation =  gl.getUniformLocation(program, \"u_fade_max\");\r\n\r\n        this.#coordsLocations.set(programName, {\r\n            translationLocation,\r\n            rotationRotation,\r\n            scaleLocation,\r\n            resolutionUniformLocation,\r\n            colorUniformLocation,\r\n            positionAttributeLocation,\r\n            fadeMinLocation,\r\n            fadeMaxLocation\r\n        });\r\n        return Promise.resolve();\r\n    }\r\n\r\n    _initWebGlAttributes() {\r\n        const gl = this.#gl;\r\n        gl.enable(gl.STENCIL_TEST);\r\n        gl.stencilFunc(gl.ALWAYS, 1, 0xFF);\r\n        //if stencil test and depth test pass we replace the initial value\r\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n        return Promise.resolve();\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @param {*} vectors \r\n     * @param {*} textures \r\n     * @param {*} image \r\n     * @param {*} imageName \r\n     * @param {*} drawMask \r\n     * @param {*} rotation \r\n     * @param {*} translation \r\n     * @param {*} scale \r\n     * @returns {Promise<void>}\r\n     */\r\n    _bindTileImages(vectors, textures, image, imageName, shapeMaskId, drawMask = [\"SRC_ALPHA\", \"ONE_MINUS_SRC_ALPHA\"], rotation = 0, translation = [0, 0], scale = [1, 1]) {\r\n        return new Promise((resolve) => {\r\n            const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\r\n                existingProgramData = this.#programsData.filter((data) => data.programName === programName);\r\n                \r\n            let isProgramDataMerged = false;\r\n\r\n            for(let i = 0; i < existingProgramData.length; i++) {\r\n                const data = existingProgramData[i];\r\n                if (data.isProgramDataCanBeMerged(imageName, shapeMaskId, drawMask, 0, [0,0], [1,1])) {\r\n                    data.mergeProgramData(vectors, textures);\r\n                    isProgramDataMerged = true;\r\n                }\r\n            }\r\n\r\n            if (!isProgramDataMerged) {\r\n                this.#programsData.push(new _WebGlDrawProgramData_js__WEBPACK_IMPORTED_MODULE_3__.WebGlDrawProgramData(programName, vectors, textures, image, imageName, shapeMaskId, drawMask, rotation, translation, scale));\r\n            }\r\n\r\n            resolve();\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    _executeTileImagesDraw() {\r\n        return new Promise((resolve) => {\r\n            const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\r\n                program = this.#getProgram(programName),\r\n                { translationLocation,\r\n                    rotationRotation,\r\n                    scaleLocation,\r\n                    resolutionUniformLocation,\r\n                    positionAttributeLocation,\r\n                    texCoordLocation,\r\n                    u_imageLocation } = this.#coordsLocations.get(programName),\r\n                gl = this.#gl,\r\n                programsData = this.#programsData.filter(programData => programData.programName === programName);\r\n           \r\n            gl.useProgram(program);\r\n\r\n            for (let i = 0; i < programsData.length; i++) {\r\n                const data = programsData[i];\r\n                // set the resolution\r\n                gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n                gl.uniform2f(translationLocation, data.translation[0], data.translation[1]);\r\n                gl.uniform2f(scaleLocation, data.scale[0], data.scale[1]);\r\n                gl.uniform1f(rotationRotation, data.rotation);\r\n                \r\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vectors), gl.STATIC_DRAW);\r\n\r\n                gl.enableVertexAttribArray(positionAttributeLocation);\r\n                //Tell the attribute how to get data out of positionBuffer\r\n                const size = 2,\r\n                    type = gl.FLOAT, // data is 32bit floats\r\n                    normalize = false,\r\n                    stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n                    offset = 0; // start of beginning of the buffer\r\n                gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n                //textures buffer\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.textures), gl.STATIC_DRAW);\r\n\r\n                gl.enableVertexAttribArray(texCoordLocation);\r\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);\r\n\r\n                let bind_number  = this.#images_bind.get(data.imageName);\r\n\r\n                if (!bind_number ) {\r\n                    bind_number  = this.#images_bind.size + 1;\r\n                    gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\r\n                    gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());\r\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data.image);\r\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n                    this.#images_bind.set(data.imageName, bind_number);\r\n                } else {\r\n                    gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\r\n                }\r\n                gl.uniform1i(u_imageLocation, bind_number);\r\n                gl.blendFunc(gl[data.drawMask[0]], gl[data.drawMask[1]]);\r\n                this.#verticesNumber = data.programVerticesNum;\r\n                if (data.shapeMaskId) {\r\n                    gl.stencilFunc(gl.EQUAL, data.shapeMaskId, 0xFF);\r\n                    //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n                }\r\n                \r\n                // Upload the image into the texture.\r\n                this.#executeGlslProgram();\r\n            }\r\n            //clear the array\r\n            this.#programsData = [];\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    _bindAndDrawTileImages(vectors, textures, image, image_name, rotation = 0, translation = [0, 0], scale = [1, 1], shapeMaskId) {\r\n        const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\r\n            program = this.#getProgram(programName),\r\n            { translationLocation,\r\n                rotationRotation,\r\n                scaleLocation,\r\n                resolutionUniformLocation,\r\n                positionAttributeLocation,\r\n                texCoordLocation,\r\n                u_imageLocation } = this.#coordsLocations.get(programName),\r\n            gl = this.#gl;\r\n\r\n        gl.useProgram(program);\r\n\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        \r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vectors), gl.STATIC_DRAW);\r\n\r\n        this.#verticesNumber += vectors.length / 2;\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        //textures buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures), gl.STATIC_DRAW);\r\n\r\n        gl.enableVertexAttribArray(texCoordLocation);\r\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n        let bind_number  = this.#images_bind.get(image_name);\r\n\r\n        if (!bind_number ) {\r\n            bind_number  = this.#images_bind.size + 1;\r\n\r\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\r\n            gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());\r\n            \r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n\r\n            this.#images_bind.set(image_name, bind_number);\r\n        } else {\r\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\r\n        }\r\n        gl.uniform1i(u_imageLocation, bind_number );\r\n        // make image transparent parts transparent\r\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        if (shapeMaskId) {\r\n            gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);\r\n            //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n        }\r\n        // Upload the image into the texture.\r\n        this.#executeGlslProgram();\r\n    }\r\n\r\n    _bindText(x, y, renderObject) {\r\n        const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\r\n            program = this.#getProgram(programName),\r\n            { translationLocation,\r\n                rotationRotation,\r\n                scaleLocation,\r\n                resolutionUniformLocation,\r\n                positionAttributeLocation,\r\n                texCoordLocation,\r\n                u_imageLocation } = this.#coordsLocations.get(programName),\r\n            gl = this.#gl;\r\n\r\n        //@toDo: add additional info to the #images_bind and avoid this call, if image is already created\r\n        const { boxWidth, boxHeight, ctx } = this.#createCanvasText(renderObject),\r\n            texture = ctx.canvas,\r\n            image_name = renderObject.text;\r\n\r\n        y = y - boxHeight;\r\n\r\n        const rotation = 0, \r\n            translation = [0, 0], \r\n            scale = [1, 1];\r\n        const vecX1 = x,\r\n            vecY1 = y,\r\n            vecX2 = vecX1 + boxWidth,\r\n            vecY2 = vecY1 + boxHeight;\r\n        const verticesBufferData = [\r\n                vecX1, vecY1,\r\n                vecX2, vecY1,\r\n                vecX1, vecY2,\r\n                vecX1, vecY2,\r\n                vecX2, vecY1,\r\n                vecX2, vecY2\r\n            ],\r\n            texturesBufferData = [\r\n                0, 0,\r\n                1, 0,\r\n                0, 1,\r\n                0, 1,\r\n                1, 0,\r\n                1, 1\r\n            ];\r\n\r\n        gl.useProgram(program);\r\n\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        \r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBufferData), gl.STATIC_DRAW);\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        //textures buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texturesBufferData), gl.STATIC_DRAW);\r\n\r\n        gl.enableVertexAttribArray(texCoordLocation);\r\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        \r\n        this.#verticesNumber += 6;\r\n        // remove box\r\n        // fix text edges\r\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\r\n        //gl.depthMask(false);\r\n        let bind_number = this.#images_bind.get(image_name);\r\n        if (!bind_number) {\r\n            bind_number  = this.#images_bind.size + 1;\r\n\r\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\r\n            gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());\r\n            // Upload the image into the texture.\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n\r\n            // As image properties such as text stroke changes, image_name still the same,\r\n            // and image won't replaced\r\n            //this.#images_bind.set(image_name, bind_number);\r\n        } else {\r\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\r\n        }\r\n        gl.uniform1i(u_imageLocation, bind_number);\r\n        //console.log(\"vertex attrib 1 :\", gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING));\r\n        this.#executeGlslProgram();\r\n    }\r\n\r\n    _bindPrimitives(renderObject, rotation = 0, translation = [0, 0], scale = [1, 1]) {\r\n        const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\r\n            program = this.#getProgram(programName),\r\n            { \r\n                translationLocation,\r\n                rotationRotation,\r\n                scaleLocation,\r\n                resolutionUniformLocation,\r\n                colorUniformLocation,\r\n                positionAttributeLocation,\r\n                fadeMinLocation\r\n            } = this.#coordsLocations.get(programName),\r\n            gl = this.#gl;\r\n\r\n        gl.useProgram(program);\r\n\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        switch (renderObject.type) {\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.RECTANGLE:\r\n            this.#setSingleRectangle(renderObject.width, renderObject.height);\r\n            this.#verticesNumber += 6;\r\n            break;\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.TEXT:\r\n            break;\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.CIRCLE: {\r\n            const coords = renderObject.vertices;\r\n            gl.bufferData(this.#gl.ARRAY_BUFFER, \r\n                new Float32Array(coords), this.#gl.STATIC_DRAW);\r\n            this.#verticesNumber += coords.length / 2;\r\n            break;\r\n        }\r\n        case _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.DRAW_TYPE.POLYGON: {\r\n            const triangles = this.#triangulatePolygon(renderObject.vertices);\r\n            this.#bindPolygon(triangles);\r\n            const len = triangles.length;\r\n            if (len % 3 !== 0) {\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, `polygons ${renderObject.id}, vertices are not correct, skip drawing`);\r\n                return;\r\n            }\r\n            this.#verticesNumber += len / 2;\r\n            break;\r\n        }\r\n        }\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(renderObject.bgColor);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        if (renderObject.blendFunc) {\r\n            gl.blendFunc(renderObject.blendFunc[0], renderObject.blendFunc[1]);\r\n        }\r\n        if (renderObject.cut) {\r\n            gl.blendEquation(gl.FUNC_SUBTRACT);\r\n        }\r\n        //disable attribute which is not used in this program\r\n        //if (gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_ENABLED)) {\r\n        //gl.disableVertexAttribArray(1);\r\n        //}\r\n        this.#executeGlslProgram(0, null, true);\r\n    }\r\n\r\n    _drawLines(linesArray, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {\r\n        const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\r\n            program = this.#getProgram(programName),\r\n            { resolutionUniformLocation,\r\n                colorUniformLocation,\r\n                positionAttributeLocation,\r\n            \r\n                translationLocation,\r\n                rotationRotation,\r\n                scaleLocation,\r\n                fadeMinLocation\r\n            } = this.#coordsLocations.get(programName),\r\n            gl = this.#gl;\r\n\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, 1, 1);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        this.#gl.bufferData(\r\n            this.#gl.ARRAY_BUFFER, \r\n            new Float32Array(linesArray),\r\n            this.#gl.STATIC_DRAW);\r\n\r\n        this.#verticesNumber += linesArray.length / 2;\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(color);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        gl.lineWidth(lineWidth);\r\n\r\n        //gl.blendFunc(gl.ONE, gl.DST_COLOR );\r\n        \r\n        //disable attribute which is not used in this program\r\n        //if (gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_ENABLED)) {\r\n        //    gl.disableVertexAttribArray(1);\r\n        //}\r\n        this.#executeGlslProgram(0, gl.LINES);\r\n    }\r\n\r\n    _drawPolygon(vertices, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {\r\n        const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\r\n            program = this.#getProgram(programName),\r\n            { resolutionUniformLocation,\r\n                colorUniformLocation,\r\n                positionAttributeLocation,\r\n            \r\n                translationLocation,\r\n                rotationRotation,\r\n                scaleLocation,\r\n                fadeMinLocation\r\n            } = this.#coordsLocations.get(programName),\r\n            gl = this.#gl;\r\n\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, 1, 1);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        const triangles = this.#triangulatePolygon(vertices);\r\n        \r\n        const polygonVerticesNum = triangles.length;\r\n        if (polygonVerticesNum % 3 !== 0) {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Warning)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, \"polygon boundaries vertices are not correct, skip drawing\");\r\n            return;\r\n        }\r\n        this.#bindPolygon(triangles);\r\n        this.#verticesNumber += polygonVerticesNum / 2;\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(color);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n\r\n        this.#executeGlslProgram(0, null);\r\n    }\r\n\r\n    _bindConus(renderObject, rotation = 0, translation = [0, 0], scale = [1, 1]) {\r\n        const programName = _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\r\n            program = this.#getProgram(programName),\r\n            { \r\n                translationLocation,\r\n                rotationRotation,\r\n                scaleLocation,\r\n                resolutionUniformLocation,\r\n                colorUniformLocation,\r\n                positionAttributeLocation,\r\n                fadeMinLocation,\r\n                fadeMaxLocation\r\n            } = this.#coordsLocations.get(programName),\r\n            gl = this.#gl,\r\n            coords = renderObject.vertices,\r\n            fillStyle = renderObject.bgColor,\r\n            fade_min = renderObject.fade_min,\r\n            fadeLen = renderObject.radius;\r\n            \r\n        gl.useProgram(program);\r\n        \r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, fade_min);\r\n        gl.uniform1f(fadeMaxLocation, fadeLen);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        gl.bufferData(this.#gl.ARRAY_BUFFER, \r\n            new Float32Array(coords), this.#gl.STATIC_DRAW);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        this.#verticesNumber += coords.length / 2;\r\n\r\n        if (renderObject.blendFunc) {\r\n            gl.blendFunc(renderObject.blendFunc[0], renderObject.blendFunc[1]);\r\n        }\r\n\r\n        if (renderObject.cut) {\r\n            // cut bottom \r\n            gl.blendEquation(gl.FUNC_SUBTRACT);\r\n            //gl.blendFunc( gl.ONE, gl.ONE );\r\n            //gl.blendFunc(gl.ONE, gl.DST_COLOR);\r\n        } //else {\r\n        //gl.disable(gl.BLEND);\r\n        // make transparent\r\n        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        //}\r\n\r\n        const colorArray = this.#rgbaToArray(fillStyle);\r\n\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        //disable attribute which is not used in this program\r\n        //if (gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_ENABLED)) {\r\n        //gl.disableVertexAttribArray(1);\r\n        //}\r\n        if (renderObject.isMaskAttached) {\r\n            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);\r\n        } else {\r\n            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);\r\n        }\r\n        //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n        this.#executeGlslProgram(0, gl.TRIANGLE_FAN, true);\r\n    }\r\n\r\n    _clearView() {\r\n        const gl = this.#gl;\r\n        // Set clear color to black, fully opaque\r\n        this.#programsData = [];\r\n        gl.clearColor(0, 0, 0, 0);\r\n        // Clear the color buffer with specified clear color\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n    }\r\n\r\n    #setProgram(name, program) {\r\n        this.#programs.set(name, program);\r\n    }\r\n\r\n    #getProgram(name) {\r\n        return this.#programs.get(name);\r\n    }\r\n\r\n    #bindPolygon(vertices) {\r\n        this.#gl.bufferData(\r\n            this.#gl.ARRAY_BUFFER, \r\n            new Float32Array(vertices),\r\n            this.#gl.STATIC_DRAW);\r\n    }\r\n\r\n    #setSingleRectangle(width, height) {\r\n        const x1 = 0,\r\n            x2 = 0 + width,\r\n            y1 = 0,\r\n            y2 = 0 + height;\r\n        this.#gl.bufferData(this.#gl.ARRAY_BUFFER, \r\n            new Float32Array([\r\n                x1, y1,\r\n                x2, y1,\r\n                x1, y2,\r\n                x1, y2,\r\n                x2, y1,\r\n                x2, y2]), this.#gl.STATIC_DRAW);\r\n    }\r\n    \r\n    #executeGlslProgram(offset = 0, primitiveType, resetEquation) {\r\n        const primitiveTypeValue = primitiveType ? primitiveType : this.#gl.TRIANGLES,\r\n            gl = this.#gl;\r\n            \r\n        const err = this.#debug ? gl.getError() : 0;\r\n        if (err !== 0) {\r\n            console.error(err);\r\n            throw new Error(\"Error num: \" + err);\r\n        } else {\r\n            gl.drawArrays(primitiveTypeValue, offset, this.#verticesNumber);\r\n            this.#verticesNumber = 0;\r\n            // set blend to default\r\n            gl.stencilFunc(gl.ALWAYS, 1, 0xFF);\r\n            if (resetEquation) {\r\n                gl.blendEquation(  gl.FUNC_ADD );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {WebGLProgram}\r\n     */\r\n    #initProgram() {\r\n        const gl = this.#gl,\r\n            program = gl.createProgram();\r\n\r\n        if (program) {\r\n            const compVertexShader = this.#compileShader(this.#vertexShaderSource, gl.VERTEX_SHADER);\r\n            if (compVertexShader) {\r\n                gl.attachShader(program, compVertexShader);\r\n            } else {\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, \"#compileShader(vertexShaderSource) is null\");\r\n            }\r\n\r\n            const compFragmentShader = this.#compileShader(this.#fragmentShaderSource, gl.FRAGMENT_SHADER);\r\n            if (compFragmentShader) {\r\n                gl.attachShader(program, compFragmentShader);\r\n            } else {\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, \"#compileShader(fragmentShaderSource) is null\");\r\n            }\r\n\r\n            gl.linkProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n                const info = gl.getProgramInfoLog(program);\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, `Could not compile WebGL program. \\n\\n${info}`);\r\n            }\r\n        } else {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, \"gl.createProgram() is null\");\r\n        }\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} renderObject \r\n     * @returns {{boxWidth:number, boxHeight:number, ctx:CanvasRenderingContext2D}}\r\n     */\r\n    #createCanvasText(renderObject) {\r\n        const ctx = document.createElement(\"canvas\").getContext(\"2d\");\r\n        if (ctx) { \r\n            ctx.font = renderObject.font;\r\n            renderObject._textMetrics = ctx.measureText(renderObject.text);\r\n            const boxWidth = renderObject.boundariesBox.width, \r\n                boxHeight = renderObject.boundariesBox.height;\r\n            ctx.canvas.width = boxWidth;\r\n            ctx.canvas.height = boxHeight;\r\n            ctx.font = renderObject.font;\r\n            ctx.textBaseline = \"bottom\";// bottom\r\n            if (renderObject.fillStyle) {\r\n                ctx.fillStyle = renderObject.fillStyle;\r\n                ctx.fillText(renderObject.text, 0, boxHeight);\r\n            } \r\n            if (renderObject.strokeStyle) {\r\n                ctx.strokeStyle = renderObject.strokeStyle;\r\n                ctx.strokeText(renderObject.text, 0, boxHeight);\r\n            }\r\n            return { boxWidth, boxHeight, ctx };\r\n        } else {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, \"can't getContext('2d')\");\r\n        }\r\n    }\r\n\r\n    #compileShader(shaderSource, shaderType) {\r\n        const shader = this.#gl.createShader(shaderType);\r\n        if (shader) {\r\n            this.#gl.shaderSource(shader, shaderSource);\r\n            this.#gl.compileShader(shader);\r\n\r\n            if (!this.#gl.getShaderParameter(shader, this.#gl.COMPILE_STATUS)) {\r\n                const info = this.#gl.getShaderInfoLog(shader);\r\n                (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, \"Couldn't compile webGl program. \\n\\n\" + info);\r\n            }\r\n        } else {\r\n            (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.WEBGL_ERROR, `gl.createShader(${shaderType}) is null`);\r\n        }\r\n        return shader;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} rgbaColor \r\n     * @returns {number[]}\r\n     */\r\n    #rgbaToArray (rgbaColor) {\r\n        return rgbaColor.replace(\"rgba(\", \"\").replace(\")\", \"\").split(\",\").map((/** @param {string} */item) => Number(item.trim()));\r\n    }\r\n\r\n    #triangulatePolygon(vertices) {\r\n        return this.#triangulate(vertices);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Array<Array<number>>} polygonVertices \r\n     * @param {Array<number>} triangulatedPolygon \r\n     * @returns {Array<number>}\r\n     */\r\n    #triangulate (polygonVertices, triangulatedPolygon = []) {\r\n        const len = polygonVertices.length,\r\n            vectorsCS = (a, b, c) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.crossProduct)({x:c[0] - a[0], y: c[1] - a[1]}, {x:b[0] - a[0], y: b[1] - a[1]});\r\n\r\n        if (len <= 3) {\r\n            polygonVertices.forEach(vertex => {\r\n                triangulatedPolygon.push(vertex[0]);\r\n                triangulatedPolygon.push(vertex[1]);\r\n            });\r\n            return triangulatedPolygon;\r\n        }\r\n        const verticesSortedByY = [...polygonVertices].sort((curr, next) => next[1] - curr[1]);\r\n        const topVertexIndex = polygonVertices.indexOf(verticesSortedByY[0]),\r\n            startVertexIndex = topVertexIndex !== len - 1 ? topVertexIndex + 1 : 0;\r\n        \r\n        let processedVertices = polygonVertices,\r\n            processedVerticesLen = processedVertices.length,\r\n            skipCount = 0,\r\n            i = startVertexIndex;\r\n        \r\n        while(processedVertices.length > 2) {\r\n            // if overflowed, start from beginning\r\n            const currLen = processedVertices.length;\r\n            if (i >= currLen) {\r\n                i -= currLen;\r\n            }\r\n    \r\n            const prevVertex = i === 0 ? processedVertices[currLen - 1] : processedVertices[i - 1],\r\n                currentVertex = processedVertices[i],\r\n                nextVertex = currLen === i + 1 ? processedVertices[0] : processedVertices[i + 1];\r\n    \r\n            \r\n            const cs = vectorsCS(prevVertex, currentVertex, nextVertex);\r\n    \r\n            if (cs < 0) {\r\n                triangulatedPolygon.push(prevVertex[0]);\r\n                triangulatedPolygon.push(prevVertex[1]);\r\n                triangulatedPolygon.push(currentVertex[0]);\r\n                triangulatedPolygon.push(currentVertex[1]);\r\n                triangulatedPolygon.push(nextVertex[0]);\r\n                triangulatedPolygon.push(nextVertex[1]);\r\n                processedVertices = processedVertices.filter((val, index) => index !== i);\r\n            } else {\r\n                skipCount += 1;\r\n                if (skipCount > processedVerticesLen) {\r\n                    (0,_Exception_js__WEBPACK_IMPORTED_MODULE_2__.Exception)(_constants_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_CODES.DRAW_PREPARE_ERROR, \"Can't extract triangles. Probably vertices input is not correct, or the order is wrong\");\r\n                }\r\n            }\r\n            i++;\r\n        }\r\n        \r\n        return triangulatedPolygon;\r\n    }\r\n}\n\n//# sourceURL=webpack://jsge/./src/base/WebGlInterface.js?");

/***/ }),

/***/ "./src/configs.js":
/*!************************!*\
  !*** ./src/configs.js ***!
  \************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SystemSettings\": () => (/* binding */ SystemSettings)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/constants.js\");\n\r\n/**\r\n * Settings object, should be passed as a parameter to System.constructor().\r\n */\r\nconst SystemSettings = {\r\n    mode: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.MODE.DEBUG,\r\n    \r\n    gameOptions: {\r\n        library: _constants_js__WEBPACK_IMPORTED_MODULE_0__.CONST.LIBRARY.WEBGL,\r\n        checkWebGlErrors: true,\r\n        debugMobileTouch: false,\r\n        optimization: null,\r\n        loadingScreen: {\r\n            backgroundColor:  \"rgba(128, 128, 128, 0.6)\",\r\n            loadingBarBg: \"rgba(128, 128, 128, 1)\",\r\n            loadingBarProgress: \"rgba(128, 128, 128, 0.2)\",\r\n        },\r\n        boundaries: {\r\n            drawLayerBoundaries: false,\r\n            drawObjectBoundaries: false,\r\n            boundariesColor: \"rgba(224, 12, 21, 0.6)\",\r\n            boundariesWidth: 2\r\n        },\r\n        render: {\r\n            averageFPStime: 10000,\r\n            minCircleTime: 1, //ms which is ~60 FPS\r\n            boundaries: {\r\n                mapBoundariesEnabled: true,\r\n                realtimeCalculations: true,\r\n                wholeWorldPrecalculations: false\r\n            }\r\n        }\r\n    },\r\n    \r\n\r\n    network: {\r\n        address: \"https://gameserver.reslc.ru:9009\",\r\n        gatherRoomsInfoInterval: 5000\r\n    },\r\n\r\n    canvasMaxSize: {\r\n        width: 900,\r\n        height: 960\r\n    },\r\n\r\n    worldSize: {\r\n        width: 960,\r\n        height: 960\r\n    },\r\n\r\n    defaultCanvasKey: \"default\"\r\n};\n\n//# sourceURL=webpack://jsge/./src/configs.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONST\": () => (/* binding */ CONST),\n/* harmony export */   \"ERROR_CODES\": () => (/* binding */ ERROR_CODES),\n/* harmony export */   \"WARNING_CODES\": () => (/* binding */ WARNING_CODES)\n/* harmony export */ });\nconst CONST = {\r\n    MODE: {\r\n        DEBUG: \"DEBUG\",\r\n        PRODUCTION: \"PRODUCTION\"\r\n    },\r\n    SCREENS: {},\r\n    AUDIO: {},\r\n    CONNECTION_STATUS: {\r\n        DISCONNECTED: \"disconnected\",\r\n        CONNECTED: \"connected\",\r\n        CONNECTION_LOST: \"connection lost\"\r\n    },\r\n    EVENTS: {\r\n        SYSTEM: {\r\n            START_PAGE:\"START_PAGE\",\r\n            STOP_PAGE: \"STOP_PAGE\",\r\n            RENDER: {\r\n                START: \"start\",\r\n                END: \"end\"\r\n            }\r\n        },\r\n        GAME: {\r\n            BOUNDARIES_COLLISION: \"BOUNDARIES_COLLISION\",\r\n            OBJECTS_COLLISION: \"OBJECTS_COLLISION\"\r\n        },\r\n        WEBSOCKET: {\r\n            SERVER_CLIENT: {\r\n                CONNECTION_STATUS_CHANGED: \"CONNECTION_STATUS_CHANGED\",\r\n                ROOMS_INFO: \"roomsInfo\",\r\n                CREATED: \"created\",\r\n                JOINED: \"joined\",\r\n                FULL: \"full\",\r\n                DISCONNECTED: \"disconnected\",\r\n                SERVER_MESSAGE: \"message\",\r\n                RESTARTED: \"restarted\",\r\n            },\r\n            CLIENT_SERVER: {\r\n                ROOMS_INFO_REQUEST: \"gatherRoomsInfo\",\r\n                CREATE_OR_JOIN: \"create or join\",\r\n                RESTART_REQUEST: \"restart\",\r\n                CLIENT_MESSAGE: \"message\"\r\n            }\r\n        }\r\n    },\r\n    WEBGL: {\r\n        DRAW_PROGRAMS: {\r\n            PRIMITIVES: \"drawPrimitives\",\r\n            IMAGES: \"drawImages\"\r\n        }\r\n    },\r\n    DRAW_TYPE: {\r\n        RECTANGLE: \"rect\",\r\n        CONUS: \"conus\",\r\n        CIRCLE: \"circle\",\r\n        POLYGON: \"polygon\",\r\n        LINE: \"line\",\r\n        TEXT: \"text\",\r\n        IMAGE: \"image\"\r\n    },\r\n    LAYERS: {\r\n        DEFAULT: \"default-view-layer\",\r\n        BOUNDARIES: \"boundaries-view-layer\"\r\n    },\r\n    GAME_OPTIONS: {},\r\n    LIBRARY: {\r\n        WEBGL: \"webgl\"\r\n    },\r\n    OPTIMIZATION: {\r\n        WEB_ASSEMBLY: {\r\n            ASSEMBLY_SCRIPT: \"ASSEMBLY_SCRIPT\"\r\n        }\r\n    }\r\n};\r\n\r\nconst ERROR_CODES = {\r\n    CREATE_INSTANCE_ERROR: \"CREATE_INSTANCE_ERROR\",\r\n    VIEW_NOT_EXIST: \"VIEW_NOT_EXIST\",\r\n    ELEMENT_NOT_EXIST: \"ELEMENT_NOT_EXIST\",\r\n    FILE_NOT_EXIST: \"FILE_NOT_EXIST\",\r\n    UNEXPECTED_INPUT_PARAMS: \"UNEXPECTED_INPUT_PARAMS\",\r\n    UNHANDLED_EXCEPTION: \"UNHANDLED_EXCEPTION\",\r\n    CANVAS_KEY_NOT_SPECIFIED: \"CANVAS_KEY_NOT_SPECIFIED\",\r\n    CANVAS_WITH_KEY_NOT_EXIST: \"CANVAS_WITH_KEY_NOT_EXIST\",\r\n    WRONG_TYPE_ERROR: \"WRONG_TYPE_ERROR\",\r\n    UNEXPECTED_WS_MESSAGE: \"UNEXPECTED_WS_MESSAGE\",\r\n    UNEXPECTED_PLAYER_ID: \"UNEXPECTED_PLAYER_ID\",\r\n    UNEXPECTED_BULLET_ID: \"UNEXPECTED_BULLET_ID\",\r\n    UNEXPECTED_EVENT_NAME: \"UNEXPECTED_EVENT_NAME\",\r\n    WEBGL_ERROR: \"WEBGL_ERROR\",\r\n    DRAW_PREPARE_ERROR: \"DRAW_PREPARE_ERROR\",\r\n    UNEXPECTED_TOUCH_AREA: \"UNEXPECTED_TOUCH_AREA\",\r\n};\r\n\r\nconst WARNING_CODES =  {\r\n    FILE_LOADING_ISSUE: \"FILE_LOADING_ISSUE\",\r\n    ASSETS_NOT_READY: \"ASSETS_NOT_READY\",\r\n    NOT_FOUND: \"NOT_FOUND\",\r\n    NOT_TESTED: \"NOT_TESTED\",\r\n    WORLD_DIMENSIONS_NOT_SET: \"WORLD_DIMENSIONS_NOT_SET\",\r\n    INCORRECT_RENDER_TYPE: \"INCORRECT_RENDER_TYPE\",\r\n    UNHANDLED_DRAW_ISSUE: \"UNHANDLED_DRAW_ISSUE\",\r\n    UNEXPECTED_WORLD_SIZE: \"UNEXPECTED_WORLD_SIZE\",\r\n    AUDIO_ALREADY_REGISTERED: \"AUDIO_ALREADY_REGISTERED\",\r\n    AUDIO_NOT_REGISTERED: \"AUDIO_NOT_REGISTERED\",\r\n    AUDIO_NOT_LOADED: \"AUDIO_NOT_LOADED\",\r\n    UNKNOWN_DRAW_OBJECT: \"UNKNOWN_DRAW_OBJECT\",\r\n    METHOD_NOT_IMPLEMENTED: \"METHOD_NOT_IMPLEMENTED\",\r\n    POLYGON_VERTICES_NOT_CORRECT: \"POLYGON_VERTICES_NOT_CORRECT\"\r\n};\n\n//# sourceURL=webpack://jsge/./src/constants.js?");

/***/ }),

/***/ "./src/design/LoadingScreen.js":
/*!*************************************!*\
  !*** ./src/design/LoadingScreen.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoadingScreen\": () => (/* binding */ LoadingScreen)\n/* harmony export */ });\n/* harmony import */ var _base_ScreenPage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base/ScreenPage.js */ \"./src/base/ScreenPage.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ \"./src/index.js\");\n\n\n\nconst logoKey = \"logoKey\";\nclass LoadingScreen extends _base_ScreenPage_js__WEBPACK_IMPORTED_MODULE_0__.ScreenPage {\n    #total = 0;\n    #loaded = 0;\n    #barWidth = 0;\n    register() {\n        //this.loader.addImage(logoKey, \"./images/icon.png\");\n    }\n\n    init() {\n        const [w, h] = this.screenPageData.canvasDimensions,\n            barWidth = w/3,\n            barHeight = 20;\n        this.createCanvasView(_index_js__WEBPACK_IMPORTED_MODULE_1__.CONST.LAYERS.DEFAULT);\n        //this.logo = this.draw.image(w/2, h/2, 300, 200, logoKey);\n        this.text = this.draw.text(w/2 - 20, h/2 - 2 * barHeight, \"JsGE\", \"24px sans-serif\", \"black\");\n        this.background = this.draw.rect(0, 0, w, h, this.systemSettings.gameOptions.loadingScreen.backgroundColor);  \n        this.loadingBarBg = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarBg);\n        this.loadingBarProgress = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarProgress);\n\n        this.#barWidth = barWidth;\n        this.addRenderObject(_index_js__WEBPACK_IMPORTED_MODULE_1__.CONST.LAYERS.DEFAULT, this.background);\n        this.addRenderObject(_index_js__WEBPACK_IMPORTED_MODULE_1__.CONST.LAYERS.DEFAULT, this.text);\n        //this.addRenderObject(CONST.LAYERS.DEFAULT, this.logo);\n        this.addRenderObject(_index_js__WEBPACK_IMPORTED_MODULE_1__.CONST.LAYERS.DEFAULT, this.loadingBarBg);\n        this.addRenderObject(_index_js__WEBPACK_IMPORTED_MODULE_1__.CONST.LAYERS.DEFAULT, this.loadingBarProgress);\n    }\n\n    _progress = (loaded, left) => {\n        const [w, h] = this.screenPageData.canvasDimensions,\n            widthPart = this.#barWidth / this.#total;\n\n        this.#loaded = loaded;\n        \n        this.loadingBarProgress.width = widthPart * this.#loaded;\n    };\n\n    start(options) {\n        this.#total = options.total;\n    }\n\n    // a workaround for checking upload progress before render\n    get loader() {\n        return ({filesWaitingForUpload:0});\n    }\n} \n\n//# sourceURL=webpack://jsge/./src/design/LoadingScreen.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CONST\": () => (/* reexport safe */ _constants_js__WEBPACK_IMPORTED_MODULE_6__.CONST),\n/* harmony export */   \"DrawImageObject\": () => (/* reexport safe */ _base_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_2__.DrawImageObject),\n/* harmony export */   \"Primitives\": () => (/* reexport module object */ _base_Primitives_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   \"ScreenPage\": () => (/* reexport safe */ _base_ScreenPage_js__WEBPACK_IMPORTED_MODULE_1__.ScreenPage),\n/* harmony export */   \"System\": () => (/* reexport safe */ _base_System_js__WEBPACK_IMPORTED_MODULE_0__.System),\n/* harmony export */   \"SystemAudioInterface\": () => (/* reexport safe */ _base_SystemAudioInterface_js__WEBPACK_IMPORTED_MODULE_3__.SystemAudioInterface),\n/* harmony export */   \"SystemSettings\": () => (/* reexport safe */ _configs_js__WEBPACK_IMPORTED_MODULE_5__.SystemSettings),\n/* harmony export */   \"utils\": () => (/* reexport module object */ _utils_js__WEBPACK_IMPORTED_MODULE_7__)\n/* harmony export */ });\n/* harmony import */ var _base_System_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/System.js */ \"./src/base/System.js\");\n/* harmony import */ var _base_ScreenPage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/ScreenPage.js */ \"./src/base/ScreenPage.js\");\n/* harmony import */ var _base_DrawImageObject_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base/DrawImageObject.js */ \"./src/base/DrawImageObject.js\");\n/* harmony import */ var _base_SystemAudioInterface_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base/SystemAudioInterface.js */ \"./src/base/SystemAudioInterface.js\");\n/* harmony import */ var _base_Primitives_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base/Primitives.js */ \"./src/base/Primitives.js\");\n/* harmony import */ var _configs_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./configs.js */ \"./src/configs.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants.js */ \"./src/constants.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils.js */ \"./src/utils.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://jsge/./src/index.js?");

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"angle_2points\": () => (/* binding */ angle_2points),\n/* harmony export */   \"angle_3points\": () => (/* binding */ angle_3points),\n/* harmony export */   \"countClosestTraversal\": () => (/* binding */ countClosestTraversal),\n/* harmony export */   \"countClosestTraversal2\": () => (/* binding */ countClosestTraversal2),\n/* harmony export */   \"countDistance\": () => (/* binding */ countDistance),\n/* harmony export */   \"crossProduct\": () => (/* binding */ crossProduct),\n/* harmony export */   \"dotProduct\": () => (/* binding */ dotProduct),\n/* harmony export */   \"dotProductWithAngle\": () => (/* binding */ dotProductWithAngle),\n/* harmony export */   \"generateUniqId\": () => (/* binding */ generateUniqId),\n/* harmony export */   \"isLineShorter\": () => (/* binding */ isLineShorter),\n/* harmony export */   \"isMobile\": () => (/* binding */ isMobile),\n/* harmony export */   \"isPointCircleIntersect\": () => (/* binding */ isPointCircleIntersect),\n/* harmony export */   \"isPointLineIntersect\": () => (/* binding */ isPointLineIntersect),\n/* harmony export */   \"isPointOnTheLine\": () => (/* binding */ isPointOnTheLine),\n/* harmony export */   \"isPointPolygonIntersect\": () => (/* binding */ isPointPolygonIntersect),\n/* harmony export */   \"isPointRectIntersect\": () => (/* binding */ isPointRectIntersect),\n/* harmony export */   \"isPolygonLineIntersect\": () => (/* binding */ isPolygonLineIntersect),\n/* harmony export */   \"isSafari\": () => (/* binding */ isSafari),\n/* harmony export */   \"pointToCircleDistance\": () => (/* binding */ pointToCircleDistance),\n/* harmony export */   \"verticesArrayToArrayNumbers\": () => (/* binding */ verticesArrayToArrayNumbers)\n/* harmony export */ });\n/* harmony import */ var _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/Primitives.js */ \"./src/base/Primitives.js\");\n\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent) ;\r\n}\r\n\r\nfunction isSafari() {\r\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n}\r\n\r\nfunction pointToCircleDistance(x, y, circle) {\r\n    const pointToCircleCenterDistance = new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y, circle.x, circle.y).length;\r\n    return pointToCircleCenterDistance - circle.r;\r\n}\r\n\r\nfunction countClosestTraversal(line, sight) {\r\n    const x1 = sight.x1,\r\n        y1 = sight.y1,\r\n        x2 = sight.x2,\r\n        y2 = sight.y2;\r\n    const x3 = line.x1,\r\n        y3 = line.y1,\r\n        x4 = line.x2,\r\n        y4 = line.y2;\r\n\r\n    const r_px = x1,\r\n        r_py = y1,\r\n        r_dx = x2-x1,\r\n        r_dy = y2-y1;\r\n\r\n    const s_px = x3,\r\n        s_py = y3,\r\n        s_dx = x4-x3,\r\n        s_dy = y4-y3;\r\n\r\n    const r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy),\r\n        s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);\r\n    if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){\r\n        return null;\r\n    }\r\n\r\n    const T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx),\r\n        T1 = (s_px+s_dx*T2-r_px)/r_dx;\r\n\r\n    if(T1<0 || isNaN(T1)) return null;\r\n    if(T2<0 || T2>1) return null;\r\n\r\n    return {\r\n        x: r_px+r_dx*T1,\r\n        y: r_py+r_dy*T1,\r\n        p: T1\r\n    };\r\n}\r\n\r\n/**\r\n * \r\n * @param {{x1:number, y1:number, x2:number, y2:number}} line1 \r\n * @param {{x1:number, y1:number, x2:number, y2:number}} line2 \r\n * @returns {{x:number, y:number, p:number} | undefined}\r\n * @ignore\r\n */\r\nfunction countClosestTraversal2(line1, line2) {\r\n    const x1 = line2.x1,\r\n        y1 = line2.y1,\r\n        x2 = line2.x2,\r\n        y2 = line2.y2;\r\n    const x3 = line1.x1,\r\n        y3 = line1.y1,\r\n        x4 = line1.x2,\r\n        y4 = line1.y2;\r\n\r\n    const det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n    // lines are parallel, or coincident\r\n    if (det === 0){\r\n        return;\r\n    }\r\n    let x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / det;\r\n    let y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / det;\r\n    const point = {x, y};\r\n    \r\n    if (isPointOnTheLine(point, line1, 0.0000000000001) && isPointOnTheLine(point, line2, 0.0000000000001)) {\r\n        const p = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));\r\n        return {x, y, p};\r\n    } else {\r\n        return;\r\n    }\r\n}\r\n\r\nfunction angle_2points(x1, y1, x2, y2) {\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n}\r\n\r\nfunction angle_3points(a, b, c) {\r\n    const x1 = a.x - b.x,\r\n        x2 = c.x - b.x,\r\n        y1 = a.y - b.y,\r\n        y2 = c.y - b.y,\r\n        d1 = Math.sqrt(x1 * x1 + y1 * y1),\r\n        d2 = Math.sqrt(x2 * x2 + y2 * y2);\r\n    //console.log(\"angle: \", (Math.acos((x1* x2 + y1 * y2) / (d1 * d2))* 180) / Math.PI);\r\n    return Math.acos((x1* x2 + y1 * y2) / (d1 * d2));\r\n}\r\n\r\nfunction dotProductWithAngle(lenA, lenB, angle) {\r\n    return lenA * lenB * Math.cos(angle);\r\n}\r\n\r\nfunction dotProduct(vec1, vec2) {\r\n    return vec1.x * vec2.x + vec1.y * vec2.y;\r\n}\r\n\r\nfunction crossProduct(a, b) {\r\n    return (a.x * b.y - b.x * a.y);\r\n}\r\n\r\nfunction isPointOnTheLine(point, line, m_error = 0) {\r\n    return  (\r\n        ((point.x >= (line.x1 - m_error)) && (point.x <= (line.x2 + m_error))) || \r\n                ((point.x <= (line.x1 + m_error)) && (point.x >= (line.x2 - m_error)))\r\n    ) && (\r\n        ((point.y >= (line.y1 - m_error)) && (point.y <= (line.y2 + m_error))) || \r\n                ((point.y <= (line.y1 + m_error)) && (point.y >= (line.y2 - m_error)))\r\n    );\r\n}\r\n\r\nfunction countDistance(obj1, obj2) {\r\n    return new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(obj1.x, obj1.y, obj2.x, obj2.y).length;\r\n}\r\n\r\nfunction isLineShorter(line1, line2) {\r\n    return (new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line1.x1, line1.y1, line1.x2, line1.y2)).length < (new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line2.x1, line2.y1, line2.x2, line2.y2)).length;\r\n}\r\n\r\nfunction isPointLineIntersect(point, line) {\r\n    const lineL = new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line.x1, line.y1, line.x2, line.y2).length,\r\n        lengthAB = new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line.x1, line.y1, point.x, point.y).length + new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(line.x2, line.y2, point.x, point.y).length;\r\n\r\n    if (lengthAB <= lineL + 0.2) {\r\n        //Logger.debug(\"point to line intersect. line len: \" + lineL + \", line AB len: \" + lengthAB);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<Array<number>>} polygon \r\n * @param {{x1:number, y1:number, x2:number, y2:number}} line \r\n * @returns {{x:number, y:number, p:number} | null}\r\n * @ignore\r\n */\r\nfunction isPolygonLineIntersect(polygon, line) {\r\n    const len = polygon.length;\r\n    for (let i = 0; i < len; i+=1) {\r\n        let curr = polygon[i],\r\n            next = polygon[i+1];\r\n        //if next item not exist and current is not first\r\n        if (!next) {\r\n            // if current vertex is not the first one\r\n            if (!(curr[0] === polygon[0][0] && curr[1] === polygon[0][1])) {\r\n                next = polygon[0];\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\r\n        const intersection = countClosestTraversal2(edge, line);\r\n        if (intersection) {\r\n            return intersection;\r\n        }\r\n    }\r\n    if (polygon[len-1][0] !== polygon[0][0] && polygon[len-1][1] !== polygon[0][1]) {\r\n        //check one last item\r\n        const curr = polygon[len - 1],\r\n            next = polygon[0];\r\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\r\n        const intersection = countClosestTraversal2(edge, line);\r\n        if (intersection) {\r\n            return intersection;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isPointPolygonIntersect(/*x, y, polygon*/) {\r\n    //const vertices = polygon.vertices;\r\n\r\n    return false;\r\n}\r\n\r\nfunction isPointRectIntersect(x, y, rect) {\r\n    if (x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.y + rect.height) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction isPointCircleIntersect(x, y, circle) {\r\n    const radius = circle.width,\r\n        lineToCircleCenter = new _base_Primitives_js__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y, circle.x, circle.y),\r\n        pointCircleLineLength = lineToCircleCenter.length;\r\n    if (pointCircleLineLength < radius)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nfunction generateUniqId() {\r\n    return Math.round(Math.random() * 1000000); \r\n}\r\n\r\nfunction verticesArrayToArrayNumbers(array) {\r\n    const len = array.length,\r\n        numbers = [];\r\n    for (let i = 0; i < len; i++) {\r\n        const vertex = array[i];\r\n        numbers.push([vertex.x, vertex.y]);\r\n    }\r\n    return numbers;\r\n}\r\n\r\n\n\n//# sourceURL=webpack://jsge/./src/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "jsge:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			};
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkjsge"] = self["webpackChunkjsge"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;