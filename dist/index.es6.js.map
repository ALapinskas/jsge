{"version":3,"file":"index.es6.js","mappings":";;;;;;;;;;;;AAAA,2BAA2B,qGAAqG,aAAa,GAAG,GAAG,WAAW,WAAW,iBAAiB,+BAA+B,oBAAoB,yDAAyD,wFAAwF,+BAA+B,6HAA6H,GAAG,QAAQ,iBAAiB,MAAM,kBAAkB,4BAA4B,oBAAoB,mBAAmB,eAAe,mBAAmB,eAAe,iBAAiB,8FAA8F,iCAAiC,2BAA0C,oBAAoB,mBAAmB,WAAW,KAAK,cAAc,4LAA4L,4BAA4B,QAAQ,2EAA2E,iDAAiD,2BAA2B,yBAAyB,wFAAwF,wCAAwC,kBAAkB,UAAU,sCAAsC,qBAAqB,gDAAgD,cAAc,mBAAmB,GAAG,GAAG,KAAK,SAAS,iDAAiD,kDAAkD,qCAAqC,GAAG,mCAAmC,eAAe,0BAA0B,iBAAiB,uBAAuB,GAAG,GAAG,2BAA2B,wHAAwH,8BAA8B,sCAAsC,mFAAmF,MAAM,eAAe,GAAG,iGAAiG,eAAe,mDAAmD,yBAAyB,IAAI,qCAAqC,4EAA4E,gCAAgC,mNAAmN,WAAW,mCAAmC,MAAM,oBAAoB,qFAAqF,UAAU,4BAA4B,YAAY,WAAW,KAAK,aAAa,qBAAqB,0BAA0B,GAAG,0BAA0B,yHAAyH,uCAAuC,qBAAqB,sCAAsC,eAAe,oCAAoC,yCAAyC,gBAAgB,GAAG,GAAG,qDAAqD,kBAAkB,8BAA8B,+BAA+B,eAAe,GAAG,gBAAgB,yCAAyC,gBAAgB,SAAS,GAAG,MAAM,uIAAuI,MAAM,+HAA+H,oBAAoB,uBAAuB,yFAAyF,mBAAmB,uBAAuB,gCAAgC,iDAAiD,aAAa,uBAAuB,0BAA0B,iDAAiD,QAAQ,6CAA6C,0EAA0E,KAAK,iCAAiC,uEAAuE,QAAQ,GAAG,KAAK,mEAAmE,KAAK,mCAAmC,iFAAiF,2CAA2C,GAAG,MAAM,mEAAmE,QAAQ,IAAI,sBAAsB,mBAAmB,oBAAoB;;;;;;;;;;;;;;ACAz1J;AACP;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1EwC;AACe;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,+BAA+B,gEAAe;AACrD;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,iEAAsB;AACpC;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CwC;AACe;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,8BAA8B,gEAAe;AACpD;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gEAAqB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5EqE;AAChB;AACE;AACI;AAChB;AAC3C;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,8BAA8B,gEAAe;AACpD;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gEAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,gBAAgB;AAChC,gBAAgB,UAAU;AAC1B,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,YAAY,wDAAS,CAAC,8EAAmC;AACzD;AACA,mCAAmC,8EAAsB;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzQwC;AACe;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,+DAAoB;AAClC;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChCqD;AACA;AACE;AACA;AACF;AACM;AACF;AACJ;AACE;AACJ;;AAEnD;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,8DAAc;AAC/C;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,8DAAc;AAC/C;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA,iCAAiC,gEAAe;AAChD;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,kEAAgB;AACjD;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO,mBAAmB,KAAK,SAAS,GAAG;AAC1D,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,gEAAe;AAC9C;AACA;AACA;AACA;;AAEA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,8DAAc;AAC/C;AACA;AACA;;AAEA;AACA,eAAe,OAAO,mBAAmB,GAAG;AAC5C,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,oEAAiB;AAClD;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAc;;AAE7C;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtMwC;AACe;;AAEvD;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,gCAAgC,gEAAe;AACtD;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,kEAAuB;AACrC;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/BwC;AACe;;AAEvD;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,oEAAyB;AACvC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DwC;AACJ;;AAEpC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU,2DAAoB;AAC9B;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,eAAe,8BAA8B,mBAAmB,GAAG;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,wEAAiC;AACpD,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1QuD;AACX;AACS;AACV;AACgB;;AAE3D;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,+DAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,mBAAmB,qDAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,0EAA+B;AACrD;AACA;AACA;;;;;;;;;;;;;;;;AC9MuD;AACI;AAC3D;AACA;AACA,SAAS,yBAAyB;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC7IwD;AACZ;;AAErC;AACP;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;;AAEA;AACA,6BAA6B,+EAAoC;AACjE;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNoE;AACjB;AACC;AACkB;AACX;AACF;AACF;AACA;AACF;AACM;AACN;AACA;AACd;AACU;AACF;AACkE;AACxE;;AAEzC;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,8BAA8B,4DAAa;AAC3C;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,gFAAqC;AACzD,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAoB;AACjC,aAAa,oEAAyB;AACtC,aAAa,gEAAqB;AAClC,aAAa,gEAAqB;AAClC;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa,iEAAsB;AACnC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA,aAAa,+DAAoB;AACjC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA,YAAY,sDAAO,CAAC,kFAAuC;AAC3D;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,eAAe,wBAAwB;AACvC,kBAAkB,8BAA8B,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAoB;AACjC,aAAa,oEAAyB;AACtC,aAAa,gEAAqB;AAClC,aAAa,gEAAqB;AAClC;AACA;AACA,cAAc;AACd;AACA;AACA,aAAa,iEAAsB;AACnC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA,aAAa,+DAAoB;AACjC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA,YAAY,sDAAO,CAAC,kFAAuC;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC,iBAAiB,oEAAyB;AAC1C,iBAAiB,gEAAqB;AACtC,iBAAiB,gEAAqB;AACtC;AACA;AACA,iBAAiB,iEAAsB;AACvC;AACA;AACA,iBAAiB,+DAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC,iBAAiB,oEAAyB;AAC1C,iBAAiB,gEAAqB;AACtC,iBAAiB,gEAAqB;AACtC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iBAAiB,iEAAsB;AACvC;AACA;AACA,iBAAiB,+DAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,iEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,mDAAM;AAC9B;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,kEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mDAAM;AACjC,0BAA0B,yDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,iEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,sBAAsB;AACrC,eAAe,QAAQ;AACvB,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,kEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtkBgD;AACP;AACzC;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA,6BAA6B,iCAAiC;AAC9D,6BAA6B,6CAA6C;AAC1E,6BAA6B,6CAA6C;AAC1E,6BAA6B,iCAAiC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrWuC;;AAEvC;AACA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oEAAoE;AACnF,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1DqD;AACV;AACN;AACiB;;AAEtD;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;;AAEA;AACA,QAAQ,mOAA0B;AAClC,4EAA4E,sBAAsB;AAClG;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,kGAAuD;AACjF;;AAEA;AACA,0BAA0B,8FAAmD;AAC7E;;AAEA;AACA,0BAA0B,8FAAmD;AAC7E;;AAEA;AACA,QAAQ,oDAAY;AACpB,qCAAqC,yGAA8D;AACnG;;AAEA;AACA,QAAQ,oDAAY;AACpB,qCAAqC,yGAA8D;AACnG;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,8FAAmD;AAC9F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,0FAA+C;AAC1F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,uFAA4C,GAAG,UAAU;AACpG;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,oFAAyC,GAAG,KAAK;AAC5F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,sFAA2C,GAAG,UAAU;AACnG;;AAEA;AACA,+BAA+B,+DAAW,CAAC,4FAAiD,GAAG,SAAS;AACxG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrIqD;AACD;AACS;AACR;AACN;AACI;AACmB;AACtE,WAAW,sBAAsB;AACO;AACe;AACE;AACF;AACF;AACM;AACN;AACA;AACyD;AACgC;;AAE9I;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;;AAE5E;AACA;;AAEA;AACA;;AAEA;;AAEA,gCAAgC,8DAAW;AAC3C,6DAA6D,qFAA0C;AACvG,6DAA6D,0FAA+C;AAC5G;AACA;;AAEA;AACA;AACA,uDAAuD,2EAAgC,EAAE,yEAAe,EAAE,2EAAiB,EAAE,qEAAW,EAAE,uEAAa;AACvJ;AACA;AACA,uDAAuD,+EAAoC,EAAE,oFAAsB,EAAE,sFAAwB,EAAE,gFAAkB,EAAE,kFAAoB;AACvL;AACA;;AAEA,mCAAmC,oEAAmB,+BAA+B,2EAAgC;AACrH,mCAAmC,oEAAmB,qCAAqC,+EAAoC;AAC/H,mCAAmC,0EAAsB,qCAAqC,+EAAoC;AAClI,mCAAmC,uEAAqB,gCAAgC,+EAAoC;AAC5H,mCAAmC,qEAAoB,gCAAgC,+EAAoC;AAC3H,mCAAmC,mEAAmB,qCAAqC,2EAAgC;AAC3H,mCAAmC,oEAAmB,+BAA+B,+EAAoC;AACzH;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oEAAoE;AACnF,eAAe,SAAS;AACxB;AACA;AACA,4DAA4D,qEAAqE;AACjI;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sDAAO,CAAC,kEAAuB;AACnD;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sDAAO,CAAC,8EAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,iBAAiB;AACvD,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,8IAA8I;AAC7J,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA,sCAAsC,gEAAqB;AAC3D,6DAA6D,2EAAgC;AAC7F,oEAAoE,2EAAgC;;AAEpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAmB;AACpC;AACA;AACA;AACA;AACA,wDAAwD,sFAA2C;AACnG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAO,CAAC,6EAAkC;AAClE;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA,2GAA2G,qFAA0C;AACrJ;AACA,kBAAkB,2EAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAA8B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,gBAAgB,sDAAO,CAAC,6EAAkC;AAC1D,aAAa;AACb;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtkBoE;AAChB;AACX;AACQ;AACF;AACuB;AACX;AAChB;AACJ;AACM;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB,SAAS,iBAAiB;AAC1B;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,mBAAmB,4EAAa;AAChC;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,6BAA6B,oEAAiB;AAC9C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;AACA,yCAAyC,0DAAY;AACrD,2CAA2C,kDAAQ;AACnD,4BAA4B,gDAAO;AACnC,+BAA+B,sDAAU;AACzC;AACA;AACA,uCAAuC,2EAAgC,kBAAkB,2EAAgC;AACzH,uCAAuC,yEAA8B,kBAAkB,yEAA8B;AACrH;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAA8B;AACpD;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,qEAA0B;AAChD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,sBAAsB,wEAA6B;AACnD;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,qEAA0B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;ACvNuE;AACvB;AACP;;AAEzC;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,yEAA8B;AAClD;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,sDAAO,CAAC,6EAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,yEAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,sDAAO,CAAC,6EAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7F+C;AACP;;AAEjC;AACP;AACA,YAAY,4DAAmB,KAAK,2DAAgB;AACpD;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC7E8C;AACH;AACA;AACJ;AACQ;;AAEU;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,gDAAO;;AAEnC,4CAA4C,iEAAY;;AAExD;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,mBAAmB;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC9FA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AChEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzEA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxCuE;AACzB;AACO;AACD;AACC;;AAE9C;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,YAAY,wDAAS,CAAC,8EAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uDAAuD,qFAA0C;AACjG;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;;AAEA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;;AAEA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,kEAAuB,0CAA0C,KAAK;AAChG;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB,+CAA+C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB,qBAAqB,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa,oEAAyB;AACtC;AACA;AACA;AACA,aAAa,+DAAoB;AACjC;AACA,aAAa,iEAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAuB;AACpC;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,qFAA0C,cAAc,gBAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,8DAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA,aAAa,qFAA0C;AACvD;AACA;AACA,aAAa,0FAA+C;AAC5D,aAAa,qFAA0C;AACvD;AACA;AACA,aAAa,iFAAsC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,8DAAc;AACvD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+EAAoC;AAC5E,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B,+EAAoC;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,+EAAoC;AAC5E,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B,+EAAoC;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAO,CAAC,8EAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sDAAO,CAAC,8EAAmC;AAC/D;AACA;AACA,kCAAkC,iBAAiB;AACnD,sCAAsC,iBAAiB;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAO,CAAC,8EAAmC;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,2FAA2F,QAAQ;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC,uDAAY,EAAE,8BAA8B,GAAG,8BAA8B;;AAElH;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,wDAAS,CAAC,yEAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC33CuC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAgB;;AAElC;AACA;AACA,iBAAiB,8DAAmB;AACpC,sBAAsB,iFAAsC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,sFAA2C;AAClE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACpEO;AACP;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,oBAAoB;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1HiD;;AAE1C,2BAA2B,yDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtC0C;AACM;AACY;AACN;AACH;AACL;AACP;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPU;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,uDAAM;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,6CAA6C;AACzD,YAAY,6CAA6C;AACzD,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAM;AACrB;;AAEA;AACA,gBAAgB,uDAAM,wDAAwD,uDAAM;AACpF;;AAEA;AACA,sBAAsB,uDAAM;AAC5B,uBAAuB,uDAAM,kDAAkD,uDAAM;;AAErF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,6CAA6C;AACzD,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,uDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,mBAAmB;AACnC,gBAAgB,qBAAqB;AACrC,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,yBAAyB;AACzB;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;;;;;;;;SC5PA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;;;;UCzBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,EAAE;UACF;;;;;UCRA;UACA;UACA;UACA;UACA;;;;;UCJA;;;;;UCAA;UACA;UACA;UACA;UACA,uBAAuB,4BAA4B;UACnD;UACA;UACA;UACA,iBAAiB,oBAAoB;UACrC;UACA,mGAAmG,YAAY;UAC/G;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,mEAAmE,iCAAiC;UACpG;UACA;UACA;UACA;;;;;UCxCA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;UCNA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;UCNA;;UAEA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA;UACA,iCAAiC;;UAEjC;UACA;UACA;UACA,KAAK;UACL,eAAe;UACf;UACA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM;UACN;UACA;UACA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM,qBAAqB;UAC3B;UACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;UACA;UACA;;;;;SErFA;SACA;SACA;SACA","sources":["webpack://jsge/./modules/assetsm/dist/assetsm.min.js","webpack://jsge/./src/base/AnimationEventImageObj.js","webpack://jsge/./src/base/DrawCircleObject.js","webpack://jsge/./src/base/DrawConusObject.js","webpack://jsge/./src/base/DrawImageObject.js","webpack://jsge/./src/base/DrawLineObject.js","webpack://jsge/./src/base/DrawObjectFactory.js","webpack://jsge/./src/base/DrawPolygonObject.js","webpack://jsge/./src/base/DrawRectObject.js","webpack://jsge/./src/base/DrawShapeObject.js","webpack://jsge/./src/base/DrawTextObject.js","webpack://jsge/./src/base/DrawTiledLayer.js","webpack://jsge/./src/base/Events/SystemEvent.js","webpack://jsge/./src/base/Exception.js","webpack://jsge/./src/base/GameStage.js","webpack://jsge/./src/base/GameStageData.js","webpack://jsge/./src/base/IExtension.js","webpack://jsge/./src/base/INetwork.js","webpack://jsge/./src/base/IRender.js","webpack://jsge/./src/base/ISystem.js","webpack://jsge/./src/base/ISystemAudio.js","webpack://jsge/./src/base/Logger.js","webpack://jsge/./src/base/Primitives.js","webpack://jsge/./src/base/System.js","webpack://jsge/./src/base/WebGl/ImagesDrawProgram.js","webpack://jsge/./src/base/WebGl/PrimitivesDrawProgram.js","webpack://jsge/./src/base/WebGl/TextureStorage.js","webpack://jsge/./src/base/WebGl/WebGlEngine.js","webpack://jsge/./src/configs.js","webpack://jsge/./src/constants.js","webpack://jsge/./src/design/LoadingStage.js","webpack://jsge/./src/index.js","webpack://jsge/./src/utils.js","webpack://jsge/webpack/bootstrap","webpack://jsge/webpack/runtime/define property getters","webpack://jsge/webpack/runtime/ensure chunk","webpack://jsge/webpack/runtime/get javascript chunk filename","webpack://jsge/webpack/runtime/hasOwnProperty shorthand","webpack://jsge/webpack/runtime/load script","webpack://jsge/webpack/runtime/make namespace object","webpack://jsge/webpack/runtime/publicPath","webpack://jsge/webpack/runtime/jsonp chunk loading","webpack://jsge/webpack/before-startup","webpack://jsge/webpack/startup","webpack://jsge/webpack/after-startup"],"sourcesContent":["const PROGRESS_EVENT_TYPE={loadstart:\"loadstart\",progress:\"progress\",abort:\"abort\",error:\"error\",load:\"load\",timeout:\"timeout\"};class Loader{#e;#t;#s=new Map;#i=new Map;constructor(e,t){this.#e=e,this.#t=(e,s,...i)=>{const r=t(e,s,...i);if(r instanceof Promise)return r.then((t=>this.#r(t,e)));Exception(\"uploadMethod should be instance of Promise and return upload result value\")}}#r=(e,t)=>new Promise(((s,i)=>{e&&0!==e.length||Warning(\"uploadMethod for \"+this.#e+\" should return Promise with upload value\"),this.#o(t,e),this.#a(t),s()}));#o(e,t){this.#i.set(e,t)}#a(e){this.#s.delete(e)}get filesWaitingForUpload(){return this.#s.size}get loadingQueue(){return this.#s}get uploadMethod(){return this.#t}_addFile=(e,t)=>{this.#s.has(e)&&Warning(\"File \"+this.#e+\" with key \"+e+\" is already added\"),this.#s.set(e,t)};_isFileInQueue=e=>this.#s.has(e);_getFile=e=>this.#i.get(e)}export default class AssetsManager{#n=new EventTarget;#d=new Map;#l=0;constructor(){this.registerLoader(\"Audio\",this._loadAudio),this.registerLoader(\"Image\",this._loadImage),this.registerLoader(\"TileMap\",this._loadTileMap),this.registerLoader(\"TileSet\",this._loadTileSet)}get filesWaitingForUpload(){let e=0;return Array.from(this.#d.values()).map((t=>e+=t.filesWaitingForUpload)),e}registerLoader=(e,t=this._defaultUploadMethod)=>{this[\"add\"+e]=(t,s,...i)=>{this.addFile(e,t,s,...i)},this[\"get\"+e]=t=>this.getFile(e,t),this[\"is\"+e+[\"InQueue\"]]=t=>this.isFileInQueue(e,t);const s=this.#d.get(e)||new Loader(e,t);this.#d.set(e,s)};preload(){return this.#h(),new Promise(((e,t)=>{this.#u().then((()=>{this.filesWaitingForUpload?this.#u().then((()=>{this.#c(),e()})):(this.#c(),e())}))}))}#u(){let e=[];return Array.from(this.#d.values()).forEach((t=>{Array.from(t.loadingQueue.entries()).forEach((s=>{e.push(t.uploadMethod(s[0],...s[1]))}))})),Promise.allSettled(e).then((e=>{e.forEach((e=>{if(\"rejected\"===e.status){const t=e.reason;Warning(t),this.#g(t)}}))}))}addEventListener(e,t,...s){PROGRESS_EVENT_TYPE[e]?this.#n.addEventListener(e,t,...s):Warning(\"Event type should be one of the ProgressEvent.type\")}removeEventListener(e,t,...s){this.#n.removeEventListener(e,t,...s)}_loadTileSet=(e,t,s=1,i)=>(this.#p(t),fetch(i?i+t:t).then((e=>e.json())).then((e=>{const{name:t,image:r}=e;return t&&r&&!this.isFileInQueue(\"Image\",t)&&this.addImage(t,i?i+r:r),e.gid=s,Promise.resolve(e)})).catch((()=>{const e=new Error(\"Can't load related tileset \"+t);return Promise.reject(e)})));_defaultUploadMethod=(e,t)=>fetch(t);_loadTileMap=(e,t,s=!0)=>(this.#E(t),fetch(t).then((e=>e.json())).then((e=>{let i,r=t.split(\"/\"),o=r.length;if(r[o-1].includes(\".tmj\")||r[o-1].includes(\".json\")?(r.pop(),i=r.join(\"/\")+\"/\"):(r[o-2].includes(\".tmj\")||r[o-2].includes(\".json\"))&&(r.splice(o-2,2),i=r.join(\"/\")+\"/\"),!0===s&&e.tilesets&&e.tilesets.length>0){const t=[];return e.tilesets.forEach(((e,s)=>{const{firstgid:r,source:o}=e,a=this._loadTileSet(\"default-\"+r,o,r,i).then((e=>(this.#m(),Promise.resolve(e))));t.push(a)})),Promise.all(t).then((t=>{for(let s=0;s<t.length;s++){const i=t[s];e.tilesets[s].data=i}return Promise.resolve(e)}))}return Promise.resolve(e)})).catch((e=>(e.message.includes(\"JSON.parse:\")&&(e=new Error(\"Can't load tilemap \"+t)),this.#g(e),Promise.reject(e)))));_loadAudio=(e,t)=>new Promise(((e,s)=>{const i=new Audio(t);i.addEventListener(\"loadeddata\",(()=>{this.#m(),e(i)})),i.addEventListener(\"error\",(()=>{const e=new Error(\"Can't load audio \"+t);this.#g(e),s(e)}))}));_loadImage=(e,t,s=\"anonymous\")=>new Promise(((e,i)=>{const r=new Image;r.crossOrigin=s,r.onload=()=>{createImageBitmap(r).then((t=>{this.#m(),e(t)}))},r.onerror=()=>{const e=new Error(\"Can't load image \"+t);this.#g(e),i(e)},r.src=t}));#p(e){e.includes(\".tsj\")||e.includes(\".json\")||Exception(\"Related Tileset file type is not correct, only .tsj or .json files are supported\")}#E(e){e.includes(\".tmj\")||e.includes(\".json\")||Exception(\"Tilemap file type is not correct, only .tmj or .json files are supported\")}addFile(e,t,s,...i){const r=this.#d.get(e);r?(this.#f(t,s),r._addFile(t,[s,...i])):Exception(\"Loader for \"+e+\" is not registered!\")}isFileInQueue(e,t){const s=this.#d.get(e);if(s)return s._isFileInQueue(t);Exception(\"Loader for \"+e+\" is not registered!\")}getFile(e,t){const s=this.#d.get(e);if(s)return s._getFile(t);Exception(\"Loader for \"+e+\" is not registered!\")}#f(e,t){const s=\"fileKey and url should be provided\";e&&0!==e.trim().length||Exception(s),t&&0!==t.trim().length||Exception(s)}#h(){let e=this.filesWaitingForUpload;this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart,{total:e}))}#c(){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load))}#m(){const e=this.filesWaitingForUpload;this.#l+=1,this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress,{lengthComputable:!0,loaded:this.#l,total:e}))}#g(e){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.error,{error:e}))}}function Exception(e){throw new Error(e)}function Warning(e){console.warn(e)}","export class AnimationEventImageObj {\n    #eventName;\n    /**\n     * @type {Array<number>}\n     */\n    #animationSpriteIndexes;\n    /**\n     * @type {number}\n     */\n    #currentSpriteIndex;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {boolean}\n     */\n    #isRepeated;\n    /**\n     * @type {number}\n     */\n    #cyclesPerFrame;\n    // first cycle should be always skipped, eg showing the current frame\n    #cyclesSkipped = 0;\n    \n    constructor(eventName, animationSpriteIndexes, isRepeated = false, cyclesPerFrame, currentSpriteIndex, isActive = false) {\n        this.#eventName = eventName;\n        this.#animationSpriteIndexes = animationSpriteIndexes;\n        this.#cyclesPerFrame = cyclesPerFrame;\n        this.#currentSpriteIndex = currentSpriteIndex ? currentSpriteIndex : 0;\n        this.#isActive = isActive;\n        this.#isRepeated = isRepeated;\n    }\n\n    get isActive() {\n        return this.#isActive;\n    }\n\n    get currentSprite() {\n        return this.#animationSpriteIndexes[this.#currentSpriteIndex];\n    }\n\n    get isLastSprite() {\n        return (this.#animationSpriteIndexes.length - 1) === this.#currentSpriteIndex;\n    }\n\n    iterateSprite() {\n        if (this.#cyclesPerFrame <= this.#cyclesSkipped) {\n            if (!this.isLastSprite) {\n                this.#currentSpriteIndex = this.#currentSpriteIndex + 1;\n            } else {\n                if (!this.#isRepeated) {\n                    this.deactivateAnimation();\n                } else {\n                    this.#currentSpriteIndex = 0;\n                }\n            }\n            // if animation is in progress, we reset it to the first item, because the first cycles already skipped\n            this.#cyclesSkipped = 1;\n        } else {\n            this.#cyclesSkipped += 1;\n        }\n    }\n\n    activateAnimation = () => {\n        this.#isActive = true;\n        this.#currentSpriteIndex = 0;\n        this.#cyclesSkipped = 0;\n    };\n\n    deactivateAnimation = () => {\n        this.#isActive = false;\n        this.#cyclesSkipped = 0;\n    };\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Circle object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawCircleObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #radius;\n\n    /**\n     * @type {Array<number>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, radius, bgColor) {\n        super(CONST.DRAW_TYPE.CIRCLE, x, y, bgColor);\n        this.#radius = radius;\n        this.#vertices = this._calculateConusVertices(radius);\n    }\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get radius() {\n        return this.#radius;\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Conus object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawConusObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #radius;\n\n    /**\n     * @type {number}\n     */\n    #angle;\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    #vertices;\n    #fade_min;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, radius, bgColor, angle, fade = 0) {\n        super(CONST.DRAW_TYPE.CONUS, x, y, bgColor);\n        this.#radius = radius;\n        this.#angle = angle;\n        this.#fade_min = fade;\n        this.#vertices = this._calculateConusVertices(radius, angle);\n    }\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get radius() {\n        return this.#radius;\n    }\n\n    /**\n     * @type {number}\n     */\n    get angle() {\n        return this.#angle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get fade_min() {\n        return this.#fade_min;\n    }\n\n    /**\n     * @param {number} value - fade start pos in px\n     */\n    set fade_min(value) {\n        this.#fade_min = value;\n    }\n}","import { AnimationEventImageObj } from \"./AnimationEventImageObj.js\";\nimport { CONST, ERROR_CODES } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { TextureStorage } from \"./WebGl/TextureStorage.js\";\nimport { Exception } from \"./Exception.js\";\n/**\n * Image object to draw\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawImageObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #w;\n    /**\n     * @type {number}\n     */\n    #h;\n    /**\n     * Image sprite key\n     * @type {string}\n     */\n    #key;\n    /**\n     * @type {ImageBitmap}\n     */\n    #image;\n    /**\n     * @type {EventTarget}\n     */\n    #emitter;\n    /**\n     * @type {Map<string, AnimationEventImageObj>}\n     */\n    #animations;\n    /**\n     * @type {number}\n     */\n    #imageIndex;\n    /**\n     * @type {number}\n     */\n    #spacing = 0;\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n    /**\n     * @type {Object | null}\n     */\n    #circleBoundaries;\n    /**\n     * @type {TextureStorage}\n     */\n    #textureStorage;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(mapX, mapY, width, height, key, imageIndex = 0, boundaries, image, spacing = 0) {\n        super(CONST.DRAW_TYPE.IMAGE, mapX, mapY);\n        this.#key = key;\n        this.#emitter = new EventTarget();\n        this.#animations = new Map();\n        this.image = image;\n        this.#imageIndex = imageIndex;\n        this.#spacing = spacing;\n        this.#w = width;\n        this.#h = height;\n        this.#vertices = boundaries && !boundaries.r ? this._convertVerticesArray(boundaries) : boundaries && boundaries.r ? this._calculateConusBoundaries(boundaries.r) : this._calculateRectVertices(width, height);\n        this.#circleBoundaries = boundaries && typeof boundaries.r !== \"undefined\" ? boundaries : null;\n    }\n\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n\n    set width(w) {\n        this.#w = w;\n    }\n\n    set height(h) {\n        this.#h = h;\n    }\n\n    /**\n     * A key should match an image loaded through AssetsManager\n     * @type {string}\n     */\n    get key() {\n        return this.#key;\n    }\n\n    /**\n     * @type {ImageBitmap}\n     */\n    get image() {\n        return this.#image;\n    }\n\n    set image(value) {\n        if (this.#textureStorage) {\n            this.#textureStorage._isTextureRecalculated = true;\n        }\n\n        this.#image = value;\n    }\n\n    /**\n     * Current image index\n     * @type {number}\n     */\n    get imageIndex() {\n        return this.#imageIndex;\n    }\n\n    set imageIndex(value) {\n        this.#imageIndex = value;\n    }\n\n    /**\n     * Image spacing (for tilesets.spacing > 0)\n     * @type {number}\n     */\n    get spacing() {\n        return this.#spacing;\n    }\n\n    /**\n     * Determines if image is animated or not\n     * @type {boolean}\n     */\n    get isAnimations() {\n        return this.#animations.size > 0;\n    }\n\n    /**\n     * @deprecated - use .vertices instead \n     * @type {Array<Array<number>>}\n     */\n    get boundaries() {\n        return this.#vertices;\n    }\n\n    get vertices() {\n        return this.#vertices;\n    }\n\n    get circleBoundaries() {\n        return this.#circleBoundaries;\n    }\n\n    /**\n     * @ignore\n     */\n    _processActiveAnimations() {\n        for (let animationEvent of this.#animations.values()) {\n            if (animationEvent.isActive) {\n                animationEvent.iterateSprite();\n                this.#imageIndex = animationEvent.currentSprite;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    get _textureStorage() {\n        return this.#textureStorage;\n    }\n\n    /**\n     * @ignore\n     */\n    set _textureStorage(texture) {\n        this.#textureStorage = texture;\n    }\n\n    /**\n     * Emit event\n     * @param {string} eventName \n     * @param  {...any} eventParams \n     */\n    emit(eventName, ...eventParams) {\n        const event = new Event(eventName);\n        event.data = [...eventParams];\n        this.#emitter.dispatchEvent(event);\n    }\n\n    /**\n     * Subscribe\n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*} options \n     */\n    addEventListener(eventName, listener, options) {\n        this.#emitter.addEventListener(eventName, listener, options);\n    }\n\n    /**\n     * Unsubscribe\n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*} options \n     */\n    removeEventListener(eventName, listener, options) {\n        this.#emitter.removeEventListener(eventName, listener, options);\n    }\n\n    /**\n     * Adds image animations\n     * @param { string } eventName -animation name\n     * @param { Array<number> } animationSpriteIndexes - animation image indexes\n     * @param { boolean } [isRepeated = false] - animation is cycled or not, cycled animation could be stopped only with stopRepeatedAnimation();\n     * @param { number } [cyclesPerFrame = 1] - determines on how many cycles should one frame be shown, the actual speed depends on gameOptions.render.minCycleTime\n     */\n    addAnimation (eventName, animationSpriteIndexes, isRepeated, cyclesPerFrame = 1) {\n        if (cyclesPerFrame < 1) {\n            Exception(ERROR_CODES.UNEXPECTED_INPUT_PARAMS, \" cyclesPerFrame should be >= 1\");\n        }\n        const animationEvent = new AnimationEventImageObj(eventName, animationSpriteIndexes, isRepeated, cyclesPerFrame);\n        this.#animations.set(eventName, animationEvent);\n        this.addEventListener(eventName, this.#activateAnimation);\n    }\n\n    #activateAnimation = (event) => {\n        const animationEvent = this.#animations.get(event.type);\n        animationEvent.activateAnimation();\n        this.#imageIndex = animationEvent.currentSprite;\n    }; \n\n    /**\n     *\n     * @param {string} eventName - animation name\n     */\n    stopRepeatedAnimation (eventName) {\n        this.#animations.get(eventName).deactivateAnimation();\n    }\n\n    /**\n     * Removes animations\n     */\n    removeAllAnimations() {\n        for (let [eventName, animationEvent] of this.#animations.entries()) {\n            this.removeEventListener(eventName, animationEvent.activateAnimation);\n            animationEvent.deactivateAnimation();\n        }\n        this.#animations.clear();\n        this.#animations = undefined;\n    }\n\n    destroy() {\n        this.removeAllAnimations();\n        super.destroy();\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Line object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawLineObject extends DrawShapeObject {\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(vertices, bgColor) {\n        super(CONST.DRAW_TYPE.LINE, vertices[0][0], vertices[0][1], bgColor);\n        this.#vertices = vertices;\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n}","import { DrawRectObject } from \"./DrawRectObject.js\";\nimport { DrawTextObject } from \"./DrawTextObject.js\";\nimport { DrawConusObject } from \"./DrawConusObject.js\";\nimport { DrawImageObject } from \"./DrawImageObject.js\";\nimport { DrawLineObject } from \"./DrawLineObject.js\";\nimport { DrawPolygonObject } from \"./DrawPolygonObject.js\";\nimport { DrawCircleObject } from \"./DrawCircleObject.js\";\nimport { DrawTiledLayer } from \"./DrawTiledLayer.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { GameStageData } from \"./GameStageData.js\";\n\n/**\n * Creates drawObjects instances.<br>\n * accessible via GameStage.draw <br>\n * Attach images for image objects and tilemaps <br>\n * Adds drawObjects to current GameStage.stageData\n * @see {@link GameStage} a part of GameStage\n */\nexport class DrawObjectFactory {\n    /**\n     * @type {AssetsManager}\n     */\n    #iLoader;\n    /**\n     * @type {GameStageData | null}\n     */\n    #currentPageData;\n    /**\n     * @hideconstructor \n     */\n    constructor(iLoader) {\n        this.#iLoader = iLoader;\n    }\n\n    /**\n     * @returns {GameStageData}\n     */\n    get stageData() {\n        return this.#currentPageData;\n    }\n\n    /**\n     * \n     * @param {*} renderObject \n     * @returns {Object}\n     */\n    #addObjectToPageData(renderObject) {\n        this.#currentPageData._renderObject = renderObject;\n        this.#currentPageData._sortRenderObjectsBySortIndex();\n        return renderObject;\n    }\n    /**\n     * @param {number} x \n     * @param {number} y \n     * @param {number} width \n     * @param {number} height \n     * @param {string} backgroundColor - rgba(r,g,b,a)\n     * @returns {DrawRectObject}\n     */\n    rect(x, y, width, height, backgroundColor) {\n        const renderObject = new DrawRectObject(x, y, width, height, backgroundColor);\n        this.#addObjectToPageData(renderObject);\n        return renderObject; \n    }\n\n    /**\n     * @param {number} x \n     * @param {number} y \n     * @param {string} text \n     * @param {string} font - size fontFamily\n     * @param {string} color - rgba(r,g,b,a)\n     * @returns {DrawTextObject}\n     */\n    text(x, y, text, font, color) {\n        const renderObject = new DrawTextObject(x, y, text, font, color);\n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * \n     * @param {number} radius \n     * @param {string} bgColor - rgba(r,g,b,a)\n     * @param {number=} angle\n     * @param {number=} [fade=0] (0 - 1)\n     * @returns {DrawConusObject}\n     */\n    conus(x, y, radius, bgColor, angle, fade = 0) {\n        const renderObject = new DrawConusObject(x, y, radius, bgColor, angle, fade);\n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * \n     * @param {number} radius \n     * @param {string} bgColor - rgba(r,g,b,a)\n     * @returns {DrawCircleObject}\n     */\n    circle(x, y, radius, bgColor) {\n        const renderObject = new DrawCircleObject(x, y, radius, bgColor);\n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * @param {number} x \n     * @param {number} y \n     * @param {number} width \n     * @param {number} height \n     * @param {string} key \n     * @param {number} [imageIndex = 0]\n     * @param {Array<{x:Number, y:Number}> | {r:number}=} boundaries - boundaries as polygon, or circle\n     * @param {number} [spacing = 0] - for tilesets.spacing > 0\n     * @returns {DrawImageObject}\n     */\n    image(x, y, width, height, key, imageIndex = 0, boundaries, spacing = 0) {\n        const image = this.#iLoader.getImage(key),\n            renderObject = new DrawImageObject(x, y, width, height, key, imageIndex, boundaries, image, spacing);\n            \n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * @param {Array<number>} vertices \n     * @param {string} color - rgba(r,g,b,a)\n     * @returns {DrawLineObject}\n     */\n    line(vertices, color) {\n        const renderObject = new DrawLineObject(vertices, color);\n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * @param {Array<{x:number, y:number}>} vertices - should go in anticlockwise order\n     * @param {string} bgColor - rgba(r,g,b,a)\n     * @returns {DrawPolygonObject}\n     */\n    polygon(vertices, bgColor) {\n        const renderObject = new DrawPolygonObject(vertices, bgColor);\n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * \n     * @param {string} layerKey \n     * @param {string} tileMapKey \n     * @param {boolean=} setBoundaries \n     * @param {DrawShapeObject=} shapeMask \n     * @returns {DrawTiledLayer}\n     */\n    tiledLayer(layerKey, tileMapKey, setBoundaries, shapeMask) {\n        const tilemap = this.#iLoader.getTileMap(tileMapKey),\n            tilesets = tilemap.tilesets,\n            tilesetImages = tilesets.map((tileset) => this.#iLoader.getImage(tileset.data.name)),\n            layerData = tilemap.layers.find((layer) => layer.name === layerKey),\n            renderObject = new DrawTiledLayer(layerKey, tileMapKey, tilemap, tilesets, tilesetImages, layerData, setBoundaries, shapeMask);\n\n        this.#addObjectToPageData(renderObject);\n        return renderObject;\n    }\n\n    /**\n     * @ignore\n     * @param {string} methodKey \n     * @param {Function} createObjectInstance\n     */\n    _registerNewObjectMethod = (methodKey, createObjectInstance) => {\n        this[methodKey] = (...args) => this.#createObjectMonad(createObjectInstance, ...args);\n    };\n\n    /**\n     * @ignore\n     * @param {Function} createInstance\n     * @param {Array<any>} args\n     */\n    #createObjectMonad = (createInstance, ...args) => {\n        const instance = createInstance(...args);\n        this.#addObjectToPageData(instance);\n        return instance;\n    }\n\n    /**\n     * @ignore\n     * @param {GameStageData} pageData;\n     */\n    _attachPageData = (pageData) => {\n        this.#currentPageData = pageData;\n    };\n    /**\n     * @ignore\n     */\n    _detachPageData = () => {\n        this.#currentPageData = null;\n    };\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawPolygonObject extends DrawShapeObject {\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(vertices, bgColor) {\n        super(CONST.DRAW_TYPE.POLYGON, vertices[0].x, vertices[0].y, bgColor);\n        this.#vertices = this._convertVerticesArray(vertices);\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawRectObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #w;\n    /**\n     * @type {number}\n     */\n    #h;\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, w, h, bgColor) {\n        super(CONST.DRAW_TYPE.RECTANGLE, x, y, bgColor);\n        this.#w = w;\n        this.#h = h;\n        this.#vertices = this._calculateRectVertices(w,h);\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n\n    set width(w) {\n        this.#w = w;\n    }\n\n    set height(h) {\n        this.#h = h;\n    }\n}","import { CONST } from \"../constants.js\";\nimport { utils } from \"../index.js\";\n\n/**\n * A base draw object.\n */\nexport class DrawShapeObject {\n    #x;\n    #y;\n    #bg;\n    /**\n     * @type {string}\n     * @enum {CONST.DRAW_TYPE}\n     */\n    #type;\n    /**\n     * Is used for blending pixel arithmetic\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc.\n     * @type {Array<number>}\n     */\n    #blendFunc;\n    \n    /**\n     * @type {number}\n     */\n    #sortIndex = 0;\n    /**\n     * @type {number}\n     */\n    #rotation = 0;\n    /**\n     * @type {number}\n     */\n    #id = utils.generateUniqId();\n    /**\n     * @type {boolean}\n     */\n    #isRemoved = false;\n    /**\n     * @type {undefined | number | null}\n     */\n    #attachedMaskId;\n    /**\n     * @type {boolean}\n     */\n    #isMask;\n    /**\n     * @type {boolean}\n     */\n    #isOffsetTurnedOff = false;\n\n    /**\n     * @type {boolean}\n     */\n    #isChanged = false;\n    /**\n     * @hideconstructor\n     */\n    constructor(type, mapX, mapY, bgColor) {\n        this.#x = mapX;\n        this.#y = mapY;\n        this.#bg = bgColor;\n        this.#type = type;\n    }\n\n    /**\n     * Background color as rgba(r,g,b,a).\n     * @type {string}\n     */\n    get bgColor() {\n        return this.#bg;\n    }\n\n    set bgColor(value) {\n        this.#bg = value;\n    }\n\n    /**\n     * @type {string}\n     * @enum {CONST.DRAW_TYPE}\n     */\n    get type() {\n        return this.#type;\n    }\n\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n\n    /**\n     * @type {number}\n     */\n    get y () {\n        return this.#y;\n    }\n\n    set x(posX) {\n        this.#x = posX;\n    }\n\n    set y(posY) {\n        this.#y = posY;\n    }\n\n    /**\n     * @type {number}\n     */\n    get sortIndex () {\n        return this.#sortIndex;\n    }\n\n    set sortIndex(value) {\n        this.#sortIndex = value;\n    }\n\n    get blendFunc () {\n        return this.#blendFunc;\n    }\n\n    set blendFunc(value) {\n        this.#blendFunc = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n        return this.#rotation;\n    }\n\n    set rotation(value) {\n        this.#rotation = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get id() {\n        return this.#id;\n    }\n\n    /**\n     * @type {boolean}\n     */\n    get isRemoved() {\n        return this.#isRemoved;\n    }\n    /**\n     * Destroy object on next render iteration.\n     */\n    destroy() {\n        this.#isRemoved = true;\n    }\n\n    get isMaskAttached() {\n        return !!this.#attachedMaskId;\n    }\n\n    /**\n     * @ignore\n     */\n    get _maskId() {\n        return this.#attachedMaskId;\n    }\n\n    /**\n     * \n     * @param {DrawShapeObject} mask \n     */\n    setMask(mask) {\n        mask._isMask = true;\n        this.#attachedMaskId = mask.id;\n    }\n\n    removeMask() {\n        this.#attachedMaskId = null;\n    }\n\n    set _isMask(isSet) {\n        this.#isMask = isSet;\n    }\n\n    get _isMask() {\n        return this.#isMask;\n    }\n\n    get isOffsetTurnedOff() {\n        return this.#isOffsetTurnedOff;\n    }\n\n    /**\n     * turn off offset for specific draw object\n     * gameStageData.centerCameraPosition() will take no effect on such object\n     * Can be used for something that should be always on screen: control buttons, overlay masks etc.\n     */\n    turnOffOffset() {\n        this.#isOffsetTurnedOff = true;\n    }\n    /**\n     * @ignore\n     * @param {number} width \n     * @param {number} height \n     * @returns {Array<Array<number>>}\n     */\n    _calculateRectVertices = (width, height) => {\n        const halfW = width/2,\n            halfH = height/2;\n        return [[-halfW, -halfH], [halfW, -halfH], [halfW, halfH], [-halfW, halfH]];\n    };\n\n    /**\n     * @param {number} radius \n     * @param {number} [angle = 2 * Math.PI]\n     * @param {number} [step = Math.PI/12] \n     * @returns {Array<number>}\n     * @ignore\n     */\n    _calculateConusVertices(radius, angle = 2*Math.PI, step = Math.PI/14) {\n        let conusPolygonCoords = [0, 0];\n\n        for (let r = 0; r <= angle; r += step) {\n            let x2 = Math.cos(r) * radius,\n                y2 = Math.sin(r) * radius;\n\n            conusPolygonCoords.push(x2, y2);\n        }\n\n        return conusPolygonCoords;\n    }\n\n    /**\n     * @param {number} radius \n     * @param {number} [angle = 2 * Math.PI]\n     * @param {number} [step = Math.PI/12] \n     * @returns {Array<Array<number>>}\n     * @ignore\n     */\n    _calculateConusBoundaries(radius, angle = 2*Math.PI, step = Math.PI/14) {\n        let conusPolygonCoords = [];\n\n        for (let r = 0; r <= angle; r += step) {\n            let x2 = Math.cos(r) * radius,\n                y2 = Math.sin(r) * radius;\n\n            conusPolygonCoords.push([x2, y2]);\n        }\n\n        return conusPolygonCoords;\n    }\n\n\n    /**\n     * @param {Array<Array<number>> | Array<{x:number, y:number}>} boundaries\n     * @returns {Array<Array<number>>}\n     * @ignore\n     */\n    _convertVerticesArray(boundaries) {\n        if (typeof boundaries[0].x !== \"undefined\" && typeof boundaries[0].y !== \"undefined\") {\n            return utils.verticesArrayToArrayNumbers(boundaries);\n        } else {\n            return boundaries;\n        }\n    }\n}","import { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { Rectangle } from \"./Primitives.js\";\nimport { CONST, ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { TextureStorage } from \"./WebGl/TextureStorage.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawTextObject extends DrawShapeObject {\n    #font;\n    #textAlign;\n    #textBaseline;\n    #fillStyle;\n    #strokeStyle;\n    #text;\n    #textMetrics;\n    /**\n     * @type {HTMLCanvasElement}\n     */\n    #textureCanvas;\n\n    /**\n     * @type {TextureStorage}\n     */\n    #textureStorage;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(mapX, mapY, text, font, fillStyle) {\n        super(CONST.DRAW_TYPE.TEXT, mapX, mapY);\n        this.#text = text;\n        this.#font = font;\n        this.#fillStyle = fillStyle;\n        this.#textMetrics;\n        this.#calculateCanvasTextureAndMeasurements();\n    }\n\n    /**\n     * Rectangle text box.\n     * @type {Rectangle}\n     */\n    get boundariesBox() {\n        const width = this.textMetrics ? this.textMetrics.width : 300,\n            height = this.textMetrics ? this.textMetrics.actualBoundingBoxAscent + /*this.textMetrics.actualBoundingBoxDescent*/ 5: 30;\n        return new Rectangle(this.x, this.y - height, width, height);\n    }\n\n    get vertices() {\n        const bb = this.boundariesBox;\n        return this._calculateRectVertices(bb.width, bb.height);\n    }\n\n    /**\n     * @type {string}\n     */\n    get text() {\n        return this.#text;\n    }\n\n    set text(value) {\n        if (value !== this.#text) {\n            this.#text = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get font() {\n        return this.#font;\n    }\n\n    set font(value) {\n        if (value !== this.#font) {\n            this.#font = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get textAlign() {\n        return this.#textAlign;\n    }\n\n    set textAlign(value) {\n        if (value !== this.#textAlign) {\n            this.#textAlign = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get textBaseline() {\n        return this.#textBaseline;\n    }\n\n    set textBaseline(value) {\n        if (value !== this.#textBaseline) {\n            this.#textBaseline = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get fillStyle() {\n        return this.#fillStyle;\n    }\n\n    set fillStyle(value) {\n        if (value !== this.#fillStyle) {\n            this.#fillStyle = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get strokeStyle() {\n        return this.#strokeStyle;\n    }\n\n    set strokeStyle(value) {\n        if (value !== this.#strokeStyle) {\n            this.#strokeStyle = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {TextMetrics}\n     */\n    get textMetrics() {\n        return this.#textMetrics;\n    }\n\n    /**\n     * @ignore\n     */\n    set _textMetrics(value) {\n        this.#textMetrics = value;\n    }\n\n    /**\n     * @ignore\n     */\n    get _textureStorage() {\n        return this.#textureStorage;\n    }\n\n    /**\n     * @ignore\n     */\n    set _textureStorage(texture) {\n        this.#textureStorage = texture;\n    }\n\n    /**\n     * @ignore\n     */\n    get _textureCanvas() {\n        return this.#textureCanvas;\n    }\n\n    /**\n     * \n     * @returns {void}\n     */\n    #calculateCanvasTextureAndMeasurements() {\n        const canvas = document.createElement(\"canvas\"),\n            ctx = canvas.getContext(\"2d\");\n        if (ctx) { \n            ctx.font = this.font;\n            this._textMetrics = ctx.measureText(this.text);\n            const boxWidth = this.boundariesBox.width, \n                boxHeight = this.boundariesBox.height;\n            ctx.canvas.width = boxWidth;\n            ctx.canvas.height = boxHeight;\n            ctx.font = this.font;\n            ctx.textBaseline = \"bottom\";// bottom\n            if (this.fillStyle) {\n                ctx.fillStyle = this.fillStyle;\n                ctx.fillText(this.text, 0, boxHeight);\n            } \n            if (this.strokeStyle) {\n                ctx.strokeStyle = this.strokeStyle;\n                ctx.strokeText(this.text, 0, boxHeight);\n            }\n            this.#textureCanvas = canvas;\n            if (this.#textureStorage) {\n                this.#textureStorage._isTextureRecalculated = true;\n            }\n        } else {\n            Exception(ERROR_CODES.UNHANDLED_EXCEPTION, \"can't getContext('2d')\");\n        }\n    }\n}","import { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { TextureStorage } from \"./WebGl/TextureStorage.js\";\n/**\n * A render object represents a layer from tiled editor\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawTiledLayer {\n    #layerKey;\n    #tileMapKey;\n    #tilemap;\n    #tilesets;\n    #tilesetImages;\n    /**\n     * @type {Array<TextureStorage>}\n     */\n    #textureStorages;\n    #layerData;\n    #setBoundaries;\n    #drawBoundaries;\n    #attachedMaskId;\n    /**\n     * @type {number}\n     */\n    #sortIndex = 0;\n    #isOffsetTurnedOff;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(layerKey, tileMapKey, tilemap, tilesets, tilesetImages, layerData, setBoundaries = false, shapeMask) {\n        this.#layerKey = layerKey;\n        this.#tileMapKey = tileMapKey;\n        this.#tilemap = tilemap;\n        this.#tilesets = tilesets;\n        this.#textureStorages = [];\n        this.#tilesetImages = tilesetImages;\n        this.#layerData = layerData;\n        this.#setBoundaries = setBoundaries;\n        this.#drawBoundaries = setBoundaries ? setBoundaries : false;\n        if (shapeMask) {\n            this.setMask(shapeMask);\n        }\n    }\n\n    /**\n     * A layer name.\n     * @type {string}\n     */\n    get layerKey() {\n        return this.#layerKey;\n    }\n\n    /**\n     * A tilemap layer key, should match key from the tilemap.\n     * @type {string}\n     */\n    get tileMapKey() {\n        return this.#tileMapKey;\n    }\n\n    get tilemap() {\n        return this.#tilemap;\n    }\n    \n    get tilesets() {\n        return this.#tilesets;\n    }\n\n    get tilesetImages() {\n        return this.#tilesetImages;\n    }\n\n    get layerData() {\n        return this.#layerData;\n    }\n    /**\n     * Should the layer borders used as boundaries, or not\n     * Can be set in GameStage.addRenderLayer() method.\n     * @type {boolean}\n     */\n    get setBoundaries() {\n        return this.#setBoundaries;\n    }\n\n    /**\n     * Should draw a boundaries helper, or not\n     * Can be set in SystemSettings.\n     * @type {boolean}\n     */\n    get drawBoundaries() {\n        return this.#drawBoundaries;\n    }\n\n    set drawBoundaries(value) {\n        this.#drawBoundaries = value;\n    }\n\n    /**\n     * @ignore\n     */\n    get _maskId() {\n        return this.#attachedMaskId;\n    }\n    /**\n     * \n     * @param {DrawShapeObject} mask \n     */\n    setMask(mask) {\n        mask._isMask = true;\n        this.#attachedMaskId = mask.id;\n    }\n\n    removeMask() {\n        this.#attachedMaskId = null;\n    }\n\n    /**\n     * @type {number}\n     */\n    get sortIndex () {\n        return this.#sortIndex;\n    }\n\n    set sortIndex(value) {\n        this.#sortIndex = value;\n    }\n\n    get isOffsetTurnedOff() {\n        return this.#isOffsetTurnedOff;\n    }\n    turnOffOffset() {\n        this.#isOffsetTurnedOff = true;\n    }\n\n    get _textureStorages() {\n        return this.#textureStorages;\n    }\n\n    _setTextureStorage(index, value) {\n        this.#textureStorages[index] = value;\n    }\n}\n","import { CONST, ERROR_CODES } from \"../../constants.js\";\nimport { Exception } from \"../Exception.js\";\n\nexport class SystemEvent extends Event {\n    #data;\n    constructor(eventValue, data){\n        super(eventValue);\n        if (!this.#isEventExist(eventValue)) {\n            Exception(ERROR_CODES.UNEXPECTED_EVENT_NAME, \", Please check if event is exist\");\n        }\n        this.#data = data;\n    }\n\n    #isEventExist(eventValue) {\n        return Object.values(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT).find(eventVal => eventVal === eventValue);\n    }\n\n    get data () {\n        return this.#data;\n    }\n}","export function Exception (code, message) {\n    throw new Error(code + \": \" + message);\n}\n\nexport function Warning (code, message) {\n    console.warn(code, message);\n}","import { CONST, ERROR_CODES, WARNING_CODES } from \"../constants.js\";\nimport { GameStageData } from \"./GameStageData.js\";\nimport { Exception, Warning } from \"./Exception.js\";\nimport AssetsManager from \"../../modules/assetsm/dist/assetsm.min.js\";\nimport { DrawObjectFactory } from \"./DrawObjectFactory.js\";\nimport { DrawCircleObject } from \"./DrawCircleObject.js\";\nimport { DrawConusObject } from \"./DrawConusObject.js\";\nimport { DrawImageObject } from \"./DrawImageObject.js\";\nimport { DrawLineObject } from \"./DrawLineObject.js\";\nimport { DrawPolygonObject } from \"./DrawPolygonObject.js\";\nimport { DrawRectObject } from \"./DrawRectObject.js\";\nimport { DrawTextObject } from \"./DrawTextObject.js\";\nimport { ISystem } from \"./ISystem.js\";\nimport { ISystemAudio } from \"./ISystemAudio.js\";\nimport { SystemSettings } from \"../configs.js\";\nimport { isPointLineIntersect, isPolygonLineIntersect, angle_2points, isCircleLineIntersect } from \"../utils.js\";\nimport { Vector } from \"./Primitives.js\";\n\n/**\n * Represents the stage of the game,<br>\n * Contains pages logic.<br>\n * Instances should be created and registered with System.registerStage() factory method\n * \n * @see {@link System} instances of this class holds by the System class\n * @hideconstructor\n */\nexport class GameStage {\n    /**\n     * @type {string}\n     */\n    #name;\n    /**\n     * @type {boolean}\n     */\n    #isInitiated = false;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {ISystem}\n     */\n    #iSystemReference;\n    /**\n     * @type {GameStageData}\n     */\n    #stageData;\n\n    constructor() {\n        this.#isActive = false;\n        this.#stageData = new GameStageData();\n    }\n\n    /**\n     * Register stage\n     * @param {string} name\n     * @param {ISystem} system \n     * @ignore\n     */\n    _register(name, system) {\n        this.#name = name;\n        this.#iSystemReference = system;\n        this.#setWorldDimensions();\n        this.#setCanvasSize();\n        this.register();\n    }\n\n    /**\n     * Initialization stage\n     * @ignore\n     */\n    _init() {\n        this.init();\n        this.#isInitiated = true;\n    }\n\n    /**\n     * @tutorial stages_lifecycle\n     * Custom logic for register stage\n     */\n    register() {}\n    /**\n     * @tutorial stages_lifecycle\n     * Custom logic for init stage\n     */\n    init() {}\n    /**\n     * Custom logic for start stage\n     * @param {Object=} options\n     */\n    start(options) {}\n    /**\n     * @tutorial stages_lifecycle\n     * Custom logic for stop stage\n     */\n    stop() {}\n    /**\n     * Custom logic for resize stage\n     */\n    resize() {}\n\n    /**\n     * @tutorial assets_manager\n     * @type {AssetsManager}\n     */\n    get iLoader() {\n        return this.#iSystemReference.iLoader;\n    }\n\n    /**\n     * @type {DrawObjectFactory}\n     */\n    get draw() {\n        return this.#iSystemReference.drawObjectFactory;\n    }\n\n    /**\n     * Attach all canvas elements from the #views to container\n     * @param {HTMLElement} container\n     * @ignore\n     */\n    _attachCanvasToContainer(container) {\n        this.#attachElementToContainer(this.canvasHtmlElement, container);\n    }\n\n    /**\n     * Add render object to the stageData\n     * @param { DrawConusObject | DrawImageObject | \n     *          DrawLineObject | DrawPolygonObject | \n     *          DrawRectObject | DrawCircleObject | \n     *          DrawTextObject } renderObject \n     */\n    addRenderObject = (renderObject) => {\n        const data = this.stageData,\n            isDataAlreadyAdded = data.renderObjects.indexOf(renderObject) !== -1;\n        if (isDataAlreadyAdded) {\n            Warning(WARNING_CODES.NEW_BEHAVIOR_INTRODUCED, \"stage.draw methods add objects to pageData, no need to call addRenderObject\");\n        } else {\n            data._renderObject = renderObject;\n            data._sortRenderObjectsBySortIndex(); \n        }\n    };\n\n    /**\n     * Determines if this stage render is Active or not\n     * @type {boolean}\n     */\n    get isActive() {\n        return this.#isActive;\n    }\n\n    /**\n     * Determines if this stage is initialized or not\n     * @type {boolean}\n     */\n    get isInitiated() {\n        return this.#isInitiated;\n    }\n\n    /**\n     * Current stage name\n     * @type {string}\n     */\n    get name () {\n        return this.#name;\n    }\n\n    /**\n     * @type {GameStageData}\n     */\n    get stageData() {\n        return this.#stageData;\n    }\n\n    /**\n     * @type {SystemSettings}\n     */\n    get systemSettings() {\n        return this.#iSystemReference.systemSettings;\n    }\n\n    /**\n     * @type {ISystemAudio}\n     */\n    get audio() {\n        return this.#iSystemReference.audio;\n    }\n\n    /**\n     * @type {ISystem}\n     */\n    get iSystem() {\n        return this.#iSystemReference;\n    }\n\n    get canvasHtmlElement() {\n        return document.getElementsByTagName(\"canvas\")[0];\n    }\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    addEventListener = (eventName, listener, options) => {\n        this.iSystem.addEventListener(eventName, listener, options);\n    };\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    removeEventListener = (eventName, listener, options) => {\n        this.iSystem.removeEventListener(eventName, listener, options);\n    };\n\n    /**\n     * Start stage render\n     * @param {Object=} options \n     * @ignore\n     */\n    _start(options) {\n        this.start(options);\n        this.#isActive = true;\n        window.addEventListener(\"resize\", this._resize);\n        this._resize();\n    }\n\n    /**\n     * Stop stage render\n     * @ignore\n     */\n    _stop() {\n        this.#isActive = false;\n        window.removeEventListener(\"resize\", this._resize);\n        this.stop();\n    }\n\n    /**\n     * Resize event\n     * @ignore\n     */\n    _resize = () => {\n        this.#setCanvasSize();\n        this.resize();\n    };\n\n    /**\n     * \n     * @param {HTMLCanvasElement} htmlElement \n     * @param {HTMLElement} container \n     */\n    #attachElementToContainer(htmlElement, container) {\n        container.appendChild(htmlElement);\n    }\n\n    #setWorldDimensions() {\n        const width = this.systemSettings.worldSize ? this.systemSettings.worldSize.width : 0,\n            height = this.systemSettings.worldSize ? this.systemSettings.worldSize.height : 0;\n            \n        this.stageData._setWorldDimensions(width, height);\n    }\n\n    //////////////////////////////////////////////////////\n    //***************************************************/\n    //****************** Collisions ********************//\n    //**************************************************//\n    //////////////////////////////////////////////////////\n\n    /**\n     * \n     * @param {number} x \n     * @param {number} y \n     * @param {DrawImageObject} drawObject \n     * @returns {{x:number, y:number, p:number} | boolean}\n     */\n    isBoundariesCollision = (x, y, drawObject) => {\n        const drawObjectType = drawObject.type,\n            vertices = drawObject.vertices,\n            circleBoundaries = drawObject.circleBoundaries;\n        switch(drawObjectType) {\n        case CONST.DRAW_TYPE.TEXT:\n        case CONST.DRAW_TYPE.RECTANGLE:\n        case CONST.DRAW_TYPE.CONUS:\n        case CONST.DRAW_TYPE.IMAGE:\n            if (!circleBoundaries) {\n                return this.#isPolygonToBoundariesCollision(x, y, vertices, drawObject.rotation);\n            } else {\n                return this.#isCircleToBoundariesCollision(x, y, drawObject.circleBoundaries.r);\n            }\n        case CONST.DRAW_TYPE.CIRCLE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\n            break;\n        case CONST.DRAW_TYPE.LINE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\n            break;\n        default:\n            Warning(CONST.WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\n        }\n        return false;\n    };\n\n    /**\n     * \n     * @param {number} x \n     * @param {number} y \n     * @param {DrawImageObject} drawObject\n     * @param {Array<DrawImageObject>} objects - objects array to check\n     * @returns {{x:number, y:number, p:number} | boolean} - the closest collision\n     */\n    isObjectsCollision = (x, y, drawObject, objects) => {\n        const drawObjectType = drawObject.type,\n            drawObjectBoundaries = drawObject.vertices,\n            circleBoundaries = drawObject.circleBoundaries;\n        switch(drawObjectType) {\n        case CONST.DRAW_TYPE.TEXT:\n        case CONST.DRAW_TYPE.RECTANGLE:\n        case CONST.DRAW_TYPE.CONUS:\n        case CONST.DRAW_TYPE.IMAGE:\n            if (!circleBoundaries) {\n                return this.#isPolygonToObjectsCollision(x, y, drawObjectBoundaries, drawObject.rotation, objects);\n            } else {\n                return this.#isCircleToObjectsCollision(x, y, circleBoundaries, objects);\n            }\n        case CONST.DRAW_TYPE.CIRCLE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\n            break;\n        case CONST.DRAW_TYPE.LINE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\n            break;\n        default:\n            Warning(CONST.WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\n        }\n        return false;\n    };\n    #isPolygonToObjectsCollision(x, y, polygonVertices, polygonRotation, objects) {\n        const len = objects.length;\n\n        let collisions = [];\n        for (let i = 0; i < len; i++) {\n            const mapObject = objects[i],\n                drawMapObjectType = mapObject.type;\n\n            let coll;\n            \n            switch(drawMapObjectType) {\n            case CONST.DRAW_TYPE.TEXT:\n            case CONST.DRAW_TYPE.RECTANGLE:\n            case CONST.DRAW_TYPE.CONUS:\n            case CONST.DRAW_TYPE.IMAGE:\n                coll = this.#isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject);\n                break;\n            case CONST.DRAW_TYPE.CIRCLE:\n                console.warn(\"isObjectCollision.circle check is not implemented yet!\");\n                break;\n            case CONST.DRAW_TYPE.LINE:\n                console.warn(\"isObjectCollision.line check is not implemented, please use rect instead\");\n                break;\n            default:\n                console.warn(\"unknown object type!\");\n            }\n            if (coll) {\n                collisions.push(coll);\n            }\n        }\n        if (collisions.length > 0) {\n            return this.#takeTheClosestCollision(collisions);\n        } else {\n            return null;\n        }\n    }\n\n    #isCircleToObjectsCollision(x, y, drawObjectBoundaries, objects) {\n        const radius = drawObjectBoundaries.r;\n\n        const len = objects.length;\n\n        let collisions = [];\n        for (let i = 0; i < len; i++) {\n            const mapObject = objects[i],\n                drawMapObjectType = mapObject.type,\n                circleBoundaries = mapObject.circleBoundaries;\n\n            let coll;\n            \n            switch(drawMapObjectType) {\n            case CONST.DRAW_TYPE.TEXT:\n            case CONST.DRAW_TYPE.RECTANGLE:\n            case CONST.DRAW_TYPE.CONUS:\n            case CONST.DRAW_TYPE.IMAGE:\n                if (!circleBoundaries) {\n                    coll = this.#isCircleToPolygonCollision(x, y, radius, mapObject);\n                } else {\n                    coll = this.#isCircleToCircleCollision(x, y, radius, mapObject.x, mapObject.y, circleBoundaries.r);\n                }\n                break;\n            case CONST.DRAW_TYPE.CIRCLE:\n                console.warn(\"isObjectCollision.circle check is not implemented yet!\");\n                break;\n            case CONST.DRAW_TYPE.LINE:\n                console.warn(\"isObjectCollision.line check is not implemented, please use rect instead\");\n                break;\n            default:\n                console.warn(\"unknown object type!\");\n            }\n            if (coll) {\n                collisions.push(coll);\n            }\n        }\n        if (collisions.length > 0) {\n            return this.#takeTheClosestCollision(collisions);\n        } else {\n            return null;\n        }\n    }\n \n    #takeTheClosestCollision(collisions) {\n        return collisions.sort((a,b) => a.p < b.p)[0];\n    }\n\n    #isCircleToPolygonCollision(x, y, radius, mapObject) {\n        const [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\n            xWithOffset = x - mapOffsetX,\n            yWithOffset = y - mapOffsetY,\n            mapObjXWithOffset = mapObject.x - mapOffsetX,\n            mapObjYWithOffset = mapObject.y - mapOffsetY,\n            mapObjVertices = mapObject.vertices, \n            mapObjRotation = mapObject.rotation,\n            len = mapObjVertices.length;\n        //console.log(\"map object check:\");\n        //console.log(mapObject);\n        for (let i = 0; i < len; i+=1) {\n            const mapObjFirstVertex = mapObjVertices[i];\n            let mapObjNextVertex = mapObjVertices[i + 1];\n            if (!mapObjNextVertex) {\n                mapObjNextVertex = mapObjVertices[0];\n            }\n            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\n                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\n                edge = {\n                    x1: vertex[0],\n                    y1: vertex[1],\n                    x2: nextVertex[0],\n                    y2: nextVertex[1]\n                },\n                intersect = isCircleLineIntersect(xWithOffset, yWithOffset, radius, edge);\n            if (intersect) {\n            //console.log(\"polygon: \", polygonWithOffsetAndRotation);\n            //console.log(\"intersect: \", intersect);\n                return intersect;\n            }\n        }\n        return false;\n    }\n\n    #isCircleToCircleCollision(circle1X, circle1Y, circle1R, circle2X, circle2Y, circle2R) {\n        const len = new Vector(circle1X, circle1Y, circle2X, circle2Y).length;\n        console.log(len);\n        console.log(circle1R);\n        console.log(circle2R);\n        if ((len - (circle1R + circle2R)) > 0) {\n            return false;\n        } else {\n            //@todo calculate point of intersect\n            return true;\n        }\n    }\n\n    #isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject) {\n        const [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\n            xWithOffset = x - mapOffsetX,\n            yWithOffset = y - mapOffsetY,\n            mapObjXWithOffset = mapObject.x - mapOffsetX,\n            mapObjYWithOffset = mapObject.y - mapOffsetY,\n            mapObjVertices = mapObject.vertices, \n            mapObjRotation = mapObject.rotation,\n            polygonWithOffsetAndRotation = polygonVertices.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, polygonRotation))),\n            len = mapObjVertices.length;\n        //console.log(\"map object check:\");\n        //console.log(mapObject);\n        for (let i = 0; i < len; i+=1) {\n            const mapObjFirstVertex = mapObjVertices[i];\n            let mapObjNextVertex = mapObjVertices[i + 1];\n            if (!mapObjNextVertex) {\n                mapObjNextVertex = mapObjVertices[0];\n            }\n            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\n                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\n                edge = {\n                    x1: vertex[0],\n                    y1: vertex[1],\n                    x2: nextVertex[0],\n                    y2: nextVertex[1]\n                },\n                intersect = isPolygonLineIntersect(polygonWithOffsetAndRotation, edge);\n            if (intersect) {\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\n                //console.log(\"intersect: \", intersect);\n                return intersect;\n            }\n        }\n        return false;\n    }\n\n    #calculateShiftedVertexPos(vertex, centerX, centerY, rotation) {\n        const vector = new Vector(0, 0, vertex[0], vertex[1]),\n            vertexAngle = angle_2points(0, 0, vertex[0], vertex[1]),\n            len = vector.length;\n            \n        const newX = centerX + (len * Math.cos(rotation + vertexAngle)),\n            newY = centerY + (len * Math.sin(rotation + vertexAngle));\n        return [newX, newY];\n    }\n    #isCircleToBoundariesCollision(x, y, r) {\n        const mapObjects = this.stageData.getBoundaries(),\n            [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\n            xWithOffset = x - mapOffsetX,\n            yWithOffset = y - mapOffsetY,\n            len = mapObjects.length;\n\n        for (let i = 0; i < len; i+=1) {\n            const item = mapObjects[i];\n            const object = {\n                    x1: item[0],\n                    y1: item[1],\n                    x2: item[2],\n                    y2: item[3]\n                },\n                intersect = isCircleLineIntersect(xWithOffset, yWithOffset, r, object);\n            if (intersect) {\n                //console.log(\"rotation: \", rotation);\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\n                //console.log(\"intersect: \", intersect);\n                return intersect;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {Array<Array<number>>} polygon\n     * @param {number} rotation \n     * @returns {{x:number, y:number, p:number} | boolean}\n     */\n    #isPolygonToBoundariesCollision(x, y, polygon, rotation) {\n        const mapObjects = this.stageData.getBoundaries(),\n            [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\n            xWithOffset = x - mapOffsetX,\n            yWithOffset = y - mapOffsetY,\n            polygonWithOffsetAndRotation = polygon.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, rotation))),\n            len = mapObjects.length;\n\n        for (let i = 0; i < len; i+=1) {\n            const item = mapObjects[i];\n            const object = {\n                    x1: item[0],\n                    y1: item[1],\n                    x2: item[2],\n                    y2: item[3]\n                },\n                intersect = isPolygonLineIntersect(polygonWithOffsetAndRotation, object);\n            if (intersect) {\n                //console.log(\"rotation: \", rotation);\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\n                //console.log(\"intersect: \", intersect);\n                return intersect;\n            }\n        }\n        return false;\n    }\n    //****************** End Collisions ****************//\n\n    #setCanvasSize() {\n        const canvasWidth = this.systemSettings.canvasMaxSize.width && (this.systemSettings.canvasMaxSize.width < window.innerWidth) ? this.systemSettings.canvasMaxSize.width : window.innerWidth,\n            canvasHeight = this.systemSettings.canvasMaxSize.height && (this.systemSettings.canvasMaxSize.height < window.innerHeight) ? this.systemSettings.canvasMaxSize.height : window.innerHeight;\n        this.stageData._setCanvasDimensions(canvasWidth, canvasHeight);\n    }\n}","import { WARNING_CODES } from \"../constants.js\";\nimport { Warning } from \"./Exception.js\";\n/**\n * A storage for stage data, such as gameObjects,\n * boundaries, worldDimensions and offset\n * @see {@link GameStage} a part of GameStage\n * @hideconstructor\n */\nexport class GameStageData {\n    #worldWidth;\n    #worldHeight;\n    #viewWidth;\n    #viewHeight;\n    #xOffset = 0;\n    #yOffset = 0;\n    #centerX = 0;\n    #centerY = 0;\n    #rotate = 0;\n    /**\n     * current screen boundaries, recalculated every render cycles\n     * @type {Array<Array<number>>}\n     */\n    #boundaries = [];\n\n    /**\n     * whole world boundaries, calculated once on prepare stage\n     * @type {Array<Array<number>>}\n     */\n    #wholeWorldBoundaries = [];\n    /**\n     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer>}\n     */\n    #renderObjects = [];\n    \n    /**\n     * @type {boolean}\n     */\n    #isOffsetTurnedOff;\n    /**\n     * @deprecated\n     * @type {boolean}\n     */\n    #isWorldBoundariesEnabled = false;\n\n    /**\n     * \n     * @returns {boolean}\n     */\n    isOffsetTurnedOff() {\n        return this.#isOffsetTurnedOff;\n    }\n    set mapRotate(value) {\n        this.#rotate = value;\n    }\n\n    /**\n     * Add a Boundaries line\n     * @param {{x1:number,y1:number,x2:number, y2:number}} boundaries \n     */\n    #addBoundaries(boundaries) {\n        this.#boundaries.push([boundaries.x1, boundaries.y1, boundaries.x2, boundaries.y2]);\n    }\n\n    /**\n     * Add array of boundaries lines\n     * @param {Array<Array<number>>} boundaries \n     * @ignore\n     */\n    _addBoundariesArray(boundaries) {\n        this.#boundaries.push(...boundaries);\n    }\n\n    /**\n     * Clear map boundaries\n     * @ignore\n     */\n    _clearBoundaries() {\n        this.#boundaries = [];\n    }\n\n    /**\n     * \n     * @param {number} width \n     * @param {number} height \n     * @ignore\n     */\n    _setWorldDimensions(width, height) {\n        this.#worldWidth = width;\n        this.#worldHeight = height;\n    }\n\n    /**\n     * \n     * @param {number} width \n     * @param {number} height \n     * @ignore\n     */\n    _setCanvasDimensions(width, height) {\n        this.#viewWidth = width;\n        this.#viewHeight = height;\n    }\n\n    /**\n     * Set map borders\n     * @ignore\n     */\n    _setMapBoundaries() {\n        const [w, h] = [this.#worldWidth, this.#worldHeight],\n            [offsetX, offsetY] = [this.#xOffset, this.#yOffset],\n            wOffset = w - offsetX,\n            hOffset = h -offsetY;\n        if (!w || !h) {\n            Warning(WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map boundaries.\");\n        }\n        this.#addBoundaries({x1: 0, y1: 0, x2: wOffset, y2: 0});\n        this.#addBoundaries({x1: wOffset, y1: 0, x2: wOffset, y2: hOffset});\n        this.#addBoundaries({x1: wOffset, y1: hOffset, x2: 0, y2: hOffset});\n        this.#addBoundaries({x1: 0, y1: hOffset, x2: 0, y2: 0});\n    }\n\n    /**\n     * @ignore\n     */\n    _setWholeWorldMapBoundaries() {\n        const [w, h] = [this.#worldWidth, this.#worldHeight];\n        if (!w || !h) {\n            Warning(WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map boundaries.\");\n        }\n        this.#wholeWorldBoundaries.push([0, 0, w, 0]);\n        this.#wholeWorldBoundaries.push([w, 0, w, h]);\n        this.#wholeWorldBoundaries.push([w, h, 0, h]);\n        this.#wholeWorldBoundaries.push([0, h, 0, 0]);\n    }\n\n    /**\n     * Merge same boundaries\n     * @ignore\n     */\n    _mergeBoundaries(isWholeMapBoundaries = false) {\n        const boundaries = isWholeMapBoundaries ? this.getWholeWorldBoundaries() : this.getBoundaries(),\n            boundariesSet = new Set(boundaries);\n        for (const line of boundariesSet.values()) {\n            const lineX1 = line[0],\n                lineY1 = line[1],\n                lineX2 = line[2],\n                lineY2 = line[3];\n            for (const line2 of boundariesSet.values()) {\n                const line2X1 = line2[0],\n                    line2Y1 = line2[1],\n                    line2X2 = line2[2],\n                    line2Y2 = line2[3];\n                if (lineX1 === line2X2 && lineY1 === line2Y2 &&\n                    lineX2 === line2X1 && lineY2 === line2Y1) {\n                    //remove double lines\n                    boundariesSet.delete(line);\n                    boundariesSet.delete(line2);\n                }\n                if (lineX2 === line2X1 && lineY2 === line2Y1 && (lineX1 === line2X2 || lineY1 === line2Y2)) {\n                    //merge lines\n                    line2[0] = lineX1;\n                    line2[1] = lineY1;\n                    boundariesSet.delete(line);\n                }\n            }\n        }\n\n        if (isWholeMapBoundaries) {\n            this.#boundaries = Array.from(boundariesSet);\n        } else {\n            this.#wholeWorldBoundaries = Array.from(boundariesSet);\n        }\n        boundariesSet.clear();\n    }\n\n    /**\n     * @ignore\n     * @param {Array<Array<number>>} boundaries \n     */\n    _setWholeMapBoundaries(boundaries) {\n        this.#wholeWorldBoundaries.push(...boundaries);\n    }\n\n    /**\n     * @deprecated\n     * @ignore\n     */\n    _enableMapBoundaries() {\n        this.#isWorldBoundariesEnabled = true;\n    }\n\n    /**\n     * \n     * @returns {Array<Array<number>>}\n     */\n    getBoundaries() {\n        return this.#boundaries;\n    }\n\n    getWholeWorldBoundaries() {\n        return this.#wholeWorldBoundaries;\n    }\n\n    /**\n     * @deprecated\n     */\n    get isWorldBoundariesEnabled() {\n        return this.#isWorldBoundariesEnabled;\n    }\n    /**\n     * @type {Array<number>}\n     */\n    get canvasDimensions() {\n        return [this.#viewWidth, this.#viewHeight];\n    }\n\n    /**\n     * @type {Array<number>}\n     */\n    get worldDimensions() {\n        return [this.#worldWidth, this.#worldHeight];\n    }\n    \n    /**\n     * @type {Array<number>}\n     */\n    get worldOffset() {\n        return [this.#xOffset, this.#yOffset];\n    }\n\n    /**\n     * @type {Array<number>}\n     */\n    get mapCenter() {\n        return [this.#centerX, this.#centerY];\n    }\n\n    /**\n     * @type {number}\n     */\n    get mapRotate() {\n        return this.#rotate;\n    }\n\n    /**\n     * @method\n     * @param {number} x \n     * @param {number} y \n     */\n    centerCameraPosition = (x, y) => {\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\n            [mapWidth, mapHeight] = this.worldDimensions,\n            halfScreenWidth = canvasWidth/2,\n            halfScreenHeight = canvasHeight/2,\n            currentCenterX = halfScreenWidth - mapOffsetX,\n            currentCenterY = halfScreenHeight - mapOffsetY;\n        if (currentCenterX < x) {\n            if (x < mapWidth - halfScreenWidth) {\n                const newXOffset = x - halfScreenWidth;\n                if (newXOffset >= 0)\n                    this.#xOffset = Math.round(newXOffset);\n            } else if (mapWidth > canvasWidth) {\n                const newXOffset = mapWidth - canvasWidth;\n                this.#xOffset = Math.round(newXOffset);\n            }\n        }\n        if (currentCenterY < y) {\n            if (y < mapHeight - halfScreenHeight) {\n                const newYOffset = y - halfScreenHeight;\n                if (newYOffset >= 0)\n                    this.#yOffset = Math.round(newYOffset);\n            } else if (mapHeight > canvasHeight) {\n                const newYOffset = mapHeight - canvasHeight;\n                this.#yOffset = Math.round(newYOffset);\n            }\n        }\n\n        this.#centerX = x;\n        this.#centerY = y;\n        //Logger.debug(\"center camera position, offset: \", this.worldOffset);\n        //Logger.debug(\"center: \", this.mapCenter);   \n    };\n\n    personRotatedCenterCamera = (x, y, rotationAngle) => {\n        console.log(\"new centering algorithm\");\n        /*\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\n            [mapWidth, mapHeight] = this.worldDimensions,\n            halfScreenWidth = canvasWidth/2,\n            halfScreenHeight = canvasHeight/2,\n            currentCenterX = halfScreenWidth - mapOffsetX,\n            currentCenterY = halfScreenHeight - mapOffsetY;\n        if (currentCenterX < x) {\n            if (x < mapWidth - halfScreenWidth) {\n                const newXOffset = x - halfScreenWidth;\n                if (newXOffset >= 0)\n                    this.#xOffset = Math.round(newXOffset);\n            } else if (mapWidth > canvasWidth) {\n                const newXOffset = mapWidth - canvasWidth;\n                this.#xOffset = Math.round(newXOffset);\n            }\n        }\n        if (currentCenterY < y) {\n            if (y < mapHeight - halfScreenHeight) {\n                const newYOffset = y - halfScreenHeight;\n                if (newYOffset >= 0)\n                    this.#yOffset = Math.round(newYOffset);\n            } else if (mapHeight > canvasHeight) {\n                const newYOffset = mapHeight - canvasHeight;\n                this.#yOffset = Math.round(newYOffset);\n            }\n        }\n\n        this.#centerX = x;\n        this.#centerY = y;\n        Logger.debug(\"center camera position, offset: \", this.worldOffset);\n        Logger.debug(\"center: \", this.mapCenter);   \n        */\n    };\n\n    /**\n     * a getter to retrieve all attached renderObjects\n     */\n    get renderObjects() {\n        return this.#renderObjects;\n    }\n\n    /**\n     * Retrieve specific objects instances\n     * @param {Object} instance - drawObjectInstance to retrieve \n     * @returns {Array<Object>}\n     */\n    getObjectsByInstance(instance) {\n        return this.#renderObjects.filter((object) => object instanceof instance);\n    }\n\n    /**\n     * @ignore\n     */\n    _sortRenderObjectsBySortIndex() {\n        this.#renderObjects = this.#renderObjects.sort((obj1, obj2) => obj1.sortIndex - obj2.sortIndex);\n    }\n\n    /**\n     * @ignore\n     */\n    set _renderObject(object) {\n        this.#renderObjects.push(object);\n    } \n\n    /**\n     * @ignore\n     */\n    set _renderObjects(objects) {\n        this.#renderObjects = objects;\n    } \n}","import { ISystem } from \"./ISystem.js\";\n\n/**\n * Class for creating modules\n * Accessed via ISystem.extensionInterface\n */\nexport class IExtension {\n    /**\n     * @type {ISystem}\n     */\n    #systemReference;\n    /**\n     * @hideconstructor\n     */\n    constructor(iSystem) {\n        this.#systemReference = iSystem;\n    }\n    /**\n     * Is used for registering new Object in DrawObjectFactory, \\\n     * registered method could be then called with this.draw[createInstanceKey]\n     * @param {string} createInstanceKey - a key for calling method from DrawObjectFactory\n     * @param {function} createInstanceMethod - method \n     */\n    registerDrawObject(createInstanceKey, createInstanceMethod) {\n        this.#systemReference.drawObjectFactory._registerNewObjectMethod(createInstanceKey, createInstanceMethod);\n    }\n\n    /**\n     * Used to register a new draw program\n     * @param {string} programName\n     * @param {string} vertexShader - raw vertex shader program\n     * @param {string} fragmentShader - raw fragment shader program \n     * @param {Array<string>} uVars - program uniform variables names\n     * @param {Array<string>} aVars - program attribute variables names\n     * @returns {Promise<void>}\n     */\n    registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {\n        return this.#systemReference.iRender._registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars);\n    }\n\n    /**\n     * Inject method to render.init stage. Should be Promise based.\n     * @param {function():Promise<void>} method \n     * @returns {void}\n     */\n    registerRenderInit(method) {\n        this.#systemReference.iRender._registerRenderInit(method);\n    }\n\n    /**\n     * Register render method for class.\n     * @param {string} objectClassName - object name registered to DrawObjectFactory\n     * @param {function(renderObject, gl, pageData, program, vars):Promise<any[]>} objectRenderMethod - should be promise based returns vertices number and draw program\n     * @param {string=} objectWebGlDrawProgram - a webgl program name previously registered with iExtension.registerAndCompileWebGlProgram()\n     */\n    registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram) {\n        this.#systemReference.iRender._registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram);\n    }\n}","import { CONST, ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { Logger } from \"./Logger.js\";\nimport { SystemEvent } from \"./Events/SystemEvent.js\";\n\n/**\n * Represents Socket connection\n */\nexport class INetwork extends EventTarget {\n    #systemSettings;\n    #socket;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(systemSettings) {\n        super();\n        if (!systemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\n        }\n        this.#systemSettings = systemSettings;\n    }\n\n    init() {\n        import(\"socket.io-client\").then((module) => {\n            this.#socket = module.io(this.#systemSettings.network.address, {withCredentials: true});\n            \n            this.#registerSocketListeners();\n        });\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get isServerConnected () {\n        if (this.#socket && this.#socket.connected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    get playerId() {\n        return this.#socket.id;\n    }\n\n    sendGatherRoomsInfo() {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.ROOMS_INFO_REQUEST);\n    }\n\n    sendCreateOrJoinRoom(roomName, map) {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CREATE_OR_JOIN, roomName , map);\n    }\n\n    sendMessage(message) {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CLIENT_MESSAGE, message);\n    }\n\n    #onConnect = () => {\n        Logger.debug(\"connected, socket id: \" + this.#socket.id);\n        this.dispatchEvent(new Event(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onDisconnect = (reason) => {\n        Logger.debug(\"server disconnected, reason: \" + reason);\n        this.dispatchEvent(new Event(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onData = (event) => {\n        console.warn(\"server data: \", event);\n    };\n\n    #onMessage = (message) => {\n        Logger.debug(\"received new message from server: \" + message);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.SERVER_MESSAGE, message));\n    };\n\n    #onRoomsInfo = (rooms) => {\n        Logger.debug(\"received roomsInfo \" + rooms);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.ROOMS_INFO, rooms));\n    };\n\n    #onCreateNewRoom = (room, map) => {\n        Logger.debug(\"CLIENT SOCKET: Created room  \" + room);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CREATED, {room, map}));\n    };\n\n    #onRoomIsFull = (room) => {\n        Logger.debug(\"CLIENT SOCKET: Room is full, can't join: \" + room);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.FULL, {room}));\n    };\n\n    #onJoinedToRoom = (room, map) => {\n        Logger.debug(\"CLIENT SOCKET: Joined to room: \" + room, \", map: \", map);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.JOINED, {room, map}));\n    };\n\n    #onUnjoinedFromRoom = (playerId) => {\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.DISCONNECTED, {playerId}));\n    };\n\n    #registerSocketListeners() {\n        this.#socket.on(\"connect\", this.#onConnect);\n        this.#socket.on(\"disconnect\", this.#onDisconnect);\n        this.#socket.on(\"data\", this.#onData);\n\n        this.#socket.on(\"roomsInfo\", this.#onRoomsInfo);\n    \n        this.#socket.on(\"created\", this.#onCreateNewRoom);\n    \n        this.#socket.on(\"full\", this.#onRoomIsFull);\n    \n        this.#socket.on(\"joined\", this.#onJoinedToRoom);\n    \n        this.#socket.on(\"log\", function(array) {\n            console.log.apply(console, array);\n        });\n    \n        this.#socket.on(\"message\", this.#onMessage);\n    \n        this.#socket.on(\"removed\", function(message) {\n            console.log(\"removed message\");\n            console.log(message);\n        });\n\n        this.#socket.on(\"disconnected\", this.#onUnjoinedFromRoom);\n\n        addEventListener(\"beforeunload\", this.#disconnect);\n    }\n\n    #disconnect = () => {\n        this.#socket.disconnect();\n    };\n}","import { DrawTiledLayer } from \"./DrawTiledLayer.js\";\nimport { Exception, Warning } from \"./Exception.js\";\nimport { ERROR_CODES, WARNING_CODES } from \"../constants.js\";\nimport { WebGlEngine } from \"./WebGl/WebGlEngine.js\";\nimport { SystemSettings } from \"../configs.js\";\nimport { GameStageData } from \"./GameStageData.js\";\nimport AssetsManager from \"../../modules/assetsm/dist/assetsm.min.js\";\n//import { calculateBufferData } from \"../wa/release.js\";\nimport { CONST } from \"../constants.js\";\nimport { DrawImageObject } from \"./DrawImageObject.js\";\nimport { DrawCircleObject } from \"./DrawCircleObject.js\";\nimport { DrawConusObject } from \"./DrawConusObject.js\";\nimport { DrawLineObject } from \"./DrawLineObject.js\";\nimport { DrawPolygonObject } from \"./DrawPolygonObject.js\";\nimport { DrawRectObject } from \"./DrawRectObject.js\";\nimport { DrawTextObject } from \"./DrawTextObject.js\";\nimport { imgVertexShader, imgFragmentShader, imgUniforms, imgAttributes } from \"./WebGl/ImagesDrawProgram.js\";\nimport { primitivesVertexShader, primitivesFragmentShader, primitivesUniforms, primitivesAttributes } from \"./WebGl/PrimitivesDrawProgram.js\";\n\n/**\n * IRender class controls the render(start/stop/speed) \n * And drawObjects(animations, removing, and rendering)\n * @see {@link GameStage} a part of GameStage\n * @hideconstructor\n */\nexport class IRender {\n    /**\n     * @type {HTMLCanvasElement}\n     */\n    #canvas;\n    /**\n     * @type {WebGLRenderingContext}\n     */\n    #drawContext;\n    /**\n     * @type {boolean}\n     */\n    #isCleared;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {WebGlEngine}\n     */\n    #webGlEngine;\n    /**\n     * @type {GameStageData | null}\n     */\n    #currentGameStageData;\n\n    /**\n     * ISystem.systemSettings\n     * @type {SystemSettings}\n     */\n    #systemSettingsReference;\n    /**\n     * A reference to the systemInterface.iLoader\n     * @type {AssetsManager}\n     */\n    #loaderReference;\n    /**\n     * @type {Array<number>}\n     */\n    #tempFPStime;\n    /**\n     * @type {NodeJS.Timer | null}\n     */\n    #fpsAverageCountTimer;\n    /**\n     * @type {boolean}\n     */\n    #isBoundariesPrecalculations = false;\n    #minCycleTime;\n    /**\n     * @type {EventTarget}\n     */\n    #emitter = new EventTarget();\n    #bindRenderLayerMethod;\n    #registeredRenderObjects = new Map();\n\n    /**\n     * @type {Array<function():Promise<void>>}\n     */\n    #initPromises = [];\n    constructor(systemSettings, iLoader, canvasContainer) {\n        this.#isCleared = false;\n        this.#canvas = document.createElement(\"canvas\");\n        canvasContainer.appendChild(this.#canvas);\n        this.#drawContext = this.#canvas.getContext(\"webgl\", {stencil: true});\n\n        this.#systemSettingsReference = systemSettings;\n        this.#loaderReference = iLoader;\n\n        this.#tempFPStime = [];\n        this.#minCycleTime = this.systemSettings.gameOptions.render.minCycleTime;\n\n        this.#isBoundariesPrecalculations = this.systemSettings.gameOptions.render.boundaries.wholeWorldPrecalculations;\n\n        this.#webGlEngine = new WebGlEngine(this.#drawContext, this.#systemSettingsReference.gameOptions);\n        if (this.systemSettings.gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT ||\n            this.systemSettings.gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT) {\n            this._registerRenderInit(this.#webGlEngine._initiateWasm);\n        }\n\n        this._registerRenderInit(this.fixCanvasSize);\n        this._registerRenderInit(\n            () => this._registerAndCompileWebGlProgram(CONST.WEBGL.DRAW_PROGRAMS.IMAGES, imgVertexShader, imgFragmentShader, imgUniforms, imgAttributes)\n        );\n        this._registerRenderInit(\n            () => this._registerAndCompileWebGlProgram(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES, primitivesVertexShader, primitivesFragmentShader, primitivesUniforms, primitivesAttributes)\n        );\n        this._registerRenderInit(this.#webGlEngine._initWebGlAttributes);\n\n        this._registerObjectRender(DrawTextObject.name, this.#webGlEngine._bindText, CONST.WEBGL.DRAW_PROGRAMS.IMAGES);\n        this._registerObjectRender(DrawRectObject.name, this.#webGlEngine._bindPrimitives, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n        this._registerObjectRender(DrawPolygonObject.name, this.#webGlEngine._bindPrimitives, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n        this._registerObjectRender(DrawCircleObject.name, this.#webGlEngine._bindConus, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n        this._registerObjectRender(DrawConusObject.name, this.#webGlEngine._bindConus, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n        this._registerObjectRender(DrawTiledLayer.name, this.#webGlEngine._bindTileImages, CONST.WEBGL.DRAW_PROGRAMS.IMAGES);\n        this._registerObjectRender(DrawLineObject.name, this.#webGlEngine._bindLine, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n    }\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    addEventListener = (eventName, listener, options) => {\n        this.#emitter.addEventListener(eventName, listener, options);\n    };\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    removeEventListener = (eventName, listener, options) => {\n        this.#emitter.removeEventListener(eventName, listener, options);\n    };\n\n    get stageData() {\n        return this.#currentGameStageData;\n    }\n\n    get systemSettings() {\n        return this.#systemSettingsReference;\n    }\n\n    get iLoader() {\n        return this.#loaderReference;\n    }\n\n    get canvas() {\n        return this.#canvas;\n    }\n\n    get drawContext() {\n        return this.#drawContext;\n    }\n\n    /**\n     * \n     * @param {string} eventName\n     * @param  {...any} eventParams\n     */\n    emit = (eventName, ...eventParams) => {\n        const event = new Event(eventName);\n        event.data = [...eventParams];\n        this.#emitter.dispatchEvent(event);\n    };\n\n    /**\n     * Determines if all added files was loaded or not\n     * @returns {boolean}\n     */\n    isAllFilesLoaded = () => {\n        return this.iLoader.filesWaitingForUpload === 0;\n    };\n\n    initiateContext = () => {\n        return Promise.all(this.#initPromises.map(method => method()));\n    };\n\n    clearContext() {\n        this.#webGlEngine._clearView();\n    }\n\n    setCanvasSize(width, height) {\n        this.#canvas.width = width;\n        this.#canvas.height = height;\n        if (this.#webGlEngine) {\n            this.#webGlEngine._fixCanvasSize(width, height);\n        }\n    }\n\n    fixCanvasSize = () => {\n        const settings = this.systemSettings, \n            canvasWidth = settings.canvasMaxSize.width && (settings.canvasMaxSize.width < window.innerWidth) ? settings.canvasMaxSize.width : window.innerWidth,\n            canvasHeight = settings.canvasMaxSize.height && (settings.canvasMaxSize.height < window.innerHeight) ? settings.canvasMaxSize.height : window.innerHeight;\n        this.setCanvasSize(canvasWidth, canvasHeight);\n        return Promise.resolve();\n    };\n\n    /****************************\n     *  Extend functionality\n     ****************************/\n    /**\n     * @ignore\n     * @param {string} programName\n     * @param {string} vertexShader - raw vertex shader program\n     * @param {string} fragmentShader - raw fragment shader program \n     * @param {Array<string>} uVars - program uniform variables names\n     * @param {Array<string>} aVars - program attribute variables names\n     * @returns {Promise<void>}\n     */\n    _registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {\n        this.#webGlEngine._registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars);\n        return Promise.resolve();\n    }\n\n    /**\n     * @ignore\n     * @param {function():Promise<void>} method \n     * @returns {void}\n     */\n    _registerRenderInit(method) {\n        this.#initPromises.push(method);\n        //} else {\n        //    Exception(ERROR_CODES.UNEXPECTED_METHOD_TYPE, \"registerRenderInit() accept only Promise based methods!\");\n        //}\n    }\n\n    /**\n     * @ignore\n     * @param {string} objectClassName - object name registered to DrawObjectFactory\n     * @param {function(renderObject, gl, pageData, program, vars):Promise<any[]>} objectRenderMethod - should be promise based returns vertices number and draw program\n     * @param {string=} objectWebGlDrawProgram \n     */\n    _registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram) {\n        this.#registeredRenderObjects.set(objectClassName, {method: objectRenderMethod, webglProgramName: objectWebGlDrawProgram});\n    }\n\n    /****************************\n     *  End of Extend functionality\n     ****************************/\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async render() {\n        let renderObjectsPromises = [],\n            errors = [],\n            isErrors = false;\n        const renderObjects = this.stageData.renderObjects;\n        if (renderObjects.length !== 0) {\n            //this.#checkCollisions(view.renderObjects);\n            for (let i = 0; i < renderObjects.length; i++) {\n                const object = renderObjects[i];\n                if (object.isRemoved) {\n                    renderObjects.splice(i, 1);\n                    i--;\n                    continue;\n                }\n                if (object.isAnimations) {\n                    object._processActiveAnimations();\n                }\n                const promise = await this._bindRenderObject(object)\n                    .catch((err) => Promise.reject(err));\n                renderObjectsPromises.push(promise);\n            }\n            if (this.systemSettings.gameOptions.debug.boundaries.drawLayerBoundaries) {\n                renderObjectsPromises.push(this.#drawBoundariesWebGl()\n                    .catch((err) => Promise.reject(err))); \n            }\n            //const bindResults = await Promise.allSettled(renderObjectsPromises);\n            //bindResults.forEach((result) => {\n            //    if (result.status === \"rejected\") {\n            //        reject(result.reason);\n            //    }\n            //});\n\n            //await this.#webGlEngine._executeImagesDraw();\n\n            //this.#postRenderActions();\n        }\n        const bindResults = await Promise.allSettled(renderObjectsPromises);\n        bindResults.forEach((result) => {\n            if (result.status === \"rejected\") {\n                reject(result.reason);\n                isErrors = true;\n                errors.push(result.reason);\n            }\n        });\n\n        this.#postRenderActions();\n            \n        this._isCleared = false;\n        if (isErrors === false) {\n            return Promise.resolve();\n        } else {\n            return Promise.reject(errors);\n        }\n    }\n\n    /**\n     * @ignore\n     */\n    set _isCleared(value) {\n        this.#isCleared = value;\n    }\n\n    /**\n     * @ignore\n     */\n    get _isCleared() {\n        return this.#isCleared;\n    }\n\n    _createBoundariesPrecalculations() {\n        //const promises = [];\n        //for (const layer of this.#renderLayers) {\n        //    promises.push(this.#layerBoundariesPrecalculation(layer).catch((err) => {\n        //        Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);\n        //    }));\n        //}\n        //return promises;\n    }\n    #postRenderActions() {\n        //const images = this.stageData.getObjectsByInstance(DrawImageObject);\n        //for (let i = 0; i < images.length; i++) {\n        //    const object = images[i];\n        //    if (object.isAnimations) {\n        //        object._processActiveAnimations();\n        //    }\n        //}\n    }\n\n    //#clearTileMapPromises() {\n    //    this.#bindTileMapPromises = [];\n    //}\n\n    /**\n     * \n     * @param {DrawTiledLayer} renderLayer \n     * @returns {Promise<void>}\n     */\n    #layerBoundariesPrecalculation(renderLayer) {\n        return new Promise((resolve, reject) => {\n            if (renderLayer.setBoundaries) {\n                const tilemap = this.iLoader.getTileMap(renderLayer.tileMapKey),\n                    tilesets = tilemap.tilesets,\n                    layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\n                    { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                    tilewidth = dtwidth,\n                    tileheight = dtheight,\n                    [ settingsWorldWidth, settingsWorldHeight ] = this.stageData.worldDimensions;\n                \n                let boundaries = [];\n\n                if (!layerData) {\n                    Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                    reject();\n                }\n                \n                for (let i = 0; i < tilesets.length; i++) {\n                    const layerCols = layerData.width,\n                        layerRows = layerData.height,\n                        worldW = tilewidth * layerCols,\n                        worldH = tileheight * layerRows;\n\n                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\n                        Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\n                        this.stageData._setWorldDimensions(worldW, worldH);\n                    }\n                    \n                    if (renderLayer.setBoundaries && this.systemSettings.gameOptions.render.boundaries.mapBoundariesEnabled) {\n                        this.stageData._setWholeWorldMapBoundaries();\n                    }\n\n                    //calculate boundaries\n                    let mapIndex = 0;\n\n                    for (let row = 0; row < layerRows; row++) {\n                        for (let col = 0; col < layerCols; col++) {\n                            let tile = layerData.data[mapIndex],\n                                mapPosX = col * tilewidth,\n                                mapPosY = row * tileheight;\n                            if (tile !== 0) {\n                                tile -= 1;\n                                \n                                boundaries.push([mapPosX, mapPosY, mapPosX + tilewidth, mapPosY]);\n                                boundaries.push([mapPosX + tilewidth, mapPosY, mapPosX + tilewidth, mapPosY + tileheight]);\n                                boundaries.push([mapPosX + tilewidth, mapPosY + tileheight, mapPosX, mapPosY + tileheight]);\n                                boundaries.push([mapPosX, mapPosY + tileheight, mapPosX, mapPosY ]);\n    \n                            }\n                            mapIndex++;\n                        }\n                    }\n                }\n                this.stageData._setWholeMapBoundaries(boundaries);\n                this.stageData._mergeBoundaries(true);\n                console.warn(\"precalculated boundaries set\");\n                console.log(this.stageData.getWholeWorldBoundaries());\n                resolve();\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * @ignore\n     * @param {DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer} renderObject \n     * @returns {Promise<void>}\n     */\n    _bindRenderObject(renderObject) {\n        const name = renderObject.constructor.name,\n            registeredRenderObject = this.#registeredRenderObjects.get(name);\n        if (registeredRenderObject) {\n            const name = registeredRenderObject.webglProgramName;\n            if (name) {\n                const program = this.#webGlEngine.getProgram(name),\n                    vars = this.#webGlEngine.getProgramVarLocations(name);\n                return registeredRenderObject.method(renderObject, this.drawContext, this.stageData, program, vars)\n                    .then((results) => this.#webGlEngine._render(results[0], results[1]));  \n            } else {\n                return registeredRenderObject.method(renderObject, this.drawContext, this.stageData);\n            }\n        } else {\n            // a workaround for images and its extend classes drawing\n            if (renderObject.type === CONST.DRAW_TYPE.IMAGE) {\n                const program = this.#webGlEngine.getProgram(CONST.WEBGL.DRAW_PROGRAMS.IMAGES),\n                    vars = this.#webGlEngine.getProgramVarLocations(CONST.WEBGL.DRAW_PROGRAMS.IMAGES);\n\n                if (!renderObject.image) {\n                    renderObject.image = this.iLoader.getImage(renderObject.key);\n                }\n                return this.#webGlEngine._bindImage(renderObject, this.drawContext, this.stageData, program, vars)\n                    .then((results) => this.#webGlEngine._render(results[0], results[1]))\n                    .then(() => {\n                        if (renderObject.vertices && this.systemSettings.gameOptions.debug.boundaries.drawObjectBoundaries) {\n                            return this.#webGlEngine._drawPolygon(renderObject, this.stageData);\n                        } else {\n                            return Promise.resolve();\n                        }\n                    });\n            } else {\n                console.warn(\"no registered draw object method for \" + name + \" skip draw\");\n                return Promise.resolve();\n            }\n        }\n    }\n\n    /**\n     * \n     * @returns {Promise<void>}\n     */\n    #drawBoundariesWebGl() {\n        return new Promise((resolve) => {\n            const b = this.stageData.getBoundaries(),\n                len = b.length,\n                linesArray = [];\n        \n            for (let i = 0; i < len; i++) {\n                const item = b[i];\n                linesArray.push(item[0], item[1]);\n                linesArray.push(item[2], item[3]);\n            }\n            this.#webGlEngine._drawLines(linesArray, this.systemSettings.gameOptions.debug.boundaries.boundariesColor, this.systemSettings.gameOptions.debug.boundaries.boundariesWidth);\n            resolve();\n        });\n    }\n\n    #countFPSaverage() {\n        const timeLeft = this.systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime,\n            steps = this.#tempFPStime.length;\n        let fullTime = 0;\n        for(let i = 0; i < steps; i++) {\n            const timeStep = this.#tempFPStime[i];\n            fullTime += timeStep;\n        }\n        console.log(\"FPS average for \", timeLeft/1000, \"sec, is \", fullTime / steps);\n\n        // cleanup\n        this.#tempFPStime = [];\n    }\n\n    /**\n     * @ignore\n     * @param {GameStageData} stageData \n     */\n    _startRender = async (/*time*/stageData) => {\n        const gameOptions = this.systemSettings.gameOptions;\n        //Logger.debug(\"_render \" + this.name + \" class\");\n        this.#isActive = true;\n        this.#currentGameStageData = stageData;\n        this.fixCanvasSize();\n        switch (gameOptions.library) {\n            case CONST.LIBRARY.WEBGL:\n                await this.#prepareViews();\n                setTimeout(() => requestAnimationFrame(this.#drawViews));\n                break;\n        }\n        if (gameOptions.render.cyclesTimeCalc.check === CONST.OPTIMIZATION.CYCLE_TIME_CALC.AVERAGES) {\n            this.#fpsAverageCountTimer = setInterval(() => this.#countFPSaverage(), gameOptions.render.cyclesTimeCalc.averageFPStime);\n        }\n    };\n\n    /**\n     * @ignore\n     */\n    _stopRender = () => {\n        this.#isActive = false;\n        this.#currentGameStageData = null;\n        this.#tempFPStime = [];\n        clearInterval(this.#fpsAverageCountTimer);\n        this.#fpsAverageCountTimer = null;\n    };\n    /**\n     * \n     * @returns {Promise<void>}\n     */\n    #prepareViews() {\n        return new Promise((resolve, reject) => {\n            let viewPromises = [];\n            const isBoundariesPrecalculations = this.#isBoundariesPrecalculations;\n            viewPromises.push(this.initiateContext());\n            if (isBoundariesPrecalculations) {\n                console.warn(\"isBoundariesPrecalculations() is turned off\");\n                //for (const view of this.#views.values()) {\n                //viewPromises.push(this.#iRender._createBoundariesPrecalculations());\n                //}\n            }\n            Promise.allSettled(viewPromises).then((drawingResults) => {\n                drawingResults.forEach((result) => {\n                    if (result.status === \"rejected\") {\n                        const error = result.reason;\n                        Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, error);\n                        reject(error);\n                    }\n                });\n                resolve();\n            });\n        });\n    }\n\n    #drawViews = async (/*drawTime*/) => {\n        const timeStart = performance.now(),\n            minCycleTime = this.#minCycleTime,\n            isCyclesTimeCalcCheckCurrent = this.systemSettings.gameOptions.render.cyclesTimeCalc.check === CONST.OPTIMIZATION.CYCLE_TIME_CALC.CURRENT;\n            \n        this.emit(CONST.EVENTS.SYSTEM.RENDER.START);\n        this.stageData._clearBoundaries();\n        this.clearContext();\n        \n        this.render().then(() => {\n            const timeEnd = performance.now() - timeStart,\n                r_time_less = minCycleTime - timeEnd,\n                wait_time = r_time_less > 0 ? r_time_less : 0,\n                fps = 1000 / (timeEnd + wait_time);\n            if (isCyclesTimeCalcCheckCurrent && timeEnd > minCycleTime) {\n                console.log(\"draw cycles done, take: \", (timeEnd), \" ms\");\n            }\n            this.emit(CONST.EVENTS.SYSTEM.RENDER.END);\n            if(fps === Infinity) {\n                console.log(\"infinity time\");\n            }\n            this.#tempFPStime.push(fps);\n            if (this.#isActive) {\n                setTimeout(() => requestAnimationFrame(this.#drawViews), wait_time);\n            }\n        }).catch((errors) => {\n            errors.forEach((err) => {\n                Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, err);\n            });\n            this._stopRender();\n        });\n    };\n}","import { CONST, ERROR_CODES, WARNING_CODES } from \"../constants.js\";\nimport { Exception, Warning } from \"./Exception.js\";\nimport { INetwork } from \"./INetwork.js\";\nimport { ISystemAudio } from \"./ISystemAudio.js\";\nimport { SystemSettings } from \"../configs.js\";\nimport AssetsManager from \"../../modules/assetsm/dist/assetsm.min.js\";\nimport { DrawObjectFactory } from \"./DrawObjectFactory.js\";\nimport { GameStage } from \"./GameStage.js\";\nimport { IRender } from \"./IRender.js\";\nimport { IExtension } from \"./IExtension.js\";\n\n/**\n * Public interface for a System<br>\n * Can be used to start/stop GameStage render, <br>\n * And provides access to SystemSettings, INetwork and ISystemAudio <br>\n * IRender, DrawObjectFactory, AssetsManager and external modules\n * accessible via GameStage.iSystem and System.system\n * @see {@link System} a part of System class instance\n * @see {@link GameStage} a part of GameStage class instance\n */\nexport class ISystem {\n    /**\n     * @type {Object}\n     */\n    #systemSettings;\n    /**\n     * @type {IExtension}\n     */\n    #iExtension;\n    /**\n     * @type {INetwork}\n     */\n    #systemServerConnection;\n    /**\n     * @type {ISystemAudio}\n     */\n    #systemAudioInterface;\n    /**\n     * @type {AssetsManager}\n     */\n    #iLoader = new AssetsManager();\n    /**\n     * @type {IRender}\n     */\n    #iRender;\n    /**\n     * @type {DrawObjectFactory}\n     */\n    #drawObjectFactory = new DrawObjectFactory(this.#iLoader);\n    \n    #modules = new Map();\n    /**\n     * @type {Map<string, GameStage>}\n     */\n    #registeredStagesReference;\n    /**\n     * @type {EventTarget}\n     */\n    #emitter = new EventTarget();\n    /**\n     * @hideconstructor\n     */\n    constructor(systemSettings, registeredStages, canvasContainer) {\n        if (!systemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\n        }\n        this.#systemSettings = systemSettings;\n        \n        this.#systemAudioInterface = new ISystemAudio(this.iLoader);\n        this.#systemServerConnection = new INetwork(systemSettings);\n        this.#iRender = new IRender(this.systemSettings, this.iLoader, canvasContainer);\n        this.#iExtension = new IExtension(this, this.#iRender);\n        this.#registeredStagesReference = registeredStages;\n        // broadcast render events\n        this.#iRender.addEventListener(CONST.EVENTS.SYSTEM.RENDER.START, () => this.emit(CONST.EVENTS.SYSTEM.RENDER.START));\n        this.#iRender.addEventListener(CONST.EVENTS.SYSTEM.RENDER.END, () => this.emit(CONST.EVENTS.SYSTEM.RENDER.END));\n    }\n\n    /**\n     * \n     * @param {string} eventName\n     * @param  {...any} eventParams\n     */\n    emit = (eventName, ...eventParams) => {\n        const event = new Event(eventName);\n        event.data = [...eventParams];\n        this.#emitter.dispatchEvent(event);\n    };\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    addEventListener = (eventName, listener, options) => {\n        this.#emitter.addEventListener(eventName, listener, options);\n    };\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    removeEventListener = (eventName, listener, options) => {\n        this.#emitter.removeEventListener(eventName, listener, options);\n    };\n    \n    /**\n     * @type { INetwork }\n     */\n    get iNetwork () {\n        return this.#systemServerConnection;\n    }\n\n    /**\n     * @type { SystemSettings }\n     */\n    get systemSettings() {\n        return this.#systemSettings;\n    }\n\n    /**\n     * @type { ISystemAudio }\n     */\n    get audio() {\n        return this.#systemAudioInterface;\n    }\n\n    /**\n     * @type {AssetsManager}\n     */\n    get iLoader() {\n        return this.#iLoader;\n    }\n\n    /**\n     * @type {IRender}\n     */\n    get iRender() {\n        return this.#iRender;\n    }\n\n    /**\n     * @type {DrawObjectFactory}\n     */\n    get drawObjectFactory() {\n        return this.#drawObjectFactory;\n    }\n\n    get iExtension() {\n        return this.#iExtension;\n    }\n    /**\n     * @type {Map<string, Object>}\n     */\n    get modules() {\n        return this.#modules;\n    }\n\n    /**\n     * \n     * @param {string} moduleKey \n     * @param {Object} moduleClass \n     * @param  {...any} args \n     * @returns {Object}\n     */\n    installModule = (moduleKey, moduleClass, ...args) => {\n        const moduleInstance = new moduleClass(this, ...args);\n        if (this.#modules.has(moduleKey)) {\n            Warning(WARNING_CODES.MODULE_ALREADY_INSTALLED, \"module \" + moduleKey + \" is already installed\");\n            return this.#modules.get(moduleKey);\n        } else {\n            this.#modules.set(moduleKey, moduleInstance);\n        }\n        return moduleInstance;\n    };\n\n    /**\n     * @method\n     * @param {string} screenPageName\n     * @param {Object} [options] - options\n     */\n    startGameStage = (screenPageName, options) => {\n        if (this.#registeredStagesReference.has(screenPageName)) {\n            const stage = this.#registeredStagesReference.get(screenPageName),\n                pageData = stage.stageData;\n            this.#drawObjectFactory._attachPageData(pageData);\n            if (stage.isInitiated === false) {\n                stage._init();\n            }\n            //stage._attachCanvasToContainer(this.#canvasContainer);\n            stage._start(options);\n            this.emit(CONST.EVENTS.SYSTEM.START_PAGE);\n            this.#iRender._startRender(pageData);\n        } else {\n            Exception(ERROR_CODES.VIEW_NOT_EXIST, \"View \" + screenPageName + \" is not registered!\");\n        }\n    };\n\n    /**\n     * @method\n     * @param {string} screenPageName\n     */\n    stopGameStage = (screenPageName) => {\n        if (this.#registeredStagesReference.has(screenPageName)) {\n            this.emit(CONST.EVENTS.SYSTEM.STOP_PAGE);\n            this.drawObjectFactory._detachPageData();\n            this.#iRender._stopRender();\n            this.#registeredStagesReference.get(screenPageName)._stop();\n        } else {\n            Exception(ERROR_CODES.VIEW_NOT_EXIST, \"View \" + screenPageName + \" is not registered!\");\n        }\n    };\n}","import AssetsManager from  \"../../modules/assetsm/dist/assetsm.min.js\";\nimport { WARNING_CODES } from \"../constants.js\";\nimport { Warning } from \"./Exception.js\";\n\n/**\n * An audio interface, <br>\n * controls all application audio,<br>\n * holds and retrieves audio, changes volume<br> \n * accessible via GameStage.audio\n * @see {@link GameStage} a part of GameStage\n * @hideconstructor\n */\nexport class ISystemAudio {\n    #volume = 0.5;\n    #audio = new Map();\n    /**\n     * @type {AssetsManager}\n     */\n    #loaderReference;\n\n    constructor(iLoader) {\n        this.#loaderReference = iLoader;\n    }\n\n    /**\n     * Original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudio = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            Warning(WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            return audio;\n        } else {\n            Warning(WARNING_CODES.AUDIO_NOT_REGISTERED, \"\");\n            return null;\n        }\n    };\n\n    /**\n     * Clone of original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudioCloned = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            Warning(WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            const audioCloned = audio.cloneNode();\n            audioCloned.volume = this.#volume;\n            return audioCloned;\n        } else {\n            Warning(WARNING_CODES.AUDIO_NOT_REGISTERED);\n            return null;\n        }\n    };\n\n    set volume(value) {\n        this.#volume = value;\n        this.#updateTracksVolumes(value);\n    }\n    /**\n     * Used to set or get audio volume, \n     * value should be from 0 to 1\n     * @type {number}\n     */\n    get volume() {\n        return this.#volume;\n    }\n\n    #updateTracksVolumes(value) {\n        for (const track of this.#audio.values()) {\n            if (track) {\n                track.volume = value;\n            }\n        }\n    }\n\n    /**\n     * Register audio in the iSystem\n     * @param {string} name\n     */\n    registerAudio(name) {\n        let mediaElement = this.#loaderReference.getAudio(name);\n        this.#audio.set(name, mediaElement);\n    }\n}","import { SystemSettings } from \"../configs.js\";\nimport { CONST } from \"../constants.js\";\n\nexport class Logger {\n    static debug(...args) {\n        if (SystemSettings.mode === CONST.MODE.DEBUG)\n            args.forEach(message => console.log(message));\n    }\n}","class Vertex {\n    #x;\n    #y;\n    constructor(x, y) {\n        this.#x = x;\n        this.#y = y;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n}\n\nclass Rectangle {\n    #x;\n    #y;\n    #w;\n    #h;\n    constructor(x, y, w, h) {\n        this.#x = x;\n        this.#y = y;\n        this.#w = w;\n        this.#h = h; \n    }\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n    /**\n     * @type {number}\n     */\n    get y() {\n        return this.#y;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n}\n\nclass Vector {\n    #x;\n    #y;\n    constructor(x1, y1, x2, y2) {\n        this.#x = x2 - x1;\n        this.#y = y2 - y1;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n\n    get length() {\n        return Math.sqrt(Math.pow(this.#x, 2) + Math.pow(this.#y, 2));\n    }\n\n    get tetaAngle() {\n        return Math.atan2(this.#y, this.#x);\n    }\n}\n\nexport { Vertex, Rectangle, Vector };","import { ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { GameStage } from \"./GameStage.js\";\nimport { ISystem } from \"./ISystem.js\";\nimport { SystemSettings } from \"../configs.js\";\n\nimport { LoadingStage } from \"../design/LoadingStage.js\";\n\nconst loadingPageName = \"loadingPage\";\n/**\n * A main app class, <br>\n * Holder class for GameStage,<br>\n * can register new GameStages,<br>\n * init and preload data for them,<br>\n */\nexport class System {\n    /**\n     * @type {Map<string, GameStage>}\n     */\n    #registeredStages;\n    /**\n     * @type {ISystem}\n     */\n    #iSystem;\n    /**\n     * @param {SystemSettings} iSystemSettings - holds iSystem settings\n     * @param {HTMLElement} [canvasContainer] - If it is not passed, iSystem will create div element and attach it to body\n     */\n    constructor(iSystemSettings, canvasContainer) {\n        if (!iSystemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"iSystemSettings should be passed to class instance\");\n        }\n        this.#registeredStages = new Map();\n\n        if (!canvasContainer) {\n            canvasContainer = document.createElement(\"div\");\n            document.body.appendChild(canvasContainer);\n        }\n\n        this.#iSystem = new ISystem(iSystemSettings, this.#registeredStages, canvasContainer);\n\n        this.registerStage(loadingPageName, LoadingStage);\n\n        this.#iSystem.iLoader.addEventListener(\"loadstart\", this.#loadStart);\n        this.#iSystem.iLoader.addEventListener(\"progress\", this.#loadProgress);\n        this.#iSystem.iLoader.addEventListener(\"load\", this.#loadComplete);\n    }\n\n    /**\n     * @type {ISystem}\n     */\n    get iSystem() {\n        return this.#iSystem;\n    }\n\n    /**\n     * A main factory method for create GameStage instances, <br>\n     * register them in a System and call GameStage.register() stage\n     * @param {string} screenPageName\n     * @param {GameStage} stage\n     */\n    registerStage(screenPageName, stage) {\n        if (screenPageName && typeof screenPageName === \"string\" && screenPageName.trim().length > 0) {\n            const stageInstance = new stage();\n            stageInstance._register(screenPageName, this.iSystem);\n            this.#registeredStages.set(screenPageName, stageInstance);\n        } else {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"valid class name should be provided\");\n        }\n    }\n\n    /**\n     * Preloads assets for all registered pages\n     * @return {Promise<void>}\n     */\n    preloadAllData() {\n        return this.#iSystem.iLoader.preload();\n    }\n\n    #loadStart = (event) => {\n        this.#iSystem.startGameStage(loadingPageName, {total: event.total});\n    };\n\n    #loadProgress = (event) => {\n        const uploaded = event.loaded,\n            left = event.total,\n            loadingPage = this.#registeredStages.get(loadingPageName);\n            \n        loadingPage._progress(uploaded, left);\n    };\n\n    #loadComplete = () => {\n        this.#iSystem.stopGameStage(loadingPageName);\n    };\n}","const imgVertexShader =  `\n    attribute vec2 a_texCoord;\n\n    attribute vec2 a_position;\n\n    uniform vec2 u_translation;\n    uniform float u_rotation;\n    uniform vec2 u_scale;\n\n    uniform vec2 u_resolution;\n\n    varying vec2 v_texCoord;\n\n    void main(void) {\n        float c = cos(u_rotation);\n        float s = sin(u_rotation);\n\n        mat3 translationMatrix1 = mat3(\n            1, 0, 0,\n            0, 1, 0,\n            u_translation.x, u_translation.y, 1\n        );\n\n        mat3 translationMatrix2 = mat3(\n            1, 0, 0,\n            0, 1, 0,\n            -u_translation.x, -u_translation.y, 1\n        );\n        \n        mat3 rotationMatrix = mat3(\n            c, s, 0,\n            -s, c, 0,\n            0, 0, 1\n        );\n\n        mat3 scalingMatrix = mat3(\n            u_scale.x, 0, 0,\n            0, u_scale.y, 0,\n            0, 0, 1\n        );\n\n        mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\n    \n        vec2 position = (matrix * vec3(a_position, 1)).xy;\n\n        vec2 clipSpace = position / u_resolution * 2.0 - 1.0;\n\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n        \n        v_texCoord = a_texCoord;\n    }`;\nconst imgFragmentShader = `\n    precision mediump float;\n\n    uniform sampler2D u_image;\n\n    //texCoords passed in from the vertex shader\n    varying vec2 v_texCoord;\n\n    void main() {\n        vec4 color = texture2D(u_image, v_texCoord);\n        gl_FragColor = color;\n    }`;\nconst imgUniforms = [\"u_translation\", \"u_rotation\", \"u_scale\", \"u_resolution\",\"u_image\"];\nconst imgAttributes = [\"a_position\", \"a_texCoord\"];\n\nexport {imgVertexShader, imgFragmentShader, imgUniforms, imgAttributes};","const primitivesVertexShader =  `\n    precision mediump float;\n\n    attribute vec2 a_position;\n\n    uniform vec2 u_translation;\n    uniform float u_rotation;\n    uniform vec2 u_scale;\n\n    uniform vec2 u_resolution;\n\n    void main(void) {\n        float c = cos(u_rotation);\n        float s = sin(u_rotation);\n\n        mat3 translationMatrix1 = mat3(\n            1, 0, 0,\n            0, 1, 0,\n            u_translation.x, u_translation.y, 1\n        );\n\n        //mat3 translationMatrix2 = mat3(\n        //    1, 0, 0,\n        //    0, 1, 0,\n        //    -u_translation.x, -u_translation.y, 1\n        //);\n        \n        mat3 rotationMatrix = mat3(\n            c, s, 0,\n            -s, c, 0,\n            0, 0, 1\n        );\n\n        mat3 scalingMatrix = mat3(\n            u_scale.x, 0, 0,\n            0, u_scale.y, 0,\n            0, 0, 1\n        );\n        \n        mat3 matrix = translationMatrix1 * rotationMatrix * scalingMatrix;\n\n        vec2 position = (matrix * vec3(a_position, 1)).xy;\n\n        vec2 clipSpace = position / u_resolution * 2.0 - 1.0;\n\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    }\n`;\nconst primitivesFragmentShader = `\n    precision mediump float;\n\n    uniform vec4 u_color;\n    uniform float u_fade_min; \n    uniform float u_fade_max;\n    uniform vec2 a_position;\n    uniform vec2 u_resolution;\n    uniform vec2 u_translation;\n\n    void main(void) {\n        vec4 p = u_color;\n        if (u_fade_min > 0.0) {\n            vec2 fix_tr = vec2(u_translation.x, u_resolution.y - u_translation.y); \n            float distance = distance(fix_tr.xy, gl_FragCoord.xy);\n            if (u_fade_min <= distance && distance <= u_fade_max) {\n                float percent = ((distance - u_fade_max) / (u_fade_min - u_fade_max)) * 100.0;\n                p.a = u_color.a * (percent / 100.0);\n            }\n        }\n\n        gl_FragColor = p;\n    }\n`;\nconst primitivesUniforms = [\"u_translation\", \"u_rotation\", \"u_scale\", \"u_resolution\", \"u_fade_min\", \"u_fade_max\", \"u_color\"];\nconst primitivesAttributes = [\"a_position\"];\n\nexport { primitivesVertexShader, primitivesFragmentShader, primitivesUniforms, primitivesAttributes };","/**\n * storing current WebGLTexture\n */\nexport class TextureStorage {\n    /**\n     * @type {Number}\n     */\n    #textureIndex;\n    /**\n     * @type {WebGLTexture}\n     */\n    #texture;\n    /**\n     * @type {boolean}\n     */\n    #isTextureRecalculated = true;\n    constructor(texture, textureIndex = 0) {\n        this.#texture = texture;\n        this.#textureIndex = textureIndex;\n    }\n\n    get _isTextureRecalculated() {\n        return this.#isTextureRecalculated;\n    }\n\n    set _isTextureRecalculated(value) {\n        this.#isTextureRecalculated = value;\n    }\n\n    get _texture() {\n        return this.#texture;\n    }\n\n    set _texture(value) {\n        this.#texture = value;\n    }\n\n    get _textureIndex() {\n        return this.#textureIndex;\n    }\n}","import { ERROR_CODES, CONST, WARNING_CODES } from \"../../constants.js\";\nimport { crossProduct } from \"../../utils.js\";\nimport { Exception, Warning } from \"../Exception.js\";\nimport { GameStageData } from \"../GameStageData.js\";\nimport { TextureStorage } from \"./TextureStorage.js\";\n\nexport class WebGlEngine {\n    /**\n     * @type {WebGLRenderingContext}\n     */\n    #gl;\n    /**\n     * @type {boolean}\n     */\n    #debug;\n    /**\n     * @type {Object}\n     */\n    #gameOptions;\n    /**\n     * @type {WebGLBuffer | null}\n     */\n    #positionBuffer;\n    /**\n     * @type {WebGLBuffer | null}\n     */\n    #texCoordBuffer;\n\n    /**\n     * @type {Map<string, WebGLProgram}\n     */\n    #registeredWebGlPrograms = new Map();\n    /**\n     * @type {Map<string, Object<string, WebGLUniformLocation | number>>}\n     */\n    #webGlProgramsVarsLocations = new Map();\n\n    constructor(context, gameOptions) {\n        if (!context || !(context instanceof WebGLRenderingContext)) {\n            Exception(ERROR_CODES.UNEXPECTED_INPUT_PARAMS, \" context parameter should be specified and equal to WebGLRenderingContext\");\n        }\n        \n        this.#gl = context;\n        this.#gameOptions = gameOptions;\n        this.#debug = gameOptions.debug.checkWebGlErrors;\n        this.#positionBuffer = context.createBuffer();\n        this.#texCoordBuffer = context.createBuffer();\n    }\n\n    getProgram(name) {\n        return this.#registeredWebGlPrograms.get(name);\n    }\n\n    getProgramVarLocations(name) {\n        return this.#webGlProgramsVarsLocations.get(name);\n    }\n\n    _fixCanvasSize(width, height) {\n        this.#gl.viewport(0, 0, width, height);\n    }\n    _initWebGlAttributes = () => {\n        const gl = this.#gl;\n        gl.enable(gl.BLEND);\n        gl.enable(gl.STENCIL_TEST);\n        gl.stencilFunc(gl.ALWAYS, 1, 0xFF);\n        //if stencil test and depth test pass we replace the initial value\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n        return Promise.resolve();\n    };\n\n    /**\n     * \n     * @returns {Promise<void>}\n     */\n    _initiateWasm = () => {\n        const url = this.#gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT ? this.#gameOptions.optimizationWASMUrl : this.#gameOptions.optimizationAssemblyUrl;\n        return new Promise((resolve, reject) => {\n            this.layerData = new WebAssembly.Memory({\n                initial:1000 // 6.4MiB x 10 = 64MiB(~67,1Mb)\n            });\n            this.layerDataFloat32 = new Float32Array(this.layerData.buffer);\n            const importObject = {\n                env: {\n                    memory: this.layerData,\n                    logi: console.log,\n                    logf: console.log\n                }\n            };\n\n            fetch(url)\n                .then((response) => response.arrayBuffer())\n                .then((module) => WebAssembly.instantiate(module, importObject))\n                .then((obj) => {\n                    this.calculateBufferData = obj.instance.exports.calculateBufferData;\n                    resolve();\n                });\n        });\n    };\n\n    _clearView() {\n        const gl = this.#gl;\n        gl.clearColor(0, 0, 0, 0);// shouldn't be gl.clearColor(0, 0, 0, 1); ?\n        // Clear the color buffer with specified clear color\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\n    }\n    \n    _render(verticesNumber, primitiveType, offset = 0) {\n        const gl = this.#gl,\n            err = this.#debug ? gl.getError() : 0;\n        if (err !== 0) {\n            console.error(err);\n            throw new Error(\"Error num: \" + err);\n        } else {\n            gl.drawArrays(primitiveType, offset, verticesNumber);\n            // set blend to default\n            gl.stencilFunc(gl.ALWAYS, 1, 0xFF);\n        }\n        return new Promise((resolve, reject) => {\n            if (this.#gameOptions.debug.delayBetweenObjectRender) {\n                setTimeout(() => {\n                    resolve();\n                }, 1000);\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    /*************************************\n     * Register and compile programs\n     ************************************/\n\n    /**\n     * \n     * @param {string} programName\n     * @param {string} vertexShader - raw vertex shader program\n     * @param {string} fragmentShader - raw fragment shader program \n     * @param {Array<string>} uVars - program uniform variables names\n     * @param {Array<string>} aVars - program attribute variables names\n     * @returns {Promise<void>}\n     */\n    _registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {\n        const program = this.#compileWebGlProgram(vertexShader, fragmentShader),\n            varsLocations = this.#getProgramVarsLocations(program, uVars, aVars);\n        this.#registeredWebGlPrograms.set(programName, program);\n        this.#webGlProgramsVarsLocations.set(programName, varsLocations);\n\n        return Promise.resolve();\n    }\n\n    /**\n     * @returns {WebGLProgram}\n     */\n    #compileWebGlProgram (vertexShader, fragmentShader) {\n        const gl = this.#gl,\n            program = gl.createProgram();\n\n        if (program) {\n            const compVertexShader = this.#compileShader(gl, vertexShader, gl.VERTEX_SHADER);\n            if (compVertexShader) {\n                gl.attachShader(program, compVertexShader);\n            } else {\n                Exception(ERROR_CODES.WEBGL_ERROR, \"#compileShader(vertexShaderSource) is null\");\n            }\n\n            const compFragmentShader = this.#compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);\n            if (compFragmentShader) {\n                gl.attachShader(program, compFragmentShader);\n            } else {\n                Exception(ERROR_CODES.WEBGL_ERROR, \"#compileShader(fragmentShaderSource) is null\");\n            }\n\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                const info = gl.getProgramInfoLog(program);\n                Exception(ERROR_CODES.WEBGL_ERROR, `Could not compile WebGL program. \\n\\n${info}`);\n            }\n        } else {\n            Exception(ERROR_CODES.WEBGL_ERROR, \"gl.createProgram() is null\");\n        }\n        return program;\n    }\n\n    /**\n     * \n     * @param {WebGLProgram} program\n     * @param {Array<string>} uVars - uniform variables\n     * @param {Array<string>} aVars - attributes variables\n     * @returns {Object<string, WebGLUniformLocation | number>} - uniform or attribute\n     */\n    #getProgramVarsLocations(program, uVars, aVars) {\n        const gl = this.#gl;\n        let locations = {};\n        uVars.forEach(elementName => {\n            locations[elementName] = gl.getUniformLocation(program, elementName);\n        });\n        aVars.forEach(elementName => {\n            locations[elementName] = gl.getAttribLocation(program, elementName);\n        });\n        return locations;\n    }\n\n    #compileShader(gl, shaderSource, shaderType) {\n        const shader = gl.createShader(shaderType);\n        if (shader) {\n            gl.shaderSource(shader, shaderSource);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                const info = gl.getShaderInfoLog(shader);\n                Exception(ERROR_CODES.WEBGL_ERROR, \"Couldn't compile webGl program. \\n\\n\" + info);\n            }\n        } else {\n            Exception(ERROR_CODES.WEBGL_ERROR, `gl.createShader(${shaderType}) is null`);\n        }\n        return shader;\n    }\n    /*------------------------------------\n     * End of Register and compile programs\n     -------------------------------------*/\n\n    /**********************************\n     * Predefined Drawing programs\n     **********************************/\n    _bindPrimitives = (renderObject, gl, pageData, program, vars) => {\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n            x = renderObject.x - xOffset,\n            y = renderObject.y - yOffset,\n            scale = [1, 1],\n            rotation = renderObject.rotation,\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],\n            { \n                u_translation: translationLocation,\n                u_rotation: rotationRotation,\n                u_scale: scaleLocation,\n                u_resolution: resolutionUniformLocation,\n                u_color: colorUniformLocation,\n                a_position: positionAttributeLocation,\n                u_fade_min: fadeMinLocation\n            } = vars;\n            \n        let verticesNumber = 0;\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, x, y);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        switch (renderObject.type) {\n        case CONST.DRAW_TYPE.RECTANGLE:\n            this.#setSingleRectangle(renderObject.width, renderObject.height);\n            verticesNumber += 6;\n            break;\n        case CONST.DRAW_TYPE.TEXT:\n            break;\n        case CONST.DRAW_TYPE.CIRCLE: {\n            const coords = renderObject.vertices;\n            gl.bufferData(this.#gl.ARRAY_BUFFER, \n                new Float32Array(coords), this.#gl.STATIC_DRAW);\n            verticesNumber += coords.length / 2;\n            break;\n        }\n        case CONST.DRAW_TYPE.POLYGON: {\n            const triangles = this.#triangulatePolygon(renderObject.vertices);\n            this.#bindPolygon(triangles);\n            const len = triangles.length;\n            if (len % 3 !== 0) {\n                Warning(WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, `polygons ${renderObject.id}, vertices are not correct, skip drawing`);\n                return Promise.reject();\n            }\n            verticesNumber += len / 2;\n            break;\n        }\n        }\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(renderObject.bgColor);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        if (blend) {\n            gl.blendFunc(blend[0], blend[1]);\n        }\n        \n        if (renderObject.isMaskAttached) {\n            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);\n        } else if (renderObject._isMask) {\n            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);\n        }\n        return Promise.resolve([verticesNumber, gl.TRIANGLES]);\n    };\n    _bindConus = (renderObject, gl, pageData, program, vars) => {\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n            x = renderObject.x - xOffset,\n            y = renderObject.y - yOffset,\n            scale = [1, 1],\n            rotation = renderObject.rotation,\n            { \n                u_translation: translationLocation,\n                u_rotation: rotationRotation,\n                u_scale: scaleLocation,\n                u_resolution: resolutionUniformLocation,\n                u_color: colorUniformLocation,\n                a_position: positionAttributeLocation,\n                u_fade_max: fadeMaxLocation,\n                u_fade_min: fadeMinLocation\n            } = vars,\n            coords = renderObject.vertices,\n            fillStyle = renderObject.bgColor,\n            fade_min = renderObject.fade_min,\n            fadeLen = renderObject.radius,\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\n        let verticesNumber = 0;\n\n        gl.useProgram(program);\n        \n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, x, y);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, fade_min);\n        gl.uniform1f(fadeMaxLocation, fadeLen);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        gl.bufferData(this.#gl.ARRAY_BUFFER, \n            new Float32Array(coords), this.#gl.STATIC_DRAW);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        verticesNumber += coords.length / 2;\n\n        if (blend) {\n            gl.blendFunc(blend[0], blend[1]);\n        }\n\n        const colorArray = this.#rgbaToArray(fillStyle);\n\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        if (renderObject.isMaskAttached) {\n            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);\n        } else if (renderObject._isMask) {\n            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);\n        }\n        \n        return Promise.resolve([verticesNumber, gl.TRIANGLE_FAN]);\n    };\n\n    _bindText = (renderObject, gl, pageData, program, vars) => {\n        const { u_translation: translationLocation,\n            u_rotation: rotationRotation,\n            u_scale: scaleLocation,\n            u_resolution: resolutionUniformLocation,\n            a_position: positionAttributeLocation,\n            a_texCoord: texCoordLocation,\n            u_image: u_imageLocation } = vars;\n\n        const {width:boxWidth, height:boxHeight} = renderObject.boundariesBox,\n            image_name = renderObject.text,\n            [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n            x = renderObject.x - xOffset,\n            y = renderObject.y - yOffset - boxHeight,\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\n\n        const rotation = 0,\n            scale = [1, 1];\n        const vecX1 = x,\n            vecY1 = y,\n            vecX2 = vecX1 + boxWidth,\n            vecY2 = vecY1 + boxHeight;\n        const verticesBufferData = [\n                vecX1, vecY1,\n                vecX2, vecY1,\n                vecX1, vecY2,\n                vecX1, vecY2,\n                vecX2, vecY1,\n                vecX2, vecY2\n            ],\n            texturesBufferData = [\n                0, 0,\n                1, 0,\n                0, 1,\n                0, 1,\n                1, 0,\n                1, 1\n            ];\n        let verticesNumber = 0;\n\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, x, y);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBufferData), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        //textures buffer\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texturesBufferData), gl.STATIC_DRAW);\n\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n        \n        verticesNumber += 6;\n        // remove box\n        // fix text edges\n        gl.blendFunc(blend[0], blend[1]);\n        //\n        //var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\n        \n        let textureStorage = renderObject._textureStorage;\n        if (!textureStorage) {\n            textureStorage = new TextureStorage(gl.createTexture());\n            renderObject._textureStorage = textureStorage;\n        }\n        if (textureStorage._isTextureRecalculated === true) {\n            this.#updateWebGlTexture(gl, textureStorage._texture, renderObject._textureCanvas);\n            textureStorage._isTextureRecalculated = false;\n        } else {\n            this.#bindTexture(gl, textureStorage._texture);\n        }\n        gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\n        \n        return Promise.resolve([verticesNumber, gl.TRIANGLES]);\n    };\n\n    _bindImage = (renderObject, gl, pageData, program, vars) => {\n        const { \n            u_translation: translationLocation,\n            u_rotation: rotationRotation,\n            u_scale: scaleLocation,\n            u_resolution: resolutionUniformLocation,\n            a_position: positionAttributeLocation,\n            a_texCoord: texCoordLocation,\n            u_image: u_imageLocation } = vars;\n\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n            x = renderObject.x - xOffset,\n            y = renderObject.y - yOffset;\n\n        const atlasImage = renderObject.image,\n            animationIndex = renderObject.imageIndex,\n            image_name = renderObject.key,\n            shapeMaskId = renderObject._maskId,\n            spacing = renderObject.spacing,\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],\n            scale = [1, 1];\n        let imageX = 0,\n            imageY = 0,\n            colNum = 0,\n            rowNum = 0,\n            verticesNumber = 0;\n        if (animationIndex !== 0) {\n            const imageColsNumber = (atlasImage.width + spacing) / (renderObject.width + spacing);\n            colNum = animationIndex % imageColsNumber;\n            rowNum = Math.floor(animationIndex / imageColsNumber);\n            imageX = colNum * renderObject.width + (colNum * spacing),\n            imageY = rowNum * renderObject.height + (rowNum * spacing);\n        }\n        const posX = x - renderObject.width / 2,\n            posY = y - renderObject.height / 2;\n        const vecX1 = posX,\n            vecY1 = posY,\n            vecX2 = vecX1 + renderObject.width,\n            vecY2 = vecY1 + renderObject.height,\n            texX1 = 1 / atlasImage.width * imageX,\n            texY1 = 1 / atlasImage.height * imageY,\n            texX2 = texX1 + (1 / atlasImage.width * renderObject.width),\n            texY2 = texY1 + (1 / atlasImage.height * renderObject.height);\n        const vectors = [\n                vecX1, vecY1,\n                vecX2, vecY1,\n                vecX1, vecY2,\n                vecX1, vecY2,\n                vecX2, vecY1,\n                vecX2, vecY2\n            ],\n            textures = [\n                texX1, texY1,\n                texX2, texY1,\n                texX1, texY2,\n                texX1, texY2,\n                texX2, texY1,\n                texX2, texY2\n            ];\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, x, y);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, renderObject.rotation);\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vectors), gl.STATIC_DRAW);\n\n        verticesNumber += vectors.length / 2;\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        //textures buffer\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures), gl.STATIC_DRAW);\n\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n        let textureStorage = renderObject._textureStorage;\n        if (!textureStorage) {\n            textureStorage = new TextureStorage(gl.createTexture());\n            renderObject._textureStorage = textureStorage;\n        } \n        if (textureStorage._isTextureRecalculated === true) {\n            this.#updateWebGlTexture(gl, textureStorage._texture, renderObject.image);\n            textureStorage._isTextureRecalculated = false;\n        } else {\n            this.#bindTexture(gl, textureStorage._texture);\n        }\n\n        gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\n        // make image transparent parts transparent\n        gl.blendFunc(blend[0], blend[1]);\n        if (shapeMaskId) {\n            gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);\n            //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\n        }\n\n        return Promise.resolve([verticesNumber, gl.TRIANGLES]);\n    };\n\n    _bindTileImages = async(renderLayer, gl, pageData, program, vars) => {\n        const { u_translation: translationLocation,\n            u_rotation: rotationRotation,\n            u_scale: scaleLocation,\n            u_resolution: resolutionUniformLocation,\n            a_position: positionAttributeLocation,\n            a_texCoord: texCoordLocation,\n            u_image: u_imageLocation } = vars;\n\n        gl.useProgram(program);\n        let renderLayerData;\n        switch (this.#gameOptions.optimization) {\n        case CONST.OPTIMIZATION.NATIVE_JS.NOT_OPTIMIZED:\n            renderLayerData = await this.#prepareRenderLayerOld(renderLayer, pageData);\n            break;\n        case CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT:\n        case CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT:\n            renderLayerData = await this.#prepareRenderLayerWM(renderLayer, pageData);\n            break;\n        case CONST.OPTIMIZATION.NATIVE_JS.OPTIMIZED:\n        default:\n            renderLayerData = await this.#prepareRenderLayer(renderLayer, pageData);\n        }\n        const translation = [0, 0],\n            scale = [1, 1],\n            rotation = 0,\n            drawMask = [\"ONE\", \"ONE_MINUS_SRC_ALPHA\"],\n            shapeMaskId = renderLayer._maskId;\n\n        let verticesNumber = 0;\n        for (let i = 0; i < renderLayerData.length; i++) {\n            const data = renderLayerData[i],\n                vectors = data[0],\n                textures = data[1],\n                image_name = data[2],\n                image = data[3];\n            // a workaround for renderlayers.tilesets.length > 1\n            // work correctly only if layer contains textures\n            // from single tileset, otherwise it will fail\n            if (vectors.length > 0 && textures.length > 0) {\n                // set the resolution\n                gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n                gl.uniform2f(translationLocation,translation[0], translation[1]);\n                gl.uniform2f(scaleLocation, scale[0], scale[1]);\n                gl.uniform1f(rotationRotation, rotation);\n                \n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, vectors, gl.STATIC_DRAW);\n\n                gl.enableVertexAttribArray(positionAttributeLocation);\n                //Tell the attribute how to get data out of positionBuffer\n                const size = 2,\n                    type = gl.FLOAT, // data is 32bit floats\n                    normalize = false,\n                    stride = 0, // move forward size * sizeof(type) each iteration to get next position\n                    offset = verticesNumber * 4; // start of beginning of the buffer\n                gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n                //textures buffer\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, textures, gl.STATIC_DRAW);\n\n                gl.enableVertexAttribArray(texCoordLocation);\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);\n\n                let textureStorage = renderLayer._textureStorages[i];\n                if (!textureStorage) {\n                    textureStorage = new TextureStorage(gl.createTexture(), i);\n                    renderLayer._setTextureStorage(i, textureStorage);\n                } \n                if (textureStorage._isTextureRecalculated === true) { \n                    this.#updateWebGlTexture(gl, textureStorage._texture, image, textureStorage._textureIndex);\n                    textureStorage._isTextureRecalculated = false;\n                } else {\n                    this.#bindTexture(gl, textureStorage._texture, textureStorage._textureIndex);\n                }\n                gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\n                gl.blendFunc(gl[drawMask[0]], gl[drawMask[1]]);\n                verticesNumber += vectors.length / 2;\n                if (shapeMaskId) {\n                    gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);\n                }\n            }\n        }\n        return Promise.resolve([verticesNumber, gl.TRIANGLES]);\n    };\n\n    _drawPolygon(renderObject, pageData) {\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n            x = renderObject.x - xOffset,\n            y = renderObject.y - yOffset,\n            rotation = renderObject.rotation || 0,\n            vertices = renderObject.vertices,\n            color =  this.#gameOptions.debug.boundaries.boundariesColor;\n        const program = this.getProgram(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n        const { u_translation: translationLocation,\n                u_rotation: rotationRotation,\n                u_scale: scaleLocation,\n                u_resolution: resolutionUniformLocation,\n                u_color: colorUniformLocation,\n                a_position: positionAttributeLocation,\n                u_fade_max: fadeMaxLocation,\n                u_fade_min: fadeMinLocation\n            } = this.getProgramVarLocations(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES),\n            gl = this.#gl;\n\n        let verticesNumber = 0;\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\n        gl.uniform2f(translationLocation, x, y);\n        gl.uniform2f(scaleLocation, 1, 1);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        const triangles = this.#triangulatePolygon(vertices);\n        \n        const polygonVerticesNum = triangles.length;\n        if (polygonVerticesNum % 3 !== 0) {\n            Warning(WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, \"polygon boundaries vertices are not correct, skip drawing\");\n            return;\n        }\n        this.#bindPolygon(triangles);\n        verticesNumber += polygonVerticesNum / 2;\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(color);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n\n        this._render(verticesNumber, gl.TRIANGLES);\n    }\n\n    _bindLine = (renderObject, gl, pageData, program, vars) => {\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n            x = renderObject.x - xOffset,\n            y = renderObject.y - yOffset,\n            scale = [1, 1],\n            rotation = renderObject.rotation,\n            { \n                u_translation: translationLocation,\n                u_rotation: rotationRotation,\n                u_scale: scaleLocation,\n                u_resolution: resolutionUniformLocation,\n                u_color: colorUniformLocation,\n                a_position: positionAttributeLocation,\n                u_fade_max: fadeMaxLocation,\n                u_fade_min: fadeMinLocation\n            } = vars,\n            coords = renderObject.vertices,\n            fillStyle = renderObject.bgColor,\n            fade_min = renderObject.fade_min,\n            fadeLen = renderObject.radius,\n            lineWidth = this.#gameOptions.debug.boundaries.boundariesWidth;\n        let verticesNumber = 0;\n\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\n        gl.uniform2f(translationLocation, x, y);\n        gl.uniform2f(scaleLocation, 1, 1);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        this.#gl.bufferData(\n            this.#gl.ARRAY_BUFFER, \n            new Float32Array(coords),\n            this.#gl.STATIC_DRAW);\n\n        verticesNumber += coords.length / 2;\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(fillStyle);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        gl.lineWidth(lineWidth);\n\n        return Promise.resolve([0, gl.LINES]);\n    };\n    \n    _drawLines(linesArray, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {\n        const program = this.getProgram(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\n        const { u_translation: translationLocation,\n                u_rotation: rotationRotation,\n                u_scale: scaleLocation,\n                u_resolution: resolutionUniformLocation,\n                u_color: colorUniformLocation,\n                a_position: positionAttributeLocation,\n                u_fade_max: fadeMaxLocation,\n                u_fade_min: fadeMinLocation\n            } = this.getProgramVarLocations(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES),\n            gl = this.#gl;\n\n        let verticesNumber = 0;\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, 1, 1);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        this.#gl.bufferData(\n            this.#gl.ARRAY_BUFFER, \n            new Float32Array(linesArray),\n            this.#gl.STATIC_DRAW);\n\n        verticesNumber += linesArray.length / 2;\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(color);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        gl.lineWidth(lineWidth);\n        \n        this._render(verticesNumber, gl.LINES);\n    }\n\n    /**\n     * \n     * @param {DrawTiledLayer} renderLayer \n     * @param {GameStageData} pageData\n     * @returns {Promise<Array<Array>>}\n     */\n    #prepareRenderLayer(renderLayer, pageData) {\n        const INDEX_TOP_LINE = 0,\n            INDEX_RIGHT_LINE = 1,\n            INDEX_BOTTOM_LINE = 2,\n            INDEX_LEFT_LINE = 3;\n\n        const INDEX_X1 = 0,\n            INDEX_Y1 = 1,\n            INDEX_X2 = 2,\n            INDEX_Y2 = 3;\n        return new Promise((resolve, reject) => {\n            const tilemap = renderLayer.tilemap,\n                tilesets = renderLayer.tilesets,\n                tilesetImages = renderLayer.tilesetImages,\n                layerData = renderLayer.layerData,\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                tilewidth = dtwidth,\n                tileheight = dtheight,\n                [ settingsWorldWidth, settingsWorldHeight ] = pageData.worldDimensions,\n                [ canvasW, canvasH ] = pageData.canvasDimensions,\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\n                boundariesCalculations = this.#gameOptions.render.boundaries.realtimeCalculations,\n                setBoundaries = renderLayer.setBoundaries;\n                \n            let boundariesRowsIndexes = new Map(),\n                boundaries = [],\n                tileImagesData = [];\n\n            if (!layerData) {\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                reject();\n            }\n            \n            for (let i = 0; i < tilesets.length; i++) {\n                const tileset = tilesets[i].data,\n                    firstgid = tilesets[i].firstgid,\n                    nextTileset = tilesets[i + 1],\n                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions\n                    tilesetwidth = tileset.tilewidth,\n                    tilesetheight = tileset.tileheight,\n                    atlasImage = tilesetImages[i],\n                    //atlasWidth = atlasImage.width,\n                    //atlasHeight = atlasImage.height,\n                    atlasWidth = tileset.imagewidth,\n                    atlasHeight = tileset.imageheight,\n                    //atlasRows = atlasHeight / tileheight,\n                    atlasColumns = tileset.columns,\n                    layerCols = layerData.width,\n                    layerRows = layerData.height,\n                    worldW = tilewidth * layerCols,\n                    worldH = tileheight * layerRows,\n                    moduloTop = yOffset % tileheight,\n                    moduleLeft = xOffset % tilewidth,\n                    skipRowsTop = yOffset !== 0 ? Math.floor(yOffset / tileheight) : 0,\n                    skipColsLeft = xOffset !== 0 ? Math.floor(xOffset / tilewidth) : 0,\n                    // sometimes canvasW/H may be bigger than world itself\n                    screenRows = worldH > canvasH ? Math.ceil(canvasH / tileheight) + 1 : layerRows,\n                    screenCols = worldW > canvasW ? Math.ceil(canvasW / tilewidth) + 1 : layerCols,\n                    skipColsRight = layerCols - screenCols - skipColsLeft,\n                    cellSpacing = tileset.spacing,\n                    cellMargin = tileset.margin,\n\n                    verticesBufferData = [],\n                    texturesBufferData = [];\n                //@toDo: move this check upper level\n                if (setBoundaries) {\n                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\n                        Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\n                        pageData._setWorldDimensions(worldW, worldH);\n                    }\n                    // boundaries cleanups every draw cycles, we need to set world boundaries again\n                    if (this.#gameOptions.render.boundaries.mapBoundariesEnabled) {\n                        pageData._setMapBoundaries();\n                    }\n                }\n\n                let mapIndex = skipRowsTop * layerCols;\n                for (let row = 0; row < screenRows; row++) {\n                    mapIndex += skipColsLeft;\n                    let currentRowIndexes = new Map();\n                    for (let col = 0; col < screenCols; col++) {\n                        let tile = layerData.data[mapIndex];\n                        \n                        if ((tile >= firstgid) && (tile < nextgid)) {\n                            const mapPosX = col * dtwidth - moduleLeft,\n                                mapPosY = row * dtheight - moduloTop;\n\n                            tile -= firstgid;\n                            const colNum = tile % atlasColumns,\n                                rowNum = Math.floor(tile / atlasColumns),\n                                atlasPosX = colNum * tilesetwidth + (colNum * cellSpacing),\n                                atlasPosY = rowNum * tilesetheight + (rowNum * cellSpacing),\n                                vecX1 = mapPosX,\n                                vecY1 = mapPosY,\n                                vecX2 = mapPosX + tilesetwidth,\n                                vecY2 = mapPosY + tilesetheight,\n                                texX1 = (1 / atlasWidth) * atlasPosX,\n                                texY1 = (1 / atlasHeight) * atlasPosY,\n                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),\n                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);\n                            verticesBufferData.push(\n                                vecX1, vecY1,\n                                vecX2, vecY1,\n                                vecX1, vecY2,\n                                vecX1, vecY2,\n                                vecX2, vecY1,\n                                vecX2, vecY2);\n                            texturesBufferData.push(\n                                texX1, texY1,\n                                texX2, texY1,\n                                texX1, texY2,\n                                texX1, texY2,\n                                texX2, texY1,\n                                texX2, texY2\n                            );\n                            if (setBoundaries) {\n                                let rightLine = [ mapPosX + tilesetwidth, mapPosY, mapPosX + tilesetwidth, mapPosY + tilesetheight ],\n                                    bottomLine = [ mapPosX + tilesetwidth, mapPosY + tilesetheight, mapPosX, mapPosY + tilesetheight ],\n                                    topLine = [ mapPosX, mapPosY, mapPosX + tilesetwidth, mapPosY],\n                                    leftLine = [ mapPosX, mapPosY + tilesetheight, mapPosX, mapPosY ],\n                                    currentAddedCellIndexes = [null, null, null, null];\n                                \n                                const topRow = row !== 0 ? boundariesRowsIndexes.get(row - 1) : undefined;\n                                if (topRow ) {\n                                    const topCellIndexes = topRow.get(col);\n                                    if (topCellIndexes) {\n                                        //remove double lines from top\n                                        const bottomTopCellIndex = topCellIndexes[INDEX_BOTTOM_LINE],\n                                            bottomTopCell = boundaries[bottomTopCellIndex];\n                                        if (bottomTopCell) {\n                                            const bottomTopCellX1 = bottomTopCell[INDEX_X1],\n                                                bottomTopCellY1 = bottomTopCell[INDEX_Y1],\n                                                bottomTopCellX2 = bottomTopCell[INDEX_X2],\n                                                bottomTopCellY2 = bottomTopCell[INDEX_Y2],\n                                                topX1 = topLine[INDEX_X1],\n                                                topY1 = topLine[INDEX_Y1],\n                                                topX2 = topLine[INDEX_X2],\n                                                topY2 = topLine[INDEX_Y2];\n                                            \n                                            if (topX1 === bottomTopCellX2 && topY1 === bottomTopCellY2 &&\n                                                topX2 === bottomTopCellX1 && topY2 === bottomTopCellY1) {\n                                                boundaries[bottomTopCellIndex] = undefined;\n                                                topLine = undefined;\n                                            }\n                                        }\n\n                                        // merge line from top right\n                                        const rightTopCellIndex = topCellIndexes[INDEX_RIGHT_LINE],\n                                            rightTopCell = boundaries[rightTopCellIndex];\n                                        if (rightTopCell) {\n                                            const rightTopCellX1 = rightTopCell[INDEX_X1],\n                                                rightTopCellY1 = rightTopCell[INDEX_Y1],\n                                                rightTopCellX2 = rightTopCell[INDEX_X2],\n                                                rightX1 = rightLine[INDEX_X1],\n                                                rightX2 = rightLine[INDEX_X2];\n                                            if (rightTopCellX1 === rightX2 && rightTopCellX2 === rightX1) {\n                                                boundaries[rightTopCellIndex] = undefined;\n                                                rightLine[INDEX_X1] = rightTopCellX1;\n                                                rightLine[INDEX_Y1] = rightTopCellY1;\n                                            }\n                                        }\n                                        // merge line from top left\n                                        const leftTopCellIndex = topCellIndexes[INDEX_LEFT_LINE],\n                                            leftTopCell = boundaries[leftTopCellIndex];\n                                        if (leftTopCell) {\n                                            const leftTopCellX1 = leftTopCell[INDEX_X1],\n                                                leftTopCellX2 = leftTopCell[INDEX_X2],\n                                                leftTopCellY2 = leftTopCell[INDEX_Y2],\n                                                leftX1 = leftLine[INDEX_X1],\n                                                leftX2 = leftLine[INDEX_X2];\n                                            if (leftTopCellX1 === leftX2 && leftTopCellX2 === leftX1) {\n                                                boundaries[leftTopCellIndex] = undefined;\n                                                leftLine[INDEX_X2] = leftTopCellX2;\n                                                leftLine[INDEX_Y2] = leftTopCellY2;\n                                            }\n                                        }\n                                    }\n                                }\n                                const leftCellIndexes = col !== 0 ? currentRowIndexes.get(col - 1) : undefined;\n                                if (leftCellIndexes) {\n\n                                    //remove double lines from left\n                                    const rightLeftCellIndex = leftCellIndexes[INDEX_RIGHT_LINE],\n                                        rightLeftCell = boundaries[rightLeftCellIndex],\n                                        rightLeftCellX1 = rightLeftCell[INDEX_X1],\n                                        rightLeftCellY1 = rightLeftCell[INDEX_Y1],\n                                        rightLeftCellX2 = rightLeftCell[INDEX_X2],\n                                        rightLeftCellY2 = rightLeftCell[INDEX_Y2],\n                                        leftX1 = leftLine[INDEX_X1],\n                                        leftY1 = leftLine[INDEX_Y1],\n                                        leftX2 = leftLine[INDEX_X2],\n                                        leftY2 = leftLine[INDEX_Y2];\n\n                                    if (leftX1 === rightLeftCellX2 && leftY1 === rightLeftCellY2 &&\n                                        leftX2 === rightLeftCellX1 && leftY2 === rightLeftCellY1) {\n                                        boundaries[rightLeftCellIndex] = undefined;\n                                        leftLine = undefined;\n                                    }\n\n                                    //merge long lines from left top\n                                    const topLeftCellIndex = leftCellIndexes[INDEX_TOP_LINE],\n                                        topLeftCell = boundaries[topLeftCellIndex];\n                                    if (topLeftCell && topLine) {\n                                        const topLeftCellX1 = topLeftCell[INDEX_X1],\n                                            topLeftCellY1 = topLeftCell[INDEX_Y1],\n                                            topLeftCellY2 = topLeftCell[INDEX_Y2],\n                                            topY1 = topLine[INDEX_Y1],\n                                            topY2 = topLine[INDEX_Y2];\n                                        if (topLeftCellY1 === topY2 && topLeftCellY2 === topY1 ) {\n                                            boundaries[topLeftCellIndex] = undefined;\n                                            topLine[INDEX_X1] = topLeftCellX1;\n                                            topLine[INDEX_Y1] = topLeftCellY1;\n                                        }\n                                    }\n\n                                    // merge long lines from left bottom\n                                    const bottomLeftCellIndex = leftCellIndexes[INDEX_BOTTOM_LINE],\n                                        bottomLeftCell = boundaries[bottomLeftCellIndex];\n                                    if (bottomLeftCell) {\n                                        const bottomLeftCellY1 = bottomLeftCell[INDEX_Y1],\n                                            bottomLeftCellX2 = bottomLeftCell[INDEX_X2],\n                                            bottomLeftCellY2 = bottomLeftCell[INDEX_Y2],\n                                            bottomY1 = bottomLine[INDEX_Y1],\n                                            bottomY2 = bottomLine[INDEX_Y2];\n                                        if (bottomLeftCellY1 === bottomY2 && bottomLeftCellY2 === bottomY1 ) {\n                                            boundaries[bottomLeftCellIndex] = undefined;\n                                            //opposite direction\n                                            bottomLine[INDEX_X2] = bottomLeftCellX2;\n                                            bottomLine[INDEX_Y2] = bottomLeftCellY2;\n                                        }\n                                    }\n\n                                }\n\n                                if (topLine) {\n                                    boundaries.push(topLine);\n                                    currentAddedCellIndexes[INDEX_TOP_LINE] = boundaries.length - 1;\n                                }\n                                boundaries.push(rightLine);\n                                currentAddedCellIndexes[INDEX_RIGHT_LINE] = boundaries.length - 1;\n                                boundaries.push(bottomLine);\n                                currentAddedCellIndexes[INDEX_BOTTOM_LINE] = boundaries.length - 1;\n                                if (leftLine) {\n                                    boundaries.push(leftLine);\n                                    currentAddedCellIndexes[INDEX_LEFT_LINE] = boundaries.length - 1;\n                                }\n                                //save values indexes cols info\n                                currentRowIndexes.set(col, currentAddedCellIndexes);\n                            }\n\n                        }\n                        mapIndex++;\n                    }\n                    if (currentRowIndexes.size > 0) {\n                        //save values indexes rows info\n                        boundariesRowsIndexes.set(row, currentRowIndexes);\n                    }\n                    mapIndex += skipColsRight;\n                }\n                //this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tileset.name, renderLayer._maskId);\n                tileImagesData.push([new Float32Array(verticesBufferData), new Float32Array(texturesBufferData), tileset.name, atlasImage]);\n            }\n            \n            if (setBoundaries) {\n                // filter undefined value\n                const filtered = boundaries.filter(array => array);\n                pageData._addBoundariesArray(filtered);\n            }\n            resolve(tileImagesData);\n        });\n    }\n\n    #prepareRenderLayerOld(renderLayer, pageData) {\n        return new Promise((resolve, reject) => {\n            const tilemap = renderLayer.tilemap,\n                tilesets = renderLayer.tilesets,\n                tilesetImages = renderLayer.tilesetImages,\n                layerData = renderLayer.layerData,\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                setBoundaries = renderLayer.setBoundaries,\n                [ settingsWorldWidth, settingsWorldHeight ] = pageData.worldDimensions,\n                [ canvasW, canvasH ] = pageData.canvasDimensions,\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset;\n            \n            let tileImagesData = [];\n            if (!layerData) {\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                reject();\n            }\n            for (let i = 0; i <= tilesets.length - 1; i++) {\n                const tileset = tilesets[i].data,\n                    firstgid = tilesets[i].firstgid,\n                    nextTileset = tilesets[i + 1],\n                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions\n                    //tilesetImages = this.iLoader.getTilesetImageArray(tileset.name),\n                    tilewidth = tileset.tilewidth,\n                    tileheight = tileset.tileheight,\n                    //atlasRows = tileset.imageheight / tileheight,\n                    //atlasColumns = tileset.imagewidth / tilewidth,\n                    atlasColumns = tileset.columns,\n                    layerCols = layerData.width,\n                    layerRows = layerData.height,\n                    worldW = tilewidth * layerCols,\n                    worldH = tileheight * layerRows,\n                    visibleCols = Math.ceil(canvasW / tilewidth),\n                    visibleRows = Math.ceil(canvasH / tileheight),\n                    offsetCols = layerCols - visibleCols,\n                    offsetRows = layerRows - visibleRows,\n                    moduloTop = yOffset % tileheight,\n                    moduloLeft = xOffset % tilewidth,\n                    atlasImage = tilesetImages[i],\n                    atlasWidth = atlasImage.width,\n                    atlasHeight = atlasImage.height,\n                    cellSpacing = tileset.spacing,\n                    cellMargin = tileset.margin;\n                \n                let mapIndex = 0,\n                    verticesBufferData = [],\n                    texturesBufferData = [];\n\n                if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\n                    Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\n                    pageData._setWorldDimensions(worldW, worldH);\n                }\n                for (let row = 0; row < layerRows; row++) {\n                    for (let col = 0; col < layerCols; col++) {\n                        let tile = layerData.data[mapIndex];\n                        \n                        if (tile >= firstgid && (tile < nextgid)) {\n\n                            tile -= firstgid;\n                            const colNum = tile % atlasColumns,\n                                rowNum = Math.floor(tile / atlasColumns),\n                                atlasPosX = colNum * tilewidth + (colNum * cellSpacing),\n                                atlasPosY = rowNum * tileheight + (rowNum * cellSpacing),\n                                vecX1 = col * dtwidth - xOffset,\n                                vecY1 = row * dtheight - yOffset,\n                                vecX2 = vecX1 + tilewidth,\n                                vecY2 = vecY1 + tileheight,\n                                texX1 = 1 / atlasWidth * atlasPosX,\n                                texY1 = 1 / atlasHeight * atlasPosY,\n                                texX2 = texX1 + (1 / atlasWidth * tilewidth),\n                                texY2 = texY1 + (1 / atlasHeight * tileheight);\n                                \n                            verticesBufferData.push(\n                                vecX1, vecY1,\n                                vecX2, vecY1,\n                                vecX1, vecY2,\n                                vecX1, vecY2,\n                                vecX2, vecY1,\n                                vecX2, vecY2);\n                            texturesBufferData.push(\n                                texX1, texY1,\n                                texX2, texY1,\n                                texX1, texY2,\n                                texX1, texY2,\n                                texX2, texY1,\n                                texX2, texY2\n                            );\n\n                        }\n                        mapIndex++;\n                    }\n                }\n                const v = new Float32Array(verticesBufferData);\n                const t = new Float32Array(texturesBufferData);\n                tileImagesData.push([v, t, tileset.name, atlasImage]);\n            }\n            resolve(tileImagesData);\n        });\n    }\n\n    /**\n     * \n     * @param {DrawTiledLayer} renderLayer \n     * @param {GameStageData} pageData\n     * @returns {Promise<void>}\n     */\n    #prepareRenderLayerWM = (renderLayer, pageData) => {\n        return new Promise((resolve, reject) => {\n            const tilemap = renderLayer.tilemap,\n                tilesets = tilemap.tilesets,\n                tilesetImages = renderLayer.tilesetImages,\n                layerData = renderLayer.layerData,\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                offsetDataItemsFullNum = layerData.data.length,\n                offsetDataItemsFilteredNum = layerData.data.filter((item) => item !== 0).length,\n                setBoundaries = false, //renderLayer.setBoundaries,\n                [ settingsWorldWidth, settingsWorldHeight ] = pageData.worldDimensions,\n                //[ canvasW, canvasH ] = this.stageData.drawDimensions,\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset;\n            const tileImagesData = [];\n            // clear data\n            // this.layerDataFloat32.fill(0);\n            // set data for webgl processing\n            this.layerDataFloat32.set(layerData.data);\n            if (!layerData) {\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                reject();\n            }\n            \n            for (let i = 0; i < tilesets.length; i++) {\n                const tileset = tilesets[i].data,\n                    firstgid = tilesets[i].firstgid,\n                    nextTileset = tilesets[i + 1],\n                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions\n                    //tilesetImages = this.iLoader.getTilesetImageArray(tileset.name),\n                    tilewidth = tileset.tilewidth,\n                    tileheight = tileset.tileheight,\n                    //atlasRows = tileset.imageheight / tileheight,\n                    atlasColumns = tileset.columns,\n                    layerCols = layerData.width,\n                    layerRows = layerData.height,\n                    //visibleCols = Math.ceil(canvasW / tilewidth),\n                    //visibleRows = Math.ceil(canvasH / tileheight),\n                    //offsetCols = layerCols - visibleCols,\n                    //offsetRows = layerRows - visibleRows,\n                    worldW = tilewidth * layerCols,\n                    worldH = tileheight * layerRows,\n                    atlasImage = tilesetImages[i],\n                    atlasWidth = atlasImage.width,\n                    atlasHeight = atlasImage.height,\n                    items = layerRows * layerCols,\n                    dataCellSizeBytes = 4,\n                    vectorCoordsItemsNum = 12,\n                    texturesCoordsItemsNum = 12,\n                    vectorDataItemsNum = offsetDataItemsFilteredNum * vectorCoordsItemsNum,\n                    texturesDataItemsNum = offsetDataItemsFilteredNum * texturesCoordsItemsNum,\n                    cellSpacing = tileset.spacing,\n                    cellMargin = tileset.margin;\n                \n                if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\n                    Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\n                    pageData._setWorldDimensions(worldW, worldH);\n                }\n\n                //if (this.canvas.width !== worldW || this.canvas.height !== worldH) {\n                //    this._setCanvasSize(worldW, worldH);\n                //}\n                // boundaries cleanups every draw cycles, we need to set world boundaries again\n                if (this.#gameOptions.render.boundaries.mapBoundariesEnabled) {\n                    pageData._setMapBoundaries();\n                }\n                const itemsProcessed = this.calculateBufferData(dataCellSizeBytes, offsetDataItemsFullNum, vectorDataItemsNum, layerRows, layerCols, dtwidth, dtheight, tilewidth, tileheight, atlasColumns, atlasWidth, atlasHeight, xOffset, yOffset, firstgid, nextgid, cellSpacing, setBoundaries);\n                \n                const verticesBufferData = itemsProcessed > 0 ? this.layerDataFloat32.slice(offsetDataItemsFullNum, vectorDataItemsNum + offsetDataItemsFullNum) : [],\n                    texturesBufferData = itemsProcessed > 0 ? this.layerDataFloat32.slice(vectorDataItemsNum + offsetDataItemsFullNum, vectorDataItemsNum + texturesDataItemsNum + offsetDataItemsFullNum) : [];\n                    \n                tileImagesData.push([verticesBufferData, texturesBufferData, tileset.name, atlasImage]);\n                if (setBoundaries) {\n                    pageData._mergeBoundaries();\n                    renderLayer.setBoundaries = false;\n                }\n            }\n            resolve(tileImagesData);\n        });\n    };\n\n    /**\n     * \n     * @param {string} rgbaColor \n     * @returns {number[]}\n     */\n    #rgbaToArray (rgbaColor) {\n        return rgbaColor.replace(\"rgba(\", \"\").replace(\")\", \"\").split(\",\").map((/** @param {string} */item) => Number(item.trim()));\n    }\n\n    #triangulatePolygon(vertices) {\n        return this.#triangulate(vertices);\n    }\n\n    /**\n     * \n     * @param {Array<Array<number>>} polygonVertices \n     * @param {Array<number>} triangulatedPolygon \n     * @returns {Array<number>}\n     */\n    #triangulate (polygonVertices, triangulatedPolygon = []) {\n        const len = polygonVertices.length,\n            vectorsCS = (a, b, c) => crossProduct({x:c[0] - a[0], y: c[1] - a[1]}, {x:b[0] - a[0], y: b[1] - a[1]});\n\n        if (len <= 3) {\n            polygonVertices.forEach(vertex => {\n                triangulatedPolygon.push(vertex[0]);\n                triangulatedPolygon.push(vertex[1]);\n            });\n            return triangulatedPolygon;\n        }\n        const verticesSortedByY = [...polygonVertices].sort((curr, next) => next[1] - curr[1]);\n        const topVertexIndex = polygonVertices.indexOf(verticesSortedByY[0]),\n            startVertexIndex = topVertexIndex !== len - 1 ? topVertexIndex + 1 : 0;\n        \n        let processedVertices = polygonVertices,\n            processedVerticesLen = processedVertices.length,\n            skipCount = 0,\n            i = startVertexIndex;\n        \n        while(processedVertices.length > 2) {\n            // if overflowed, start from beginning\n            const currLen = processedVertices.length;\n            if (i >= currLen) {\n                i -= currLen;\n            }\n    \n            const prevVertex = i === 0 ? processedVertices[currLen - 1] : processedVertices[i - 1],\n                currentVertex = processedVertices[i],\n                nextVertex = currLen === i + 1 ? processedVertices[0] : processedVertices[i + 1];\n    \n            \n            const cs = vectorsCS(prevVertex, currentVertex, nextVertex);\n    \n            if (cs < 0) {\n                triangulatedPolygon.push(prevVertex[0]);\n                triangulatedPolygon.push(prevVertex[1]);\n                triangulatedPolygon.push(currentVertex[0]);\n                triangulatedPolygon.push(currentVertex[1]);\n                triangulatedPolygon.push(nextVertex[0]);\n                triangulatedPolygon.push(nextVertex[1]);\n                processedVertices = processedVertices.filter((val, index) => index !== i);\n            } else {\n                skipCount += 1;\n                if (skipCount > processedVerticesLen) {\n                    Exception(ERROR_CODES.DRAW_PREPARE_ERROR, \"Can't extract triangles. Probably vertices input is not correct, or the order is wrong\");\n                }\n            }\n            i++;\n        }\n        \n        return triangulatedPolygon;\n    }\n\n    #bindPolygon(vertices) {\n        this.#gl.bufferData(\n            this.#gl.ARRAY_BUFFER, \n            new Float32Array(vertices),\n            this.#gl.STATIC_DRAW);\n    }\n\n    #setSingleRectangle(width, height) {\n        const x1 = 0,\n            x2 = 0 + width,\n            y1 = 0,\n            y2 = 0 + height;\n        this.#gl.bufferData(this.#gl.ARRAY_BUFFER, \n            new Float32Array([\n                x1, y1,\n                x2, y1,\n                x1, y2,\n                x1, y2,\n                x2, y1,\n                x2, y2]), this.#gl.STATIC_DRAW);\n    }\n    /*------------------------------------\n     * End of Predefined Drawing programs\n     -------------------------------------*/\n\n    /**-----------------------------------\n     * Textures\n     ------------------------------------*/\n    #updateWebGlTexture(gl, texture, textureImage, textureNum = 0, useMipMaps = false) {\n        this.#bindTexture(gl, texture, textureNum);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\n        // already default value\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        // for textures not power of 2 (texts for example)\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST);\n        if (useMipMaps)\n            gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    #bindTexture(gl, texture, textureNum = 0) {\n        gl.activeTexture(gl.TEXTURE0 + textureNum);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n    }\n\n    #removeTexture(gl, texture) {\n        gl.deleteTexture(texture);\n    }\n    /*------------------------------------\n     * End Textures\n    --------------------------------------*/\n}","import { CONST } from \"./constants.js\";\n/**\n * Settings object, should be passed as a parameter to System.constructor().\n */\nexport class SystemSettings {\n    /**\n     * @hideconstructor\n     */\n    constructor(){}\n    /**\n     * DEBUG/PRODUCTION, for debug mode system Logger will show debug information in the console\n     */\n    static mode = CONST.MODE.DEBUG;\n\n    static gameOptions = {\n        // no other variants only WEBGL for now\n        library: CONST.LIBRARY.WEBGL,\n        optimization: CONST.OPTIMIZATION.NATIVE_JS.OPTIMIZED,\n        optimizationWASMUrl: \"/src/wa/calculateBufferDataWat.wasm\",\n        optimizationAssemblyUrl: \"/src/wa/calculateBufferDataAssembly.wasm\",\n        loadingScreen: {\n            backgroundColor:  \"rgba(128, 128, 128, 0.6)\",\n            loadingBarBg: \"rgba(128, 128, 128, 1)\",\n            loadingBarProgress: \"rgba(128, 128, 128, 0.2)\",\n        },\n        render: {\n            minCycleTime: 16, //ms which is ~60 FPS\n            cyclesTimeCalc: {\n                check: CONST.OPTIMIZATION.CYCLE_TIME_CALC.AVERAGES,\n                averageFPStime: 10000\n            },\n            boundaries: {\n                mapBoundariesEnabled: true,\n                realtimeCalculations: true,\n                wholeWorldPrecalculations: false\n            },\n            \n        },\n        debug: {\n            checkWebGlErrors: false,\n            debugMobileTouch: false,\n            boundaries: {\n                drawLayerBoundaries: false,\n                drawObjectBoundaries: false,\n                boundariesColor: \"rgba(224, 12, 21, 0.6)\",\n                boundariesWidth: 2\n            },\n            delayBetweenObjectRender: false, // 1 sec delay for debug proposes\n        }\n    };\n    \n\n    static network = {\n        address: \"https://gameserver.reslc.ru:9009\",\n        gatherRoomsInfoInterval: 5000\n    };\n\n    static canvasMaxSize = {\n        width: 1800,\n        height: 1800\n    };\n\n    static worldSize = {\n        width: 960,\n        height: 960\n    };\n\n    static defaultCanvasKey = \"default\";\n}","export const CONST = {\n    MODE: {\n        DEBUG: \"DEBUG\",\n        PRODUCTION: \"PRODUCTION\"\n    },\n    SCREENS: {},\n    AUDIO: {},\n    CONNECTION_STATUS: {\n        DISCONNECTED: \"disconnected\",\n        CONNECTED: \"connected\",\n        CONNECTION_LOST: \"connection lost\"\n    },\n    EVENTS: {\n        SYSTEM: {\n            START_PAGE:\"START_PAGE\",\n            STOP_PAGE: \"STOP_PAGE\",\n            RENDER: {\n                START: \"start\",\n                END: \"end\"\n            }\n        },\n        GAME: {\n            BOUNDARIES_COLLISION: \"BOUNDARIES_COLLISION\",\n            OBJECTS_COLLISION: \"OBJECTS_COLLISION\"\n        },\n        WEBSOCKET: {\n            SERVER_CLIENT: {\n                CONNECTION_STATUS_CHANGED: \"CONNECTION_STATUS_CHANGED\",\n                ROOMS_INFO: \"roomsInfo\",\n                CREATED: \"created\",\n                JOINED: \"joined\",\n                FULL: \"full\",\n                DISCONNECTED: \"disconnected\",\n                SERVER_MESSAGE: \"message\",\n                RESTARTED: \"restarted\",\n            },\n            CLIENT_SERVER: {\n                ROOMS_INFO_REQUEST: \"gatherRoomsInfo\",\n                CREATE_OR_JOIN: \"create or join\",\n                RESTART_REQUEST: \"restart\",\n                CLIENT_MESSAGE: \"message\"\n            }\n        }\n    },\n    WEBGL: {\n        DRAW_PROGRAMS: {\n            PRIMITIVES: \"drawPrimitives\",\n            IMAGES: \"drawImages\"\n        }\n    },\n    DRAW_TYPE: {\n        RECTANGLE: \"rect\",\n        CONUS: \"conus\",\n        CIRCLE: \"circle\",\n        POLYGON: \"polygon\",\n        LINE: \"line\",\n        TEXT: \"text\",\n        IMAGE: \"image\"\n    },\n    LAYERS: {\n        DEFAULT: \"default-view-layer\",\n        BOUNDARIES: \"boundaries-view-layer\"\n    },\n    GAME_OPTIONS: {},\n    LIBRARY: {\n        WEBGL: \"webgl\"\n    },\n    OPTIMIZATION: {\n        CYCLE_TIME_CALC: {\n            AVERAGES: \"AVERAGES\",\n            CURRENT: \"CURRENT\"\n        },\n        NATIVE_JS: {\n            NOT_OPTIMIZED: \"NOT_OPTIMIZED\",\n            OPTIMIZED: \"OPTIMIZED\"\n        },\n        WEB_ASSEMBLY: {\n            ASSEMBLY_SCRIPT: \"ASSEMBLY_SCRIPT\",\n            NATIVE_WAT: \"WASM\"\n        }\n    }\n};\n\nexport const ERROR_CODES = {\n    CREATE_INSTANCE_ERROR: \"CREATE_INSTANCE_ERROR\",\n    VIEW_NOT_EXIST: \"VIEW_NOT_EXIST\",\n    ELEMENT_NOT_EXIST: \"ELEMENT_NOT_EXIST\",\n    FILE_NOT_EXIST: \"FILE_NOT_EXIST\",\n    UNEXPECTED_INPUT_PARAMS: \"UNEXPECTED_INPUT_PARAMS\",\n    UNHANDLED_EXCEPTION: \"UNHANDLED_EXCEPTION\",\n    CANVAS_KEY_NOT_SPECIFIED: \"CANVAS_KEY_NOT_SPECIFIED\",\n    CANVAS_WITH_KEY_NOT_EXIST: \"CANVAS_WITH_KEY_NOT_EXIST\",\n    WRONG_TYPE_ERROR: \"WRONG_TYPE_ERROR\",\n    UNEXPECTED_WS_MESSAGE: \"UNEXPECTED_WS_MESSAGE\",\n    UNEXPECTED_PLAYER_ID: \"UNEXPECTED_PLAYER_ID\",\n    UNEXPECTED_BULLET_ID: \"UNEXPECTED_BULLET_ID\",\n    UNEXPECTED_EVENT_NAME: \"UNEXPECTED_EVENT_NAME\",\n    WEBGL_ERROR: \"WEBGL_ERROR\",\n    DRAW_PREPARE_ERROR: \"DRAW_PREPARE_ERROR\",\n    UNEXPECTED_TOUCH_AREA: \"UNEXPECTED TOUCH AREA\",\n    UNEXPECTED_METHOD_TYPE: \"UNEXPECTED METHOD TYPE\"\n};\n\nexport const WARNING_CODES =  {\n    FILE_LOADING_ISSUE: \"FILE_LOADING_ISSUE\",\n    ASSETS_NOT_READY: \"ASSETS_NOT_READY\",\n    NOT_FOUND: \"NOT_FOUND\",\n    NOT_TESTED: \"NOT_TESTED\",\n    WORLD_DIMENSIONS_NOT_SET: \"WORLD_DIMENSIONS_NOT_SET\",\n    INCORRECT_RENDER_TYPE: \"INCORRECT_RENDER_TYPE\",\n    UNHANDLED_DRAW_ISSUE: \"UNHANDLED_DRAW_ISSUE\",\n    UNEXPECTED_WORLD_SIZE: \"UNEXPECTED_WORLD_SIZE\",\n    AUDIO_ALREADY_REGISTERED: \"AUDIO_ALREADY_REGISTERED\",\n    AUDIO_NOT_REGISTERED: \"AUDIO_NOT_REGISTERED\",\n    AUDIO_NOT_LOADED: \"AUDIO_NOT_LOADED\",\n    UNKNOWN_DRAW_OBJECT: \"UNKNOWN_DRAW_OBJECT\",\n    METHOD_NOT_IMPLEMENTED: \"METHOD_NOT_IMPLEMENTED\",\n    POLYGON_VERTICES_NOT_CORRECT: \"POLYGON_VERTICES_NOT_CORRECT\",\n    MODULE_ALREADY_INSTALLED: \"MODULE_ALREADY_INSTALLED\",\n    DEPRECATED_PARAMETER: \"DEPRECATED_PARAMETER\",\n    NEW_BEHAVIOR_INTRODUCED: \"NEW_BEHAVIOR_INTRODUCED\",\n    TEXTURE_IMAGE_TEMP_OVERFLOW: \"TEXTURE_IMAGE_TEMP_OVERFLOW\"\n};","import { GameStage } from \"../base/GameStage.js\";\n\nexport class LoadingStage extends GameStage {\n    #total = 0;\n    #loaded = 0;\n    #barWidth = 0;\n    register() {\n        //this.iLoader.addImage(logoKey, \"./images/icon.png\");\n    }\n\n    init() {\n        const [w, h] = this.stageData.canvasDimensions,\n            barWidth = w/3,\n            barHeight = 20;\n        //this.logo = this.draw.image(w/2, h/2, 300, 200, logoKey);\n        this.background = this.draw.rect(0, 0, w, h, this.systemSettings.gameOptions.loadingScreen.backgroundColor);  \n        this.loadingBarBg = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarBg);\n        this.loadingBarProgress = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarProgress);\n        this.text = this.draw.text(w/2 - 20, h/2 - 2 * barHeight, \"JsGE\", \"24px sans-serif\", \"black\");\n        this.#barWidth = barWidth;\n    }\n\n    _progress = (loaded) => {\n        const widthPart = this.#barWidth / this.#total;\n\n        this.#loaded = loaded;\n        \n        this.loadingBarProgress.width = widthPart * this.#loaded;\n    };\n\n    start(options) {\n        this.#total = options.total;\n    }\n\n    // a workaround for checking upload progress before render\n    get iLoader() {\n        return ({filesWaitingForUpload:0});\n    }\n} ","import { System } from \"./base/System.js\";\nimport { GameStage } from \"./base/GameStage.js\";\nimport { DrawImageObject } from \"./base/DrawImageObject.js\";\nimport { ISystemAudio } from \"./base/ISystemAudio.js\";\nimport * as Primitives from \"./base/Primitives.js\";\nimport { SystemSettings } from \"./configs.js\";\nimport { CONST } from \"./constants.js\";\nimport * as utils from \"./utils.js\";\n\nexport { System, SystemSettings, CONST, GameStage, DrawImageObject, ISystemAudio, Primitives, utils };","import { Vector } from \"./base/Primitives.js\";\n\nfunction isMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent) ;\n}\n\nfunction isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\nfunction pointToCircleDistance(x, y, circle) {\n    const pointToCircleCenterDistance = new Vector(x, y, circle.x, circle.y).length;\n    return pointToCircleCenterDistance - circle.r;\n}\n\nfunction countClosestTraversal(line, sight) {\n    const x1 = sight.x1,\n        y1 = sight.y1,\n        x2 = sight.x2,\n        y2 = sight.y2;\n    const x3 = line.x1,\n        y3 = line.y1,\n        x4 = line.x2,\n        y4 = line.y2;\n\n    const r_px = x1,\n        r_py = y1,\n        r_dx = x2-x1,\n        r_dy = y2-y1;\n\n    const s_px = x3,\n        s_py = y3,\n        s_dx = x4-x3,\n        s_dy = y4-y3;\n\n    const r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy),\n        s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);\n    if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){\n        return null;\n    }\n\n    const T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx),\n        T1 = (s_px+s_dx*T2-r_px)/r_dx;\n\n    if(T1<0 || isNaN(T1)) return null;\n    if(T2<0 || T2>1) return null;\n\n    return {\n        x: r_px+r_dx*T1,\n        y: r_py+r_dy*T1,\n        p: T1\n    };\n}\n\n/**\n * \n * @param {{x1:number, y1:number, x2:number, y2:number}} line1 \n * @param {{x1:number, y1:number, x2:number, y2:number}} line2 \n * @returns {{x:number, y:number, p:number} | undefined}\n * @ignore\n */\nfunction countClosestTraversal2(line1, line2) {\n    const x1 = line2.x1,\n        y1 = line2.y1,\n        x2 = line2.x2,\n        y2 = line2.y2;\n    const x3 = line1.x1,\n        y3 = line1.y1,\n        x4 = line1.x2,\n        y4 = line1.y2;\n\n    const det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    // lines are parallel, or coincident\n    if (det === 0){\n        return;\n    }\n    let x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / det;\n    let y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / det;\n    const point = {x, y};\n    \n    if (isPointOnTheLine(point, line1, 0.0000000000001) && isPointOnTheLine(point, line2, 0.0000000000001)) {\n        const p = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));\n        return {x, y, p};\n    } else {\n        return;\n    }\n}\n\nfunction angle_2points(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1);\n}\n\nfunction angle_3points(a, b, c) {\n    const x1 = a.x - b.x,\n        x2 = c.x - b.x,\n        y1 = a.y - b.y,\n        y2 = c.y - b.y,\n        d1 = Math.sqrt(x1 * x1 + y1 * y1),\n        d2 = Math.sqrt(x2 * x2 + y2 * y2);\n    //console.log(\"angle: \", (Math.acos((x1* x2 + y1 * y2) / (d1 * d2))* 180) / Math.PI);\n    return Math.acos((x1* x2 + y1 * y2) / (d1 * d2));\n}\n\nfunction dotProductWithAngle(lenA, lenB, angle) {\n    return lenA * lenB * Math.cos(angle);\n}\n\nfunction dotProduct(vec1, vec2) {\n    return vec1.x * vec2.x + vec1.y * vec2.y;\n}\n\nfunction crossProduct(a, b) {\n    return (a.x * b.y - b.x * a.y);\n}\n\nfunction isPointOnTheLine(point, line, m_error = 0) {\n    return  (\n        ((point.x >= (line.x1 - m_error)) && (point.x <= (line.x2 + m_error))) || \n                ((point.x <= (line.x1 + m_error)) && (point.x >= (line.x2 - m_error)))\n    ) && (\n        ((point.y >= (line.y1 - m_error)) && (point.y <= (line.y2 + m_error))) || \n                ((point.y <= (line.y1 + m_error)) && (point.y >= (line.y2 - m_error)))\n    );\n}\n\nfunction countDistance(obj1, obj2) {\n    return new Vector(obj1.x, obj1.y, obj2.x, obj2.y).length;\n}\n\nfunction isLineShorter(line1, line2) {\n    return (new Vector(line1.x1, line1.y1, line1.x2, line1.y2)).length < (new Vector(line2.x1, line2.y1, line2.x2, line2.y2)).length;\n}\n\nfunction isPointLineIntersect(point, line) {\n    const lineL = new Vector(line.x1, line.y1, line.x2, line.y2).length,\n        lengthAB = new Vector(line.x1, line.y1, point.x, point.y).length + new Vector(line.x2, line.y2, point.x, point.y).length;\n\n    if (lengthAB <= lineL + 0.2) {\n        //Logger.debug(\"point to line intersect. line len: \" + lineL + \", line AB len: \" + lengthAB);\n        return true;\n    }\n    return false;\n}\n\n/**\n * \n * @param {Array<Array<number>>} polygon \n * @param {{x1:number, y1:number, x2:number, y2:number}} line \n * @returns {{x:number, y:number, p:number} | null}\n * @ignore\n */\nfunction isPolygonLineIntersect(polygon, line) {\n    const len = polygon.length;\n    for (let i = 0; i < len; i+=1) {\n        let curr = polygon[i],\n            next = polygon[i+1];\n        //if next item not exist and current is not first\n        if (!next) {\n            // if current vertex is not the first one\n            if (!(curr[0] === polygon[0][0] && curr[1] === polygon[0][1])) {\n                next = polygon[0];\n            } else {\n                continue;\n            }\n        }\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\n        const intersection = countClosestTraversal2(edge, line);\n        if (intersection) {\n            return intersection;\n        }\n    }\n    if (polygon[len-1][0] !== polygon[0][0] && polygon[len-1][1] !== polygon[0][1]) {\n        //check one last item\n        const curr = polygon[len - 1],\n            next = polygon[0];\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\n        const intersection = countClosestTraversal2(edge, line);\n        if (intersection) {\n            return intersection;\n        }\n    }\n    return null;\n}\n\nfunction isPointPolygonIntersect(/*x, y, polygon*/) {\n    //const vertices = polygon.vertices;\n\n    return false;\n}\n\nfunction isPointRectIntersect(x, y, rect) {\n    if (x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.y + rect.height) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isPointCircleIntersect(x, y, circle) {\n    const radius = circle.width,\n        lineToCircleCenter = new Vector(x, y, circle.x, circle.y),\n        pointCircleLineLength = lineToCircleCenter.length;\n    if (pointCircleLineLength < radius)\n        return true;\n    else\n        return false;\n}\n\nfunction isCircleLineIntersect(x, y, r, line) {\n    const x1 = line.x1,\n        y1 = line.y1,\n        x2 = line.x2,\n        y2 = line.y2,\n        vec1 = {x: x1 - x, y: y1-y}, //new Vector(x, y, x1, y1),\n        vec2 = {x: x2 - x, y: y2-y}, //new Vector(x, y, x2, y2),\n        vec3 = {x: x2 - x1, y: y2-y1}, //new Vector(x1 ,y1, x2, y2),\n        vec4 = {x: x1 - x2, y: y1-y2}, //new Vector(x2, y2, x1, y1),\n        vec3Len = Math.sqrt(Math.pow(vec3.x, 2) + Math.pow(vec3.y, 2)),//vec3.length,\n        dotP1 = dotProduct(vec1, vec4),\n        dotP2 = dotProduct(vec2, vec3);\n        // checks if the line is inside the circle,\n        // max_dist = Math.max(vec1Len, vec2Len);\n    let min_dist;\n    \n    if (dotP1 > 0 && dotP2 > 0) {\n        min_dist = crossProduct(vec1,vec2)/vec3Len;\n        if (min_dist < 0) {\n            min_dist *= -1;\n        }\n    } else {\n        min_dist = Math.min(vec1.length, vec2.length);\n    }\n    \n    if (min_dist <= r) { // && max_dist >= r) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction generateUniqId() {\n    return Math.round(Math.random() * 1000000); \n}\n\nfunction verticesArrayToArrayNumbers(array) {\n    const len = array.length,\n        numbers = [];\n    for (let i = 0; i < len; i++) {\n        const vertex = array[i];\n        numbers.push([vertex.x, vertex.y]);\n    }\n    return numbers;\n}\n\nexport { \n    isMobile, \n    isSafari, \n    pointToCircleDistance, \n    countClosestTraversal, \n    countClosestTraversal2,\n    angle_2points,\n    angle_3points,\n    dotProductWithAngle,\n    dotProduct,\n    crossProduct,\n    isPointOnTheLine,\n    isLineShorter,\n    isPointLineIntersect,\n    isPointPolygonIntersect,\n    isPointRectIntersect,\n    isPointCircleIntersect,\n    isPolygonLineIntersect,\n    isCircleLineIntersect,\n    generateUniqId,\n    verticesArrayToArrayNumbers,\n    countDistance };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.es6.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"jsge:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\t\tscript.type = \"module\";\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (typeof import.meta.url === \"string\") scriptUrl = import.meta.url\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkjsge\"] = self[\"webpackChunkjsge\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.js\");\n",""],"names":[],"sourceRoot":""}