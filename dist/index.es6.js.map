{"version":3,"file":"index.es6.js","mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,+BAA+B;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,iBAAiB;AACjB;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B;AAC3E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,OAAO;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,0DAA0D;AAChJ;AACA;AACA;AACA;AACA,gFAAgF,OAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACh7B+C;AACQ;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,+BAA+B,gEAAe;AACrD;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,2DAAgB;AAC9B;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9C+C;AACQ;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,8BAA8B,gEAAe;AACpD;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,0DAAe;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5EsD;AACM;AACL;AACQ;AACV;AACrD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,8BAA8B,gEAAe;AACpD;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,0DAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,uBAAuB,2BAA2B,IAAI;AACtE,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,YAAY,wDAAS,CAAC,8EAAmC,4EAA4E,2BAA2B;AAChK;AACA,mCAAmC,8DAAc;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvT+C;AACQ;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,yDAAc;AAC5B;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChC+C;AACQ;;AAEvD;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,gCAAgC,gEAAe;AACtD;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,4DAAiB;AAC/B;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/B+C;AACQ;;AAEvD;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,8DAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1D+C;AACR;;AAEvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU,2DAAoB;AAC9B;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,eAAe,8BAA8B,mBAAmB,GAAG;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,wEAAiC;AACpD,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxQuD;AACX;AACgB;AAChB;AACmB;;AAE/D;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,yDAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,mBAAmB,qDAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,2DAA2D,0BAA0B,GAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,0EAA+B;AACrD;AACA;AACA;;;;;;;;;;;;;;;;;;ACvOsD;AACC;AACQ;AACU;AACzE;AACA;AACA,SAAS,yBAAyB;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8DAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,8BAA8B;AAC9B;AACA,+DAA+D;AAC/D,8BAA8B;AAC9B;AACA,yFAAyF;AACzF,8BAA8B,OAAO;AACrC;AACA,kEAAkE;AAClE;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,gCAAgC,iFAAqB;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,+BAA+B,GAAG;AACxD,iBAAiB,OAAO,2BAA2B;AACnD;AACA;AACA,mDAAmD,4DAA4D;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7EO;AACP;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjGwD;AACA;AACE;AACA;AACF;AACM;AACF;AACJ;AACE;AACP;AACC;AACS;AACU;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,iEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,iEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA,iCAAiC,mEAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,qEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO,mBAAmB,KAAK,SAAS,GAAG;AAC1D,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,YAAY,yDAAS,CAAC,0EAA8B;AACpD;AACA;AACA,iCAAiC,mEAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,iEAAc;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO,mBAAmB,GAAG;AAC5C,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,iCAAiC,uEAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA,wCAAwC;AACxC;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA,+BAA+B,iEAAc;AAC7C;AACA,YAAY,uDAAO,CAAC,gFAAoC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvNwD;AACZ;;AAErC;AACP;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;;AAEA;AACA,6BAA6B,+EAAoC;AACjE;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNwE;AACrB;AACC;AACmB;AACZ;AACC;AACF;AACA;AACF;AACM;AACN;AACA;AACjB;AACU;AACF;AACwK;AAC3K;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,8BAA8B,4DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,gFAAqC;AACzD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAc;AAC/B,iBAAiB,8DAAmB;AACpC,iBAAiB,0DAAe;AAChC,iBAAiB,0DAAe;AAChC;AACA;AACA,kBAAkB;AAClB;AACA;AACA,iBAAiB,2DAAgB;AACjC,gBAAgB,sDAAO,CAAC,+EAAoC;AAC5D;AACA,iBAAiB,yDAAc;AAC/B,gBAAgB,sDAAO,CAAC,+EAAoC;AAC5D;AACA;AACA,gBAAgB,sDAAO,CAAC,4EAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,eAAe,wBAAwB;AACvC,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAc;AAC/B,iBAAiB,8DAAmB;AACpC,iBAAiB,0DAAe;AAChC,iBAAiB,0DAAe;AAChC;AACA;AACA,kBAAkB;AAClB;AACA;AACA,iBAAiB,2DAAgB;AACjC,gBAAgB,sDAAO,CAAC,+EAAoC;AAC5D;AACA,iBAAiB,yDAAc;AAC/B,gBAAgB,sDAAO,CAAC,+EAAoC;AAC5D;AACA;AACA,gBAAgB,sDAAO,CAAC,4EAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAc;AAC/B,iBAAiB,8DAAmB;AACpC,iBAAiB,0DAAe;AAChC,iBAAiB,0DAAe;AAChC;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA,iBAAiB,yDAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,qBAAqB,yDAAc;AACnC,qBAAqB,8DAAmB;AACxC,qBAAqB,0DAAe;AACpC,qBAAqB,0DAAe;AACpC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,qBAAqB,2DAAgB;AACrC;AACA;AACA,qBAAqB,yDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,iEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAM;AAC9B;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,kEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAM;AACjC,0BAA0B,yDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kCAAkC,iEAAqB,+BAA+B,eAAe;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA,gCAAgC,oEAAwB,WAAW,gCAAgC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,gCAAgC,kEAAsB,UAAU,gCAAgC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,sBAAsB;AACrC,eAAe,QAAQ;AACvB,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kCAAkC,kEAAsB,gCAAgC,eAAe;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA,gCAAgC,qEAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA,gCAAgC,mEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC7pBgD;AACP;AACzC;AACwD;AACE;AACE;AACF;AACF;AACM;AACN;AACA;AACxD;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA,kCAAkC,iCAAiC;AACnE,kCAAkC,6CAA6C;AAC/E,kCAAkC,6CAA6C;AAC/E,kCAAkC,iCAAiC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzrBuC;;AAEvC;AACA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oEAAoE;AACnF,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1DqD;AACV;AACN;AACiB;AACtD,WAAW,SAAS;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;;AAEA;AACA,QAAQ,mOAA0B;AAClC,4EAA4E,sBAAsB;AAClG;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,kGAAuD;AACjF;;AAEA;AACA,0BAA0B,8FAAmD;AAC7E;;AAEA;AACA,0BAA0B,8FAAmD;AAC7E;;AAEA;AACA,QAAQ,oDAAY;AACpB,qCAAqC,yGAA8D;AACnG;;AAEA;AACA,QAAQ,oDAAY;AACpB,qCAAqC,yGAA8D;AACnG;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,8FAAmD;AAC9F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,0FAA+C;AAC1F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,uFAA4C,GAAG,UAAU;AACpG;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,oFAAyC,GAAG,KAAK;AAC5F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,sFAA2C,GAAG,UAAU;AACnG;;AAEA;AACA,+BAA+B,+DAAW,CAAC,4FAAiD,GAAG,SAAS;AACxG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC/IoD;AACS;AACR;AACN;AACI;AACoB;AACvE,WAAW,sBAAsB;AACO;AACsE;AACgC;AAC3B;AACtE;AAC7C;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8DAAW;AAC3C;AACA;AACA,6DAA6D,qFAA0C;AACvG,6DAA6D,0FAA+C;AAC5G;AACA;AACA;AACA;AACA;AACA,uDAAuD,2EAAgC,EAAE,wEAAe,EAAE,0EAAiB,EAAE,oEAAW,EAAE,sEAAa;AACvJ;AACA;AACA,uDAAuD,+EAAoC,EAAE,mFAAsB,EAAE,qFAAwB,EAAE,+EAAkB,EAAE,iFAAoB;AACvL;AACA;AACA,uDAAuD,6EAAkC,EAAE,0EAAgB,EAAE,4EAAkB,EAAE,sEAAY,EAAE,wEAAc;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uCAAuC;AACtD,iBAAiB;AACjB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oEAAoE;AACnF,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAmB;AAChC;AACA,2CAA2C,sDAAU;AACrD;AACA,sDAAsD,2EAAgC,kBAAkB,2EAAgC;AACxI,sDAAsD,yEAA8B,kBAAkB,yEAA8B;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2EAAgC,YAAY,2EAAgC;AACjI,qDAAqD,yEAA8B,YAAY,yEAA8B;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAO,CAAC,6EAAkC;AAClE;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClToE;AAChB;AACX;AACQ;AACF;AACwB;AACZ;AAChB;AACJ;AACM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB,SAAS,iBAAiB;AAC1B;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,mBAAmB,6EAAa;AAChC;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,6BAA6B,oEAAiB;AAC9C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;AACA,yCAAyC,0DAAY;AACrD,4EAA4E,kDAAQ;AACpF,4BAA4B,gDAAO;AACnC,+BAA+B,sDAAU;AACzC;AACA;AACA,uCAAuC,2EAAgC,kBAAkB,2EAAgC;AACzH,uCAAuC,yEAA8B,kBAAkB,yEAA8B;AACrH;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,2EAAgC;AAC1D,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAA8B;AACxD;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,qEAA0B;AAChD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,sBAAsB,wEAA6B;AACnD;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,sEAA2B;AACjD;AACA;AACA;;;;;;;;;;;;;;;;;ACjOwE;AACxB;AACP;;AAEzC;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,yEAA8B;AAClD;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,sDAAO,CAAC,6EAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,yEAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,sDAAO,CAAC,6EAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7F+C;AACP;;AAEjC;AACP;AACA,YAAY,4DAAmB,KAAK,2DAAgB;AACpD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACR+C;AACI;AACX;AACC;AACO;AAChD;AACwD;AACE;AACE;AACF;AACF;AACM;AACN;AACA;AACH;AACE;AACvD;AACoC;AACpC;AACA;AACA;AACA;AACA,SAAS,eAAe;AACxB;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAe;AACnD;AACA;AACA;AACA;AACA,6EAA6E,sFAA2C;AACxH;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G,qFAA0C;AACtJ;AACA,kBAAkB,2EAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB,yEAA8B;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,sDAAO,CAAC,6EAAkC;AAC9D,iBAAiB;AACjB,cAAc;AACd,gBAAgB,sDAAO,CAAC,6EAAkC;AAC1D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8IAA8I;AAC7J,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,sEAA8B;AACjE,oDAAoD,8CAA8C;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChVA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5F8C;AACH;AACJ;AACQ;;AAEU;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,gDAAO;;AAEnC;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,iEAAY;;AAExD;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,oBAAoB;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjGA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxCA;AACA;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnEkF;AACpC;AACO;AACD;AACW;AAC/D;AACyD;AACI;AACF;AACF;AACM;AACN;AACA;AACzD;AAC0E;AACnC;AACvC;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc,aAAa,2CAA2C;AACtE;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,8EAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAmB,kBAAkB,6EAAkC;AAC1G,mCAAmC,uEAAmB,wBAAwB,+EAAoC;AAClH,mCAAmC,4EAAsB,wBAAwB,+EAAoC;AACrH,mCAAmC,0EAAqB,mBAAmB,+EAAoC;AAC/G,mCAAmC,wEAAoB,mBAAmB,+EAAoC;AAC9G,mCAAmC,sEAAmB,wBAAwB,6EAAkC;AAChH,mCAAmC,sEAAmB,kBAAkB,+EAAoC;AAC5G,mCAAmC,0DAAe,mBAAmB,6EAAkC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iEAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,sDAAO,CAAC,8EAAmC;AAC3D;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uDAAuD,qFAA0C;AACjG;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2CAA2C;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,kEAAuB,0CAA0C,KAAK;AAChG;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB,+CAA+C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB,qBAAqB,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAmB;AAChC;AACA;AACA;AACA,aAAa,yDAAc;AAC3B;AACA,aAAa,2DAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4DAAiB;AAC9B;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,qFAA0C,cAAc,gBAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oEAA4B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,yEAA8B;AACxD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAkB,CAAC,0DAAkB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAAgB;AACrD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA,6BAA6B,iEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iBAAiB,qFAA0C;AAC3D;AACA;AACA,iBAAiB,0FAA+C;AAChE,iBAAiB,qFAA0C;AAC3D;AACA;AACA,iBAAiB,iFAAsC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uBAAuB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uEAAgB;AACjE;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uEAAgB;AACzD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+EAAoC;AAC5E,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B,+EAAoC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+EAAoC;AAC5E,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B,+EAAoC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,kEAAkE;AACjF,eAAe,SAAS;AACxB;AACA;AACA,uDAAuD,qEAAqE;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sDAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,qDAAqD;AACrD,8CAA8C;AAC9C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,2FAA2F,QAAQ;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC,uDAAY,EAAE,8BAA8B,GAAG,8BAA8B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,oBAAoB,sDAAO,CAAC,0EAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACj/DuC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAgB;AAClC;AACA;AACA;AACA,iBAAiB,8DAAmB;AACpC,sBAAsB,iFAAsC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uBAAuB,sFAA2C;AAClE;AACA,aAAa;AACb,0BAA0B;AAC1B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACnFO;AACP;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,oBAAoB;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjIiD;;AAE1C,2BAA2B,yDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1C0C;AACM;AACe;AACT;AACA;AACR;AACP;AACH;;AAEkE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTrD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0DAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6CAA6C;AACzD,YAAY,6CAA6C;AACzD,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAM;AACrB;AACA;AACA;AACA,gBAAgB,0DAAM,wDAAwD,0DAAM;AACpF;AACA;AACA;AACA,sBAAsB,0DAAM;AAC5B,uBAAuB,0DAAM,kDAAkD,0DAAM;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,6CAA6C;AACzD,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,GAAG,+DAA+D;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,+BAA+B;AAC3C,aAAa;AACb;AACA;AACA;AACA,iCAAiC,0DAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,gBAAgB,mBAAmB;AACnC,gBAAgB,qBAAqB;AACrC,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,yBAAyB;AACzB;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,YAAY,+BAA+B;AAC3C,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,gCAAgC,gDAAgD;AAChF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,gBAAgB;AAC5B,cAAc;AACd;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA,uCAAuC,kBAAkB;AACzD;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;SCniBA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;;;;UCzBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,EAAE;UACF;;;;;UCRA;UACA;UACA;UACA;UACA;;;;;UCJA;;;;;UCAA;UACA;UACA;UACA;UACA,uBAAuB,4BAA4B;UACnD;UACA;UACA;UACA,iBAAiB,oBAAoB;UACrC;UACA,mGAAmG,YAAY;UAC/G;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,mEAAmE,iCAAiC;UACpG;UACA;UACA;UACA;;;;;UCxCA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;UCNA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;UCNA;;UAEA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA;UACA,iCAAiC;;UAEjC;UACA;UACA;UACA,KAAK;UACL,eAAe;UACf;UACA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM;UACN;UACA;UACA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM,qBAAqB;UAC3B;UACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;UACA;UACA;;;;;SErFA;SACA;SACA;SACA","sources":["webpack://jsge/./modules/assetsm/src/AssetsManager.js","webpack://jsge/./src/base/2d/DrawCircleObject.js","webpack://jsge/./src/base/2d/DrawConusObject.js","webpack://jsge/./src/base/2d/DrawImageObject.js","webpack://jsge/./src/base/2d/DrawLineObject.js","webpack://jsge/./src/base/2d/DrawPolygonObject.js","webpack://jsge/./src/base/2d/DrawRectObject.js","webpack://jsge/./src/base/2d/DrawShapeObject.js","webpack://jsge/./src/base/2d/DrawTextObject.js","webpack://jsge/./src/base/2d/DrawTiledLayer.js","webpack://jsge/./src/base/2d/Primitives.js","webpack://jsge/./src/base/AnimationEvent.js","webpack://jsge/./src/base/DrawObjectFactory.js","webpack://jsge/./src/base/Events/SystemEvent.js","webpack://jsge/./src/base/Exception.js","webpack://jsge/./src/base/GameStage.js","webpack://jsge/./src/base/GameStageData.js","webpack://jsge/./src/base/IExtension.js","webpack://jsge/./src/base/INetwork.js","webpack://jsge/./src/base/IRender.js","webpack://jsge/./src/base/ISystem.js","webpack://jsge/./src/base/ISystemAudio.js","webpack://jsge/./src/base/Logger.js","webpack://jsge/./src/base/RenderLoop.js","webpack://jsge/./src/base/RenderLoopDebug.js","webpack://jsge/./src/base/System.js","webpack://jsge/./src/base/Temp/ImageTempStorage.js","webpack://jsge/./src/base/Temp/TiledLayerTempStorage.js","webpack://jsge/./src/base/WebGl/ImagesDrawProgram.js","webpack://jsge/./src/base/WebGl/ImagesDrawProgramM.js","webpack://jsge/./src/base/WebGl/PrimitivesDrawProgram.js","webpack://jsge/./src/base/WebGl/WebGlEngine.js","webpack://jsge/./src/configs.js","webpack://jsge/./src/constants.js","webpack://jsge/./src/design/LoadingStage.js","webpack://jsge/./src/index.js","webpack://jsge/./src/utils.js","webpack://jsge/webpack/bootstrap","webpack://jsge/webpack/runtime/define property getters","webpack://jsge/webpack/runtime/ensure chunk","webpack://jsge/webpack/runtime/get javascript chunk filename","webpack://jsge/webpack/runtime/hasOwnProperty shorthand","webpack://jsge/webpack/runtime/load script","webpack://jsge/webpack/runtime/make namespace object","webpack://jsge/webpack/runtime/publicPath","webpack://jsge/webpack/runtime/jsonp chunk loading","webpack://jsge/webpack/before-startup","webpack://jsge/webpack/startup","webpack://jsge/webpack/after-startup"],"sourcesContent":["\r\nconst PROGRESS_EVENT_TYPE = {\r\n    loadstart: \"loadstart\", \r\n    progress: \"progress\", \r\n    abort: \"abort\", \r\n    error: \"error\", \r\n    load: \"load\", \r\n    timeout: \"timeout\"\r\n}\r\n\r\nconst ERROR_MESSAGES = {\r\n    // Critical\r\n    LOADER_NOT_REGISTERED: \" loader is not registered.\",\r\n    RECURSION_ERROR: \"Too much recursion. Stop iteration.\",\r\n    NOT_CORRECT_METHOD_TYPE: \"uploadMethod should be instance of Promise and return upload result value\",\r\n    XML_FILE_EXTENSION_INCORRECT: \" AtlasXML file extension is incorrect, only .xml file supported\",\r\n    TILESET_FILE_EXTENSION_INCORRECT: \" tileset file extension is not correct, only .tsj, .json, .tsx, .xml files are supported\",\r\n    TILEMAP_FILE_EXTENSION_INCORRECT: \" tilemap file extension is not correct, only .tmj, .json, .tmx, .xml files are supported\",\r\n    INPUT_PARAMS_ARE_INCORRECT: \" fileKey and url should be provided\",\r\n    // Non critical\r\n    ATLAS_IMAGE_LOADING_FAILED: \"Error loading atlas image \",\r\n    TILESET_LOADING_FAILED: \"Error loading related tileset \",\r\n    TILEMAP_LOADING_FAILED: \"Error loading tilemap \",\r\n    AUDIO_LOADING_FAILED: \"Error loading audio \",\r\n    IMAGE_LOADING_FAILED: \"Error loading image \",\r\n    XML_FORMAT_INCORRECT: \" XML format is not correct.\",\r\n}\r\n\r\nconst FILE_FORMAT = {\r\n    JSON: \"JSON\",\r\n    XML: \"XML\",\r\n    UNKNOWN: \"UNKNOWN\"\r\n}\r\n\r\nclass Loader {\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #fileType;\r\n    /**\r\n     * @type { (...args: any[]) => Promise<void> }\r\n     */\r\n    #uploadMethod;\r\n    /**\r\n     * name: url\r\n     * @type { Map<string, string[]>}\r\n     */\r\n    #loadingQueue = new Map();\r\n    /**\r\n     * name: file\r\n     * @type { Map<string, any>}\r\n     */\r\n    #store = new Map();\r\n    /**\r\n     * \r\n     * @param {string} name \r\n     * @param {Function} uploadMethod \r\n     */\r\n\r\n    constructor(name, uploadMethod) {\r\n        this.#fileType = name;\r\n        this.#uploadMethod = (key, url, ...args) => {\r\n            const upload = uploadMethod(key, url, ...args);\r\n            if (upload instanceof Promise) {\r\n                return upload.then((uploadResult) => this.#processUploadResult(uploadResult, key));\r\n            } else {\r\n                throw new TypeError(ERROR_MESSAGES.NOT_CORRECT_METHOD_TYPE);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {null | Object} uploadResult \r\n     * @param {string} key \r\n     * @returns {Promise<void>}\r\n     */\r\n    #processUploadResult = (uploadResult, key) => {\r\n        return new Promise((resolve, reject) => {\r\n            if ( !uploadResult && uploadResult !== null ) {\r\n                Warning(\"AssetsManager: uploadMethod for \" + this.#fileType + \" returns incorrect value\");\r\n            }\r\n            this.#addUploadResultValue(key, uploadResult);\r\n            this.#removeUploadFromQueue(key);\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @param {*} value \r\n     */\r\n    #addUploadResultValue(key, value) {\r\n        this.#store.set(key, value);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     */\r\n    #removeUploadFromQueue(key) {\r\n        this.#loadingQueue.delete(key);\r\n    }\r\n\r\n    get filesWaitingForUpload() {\r\n        return this.#loadingQueue.size;\r\n    }\r\n\r\n    get loadingQueue() {\r\n        return this.#loadingQueue\r\n    };\r\n    \r\n    get uploadMethod() { \r\n        return this.#uploadMethod;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @param {string[]} paramsArr \r\n     */\r\n    _addFile = (key, paramsArr) => {\r\n        if (this.#loadingQueue.has(key)) {\r\n            Warning(\"AssetsManager: File \" + this.#fileType + \" with key \" + key + \" is already added\");\r\n        }\r\n        this.#loadingQueue.set(key, paramsArr);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @returns {boolean}\r\n     */\r\n    _isFileInQueue = (key) => {\r\n        return this.#loadingQueue.has(key);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @returns {any}\r\n     */\r\n    _getFile = (key) => {\r\n        return this.#store.get(key);\r\n    }\r\n}\r\n\r\n/**\r\n *  This class is used to preload \r\n *  tilemaps, tilesets, images and audio,\r\n *  and easy access loaded files by keys\r\n */\r\nexport default class AssetsManager {\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #MAX_LOADING_CYCLES = 5;\r\n    /**\r\n     * @type {EventTarget}\r\n     */\r\n    #emitter = new EventTarget();\r\n\r\n    /**\r\n     * @type { Map<string, Loader>}\r\n     */\r\n    #registeredLoaders = new Map();\r\n    \r\n    /**\r\n     * @type {number}\r\n     */\r\n    #itemsLoaded = 0;\r\n\r\n    constructor() {\r\n        this.registerLoader(\"Audio\", this._loadAudio);\r\n        this.registerLoader(\"Image\", this._loadImage);\r\n        this.registerLoader(\"TileMap\", this._loadTileMap);\r\n        this.registerLoader(\"TileSet\", this._loadTileSet);\r\n        this.registerLoader(\"AtlasImageMap\", this._loadAtlasImage);\r\n        this.registerLoader(\"AtlasXML\", this._loadAtlasXml);\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get filesWaitingForUpload() {\r\n        let files = 0;\r\n        Array.from(this.#registeredLoaders.values()).map((loader) => files += loader.filesWaitingForUpload);\r\n        return files;\r\n    }\r\n\r\n    /**\r\n     * Register a new file type to upload. Method will dynamically add new methods.\r\n     * @param {string} fileTypeName\r\n     * @param {Function=} loadMethod loadMethod should return Promise<result>\r\n     * @returns {void}\r\n     */\r\n    registerLoader = (fileTypeName, loadMethod = this._defaultUploadMethod) => {\r\n        this[\"add\" + fileTypeName] = (key, url, ...args) => {\r\n            this.addFile(fileTypeName, key, url, ...args);\r\n        }\r\n        this[\"get\" + fileTypeName] = (key) => {\r\n            return this.getFile(fileTypeName, key);\r\n        }\r\n        this[\"is\" + fileTypeName + [\"InQueue\"]] = (key) => {\r\n            return this.isFileInQueue(fileTypeName, key);\r\n        }\r\n\r\n        const registeredFileType = this.#registeredLoaders.get(fileTypeName) || new Loader(fileTypeName, loadMethod);\r\n\r\n        this.#registeredLoaders.set(fileTypeName, registeredFileType);\r\n    }\r\n\r\n    /**\r\n     * Execute load audio, images from tilemaps and images queues\r\n     * @returns {Promise<void>}\r\n     */\r\n    preload() {\r\n        this.#dispatchLoadingStart();\r\n        return new Promise(async(resolve, reject) => {\r\n            this.#uploadFilesRecursive().then(() => {\r\n                this.#dispatchLoadingFinish();\r\n                resolve();\r\n            }).catch((err) => {\r\n                reject(err);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} loadCount \r\n     * @returns {Promise<void>}\r\n     */\r\n    #uploadFilesRecursive(loadCount = 0) {\r\n        return this.#uploadFiles().then(() => {\r\n            if (this.filesWaitingForUpload === 0) {\r\n                return Promise.resolve();\r\n            } else {\r\n                loadCount++;\r\n                if (loadCount > this.#MAX_LOADING_CYCLES) {\r\n                    const err = new Error(ERROR_MESSAGES.RECURSION_ERROR);\r\n                    this.#dispatchLoadingError(err);\r\n                    return Promise.reject(new Error(ERROR_MESSAGES.RECURSION_ERROR));\r\n                } else {\r\n                    return this.#uploadFilesRecursive(loadCount);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    #uploadFiles() {\r\n        return new Promise((resolve, reject) => {\r\n            /** @type {Promise<void>[]} */\r\n            let uploadPromises = [];\r\n            Array.from(this.#registeredLoaders.values()).forEach((fileType) => {\r\n                Array.from(fileType.loadingQueue.entries()).forEach((key_value) => {\r\n                    /** @type {Promise<void>} */\r\n                    const p = new Promise((res, rej) => fileType.uploadMethod(key_value[0], ...key_value[1]).then(() => res()));\r\n                    uploadPromises.push(p);\r\n                });\r\n            });\r\n    \r\n            Promise.allSettled(uploadPromises).then((results) => {\r\n                for (const result of results) {\r\n                    if (result.status === \"rejected\") {\r\n                        const error = result.reason;\r\n                        // incorrect method is a critical issue\r\n                        if (this.#isUploadErrorCritical(error)) {\r\n                            reject(error);\r\n                        } else {\r\n                            Warning(\"AssetsManager: \" + error.message);\r\n                            this.#dispatchLoadingError(error);\r\n                        }\r\n                    }\r\n                }\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n\r\n    addEventListener(type, fn, ...args) {\r\n        if (!PROGRESS_EVENT_TYPE[type]) {\r\n            Warning(\"AssetsManager: Event type should be one of the ProgressEvent.type\");\r\n        } else {\r\n            this.#emitter.addEventListener(type, fn, ...args);\r\n        }   \r\n    }\r\n\r\n    removeEventListener(type, fn, ...args) {\r\n        this.#emitter.removeEventListener(type, fn, ...args);\r\n    }\r\n\r\n    /**\r\n     * Loads image atlas xml\r\n     * @param {string} key\r\n     * @param {string} url\r\n     * @returns {Promise<HTMLElement | Error>}\r\n     */\r\n    _loadAtlasXml = (key, url) => {\r\n        this.#checkXmlUrl(url);\r\n        return fetch(url)\r\n            .then(response => response.text())\r\n            .then(str => new window.DOMParser().parseFromString(str, \"text/xml\"))\r\n            .then(data => {\r\n                const atlas = data.documentElement || data.activeElement,\r\n                    atlasImagePath = atlas.attributes.getNamedItem(\"imagePath\"),\r\n                    childrenNodes = atlas.children;\r\n\r\n                if (atlasImagePath) {\r\n                    const relativePath = this.#calculateRelativePath(url);\r\n\r\n                    this.addAtlasImageMap(key, relativePath + atlasImagePath.value, childrenNodes, relativePath);\r\n                    return atlas;\r\n                } else {\r\n                    const err = new Error(key + ERROR_MESSAGES.XML_FORMAT_INCORRECT);\r\n                    this.#dispatchLoadingError(err);\r\n                    return err;\r\n                    // return Promise.reject(err);\r\n                }\r\n            });\r\n    }\r\n\r\n    _loadAtlasImage = (key, url, atlasChildNodes, cors = \"anonymous\") => {\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image(),\r\n                imageAtlas = new Map(),\r\n                tempCanvas = document.createElement(\"canvas\"),\r\n                tempCtx = tempCanvas.getContext(\"2d\");\r\n            \r\n            img.crossOrigin = cors;\r\n            img.onload = () => {\r\n                const imageBitmapPromises = [];\r\n                let imageAtlasKeys = [];\r\n                // fix dimensions\r\n                tempCanvas.width = img.width;\r\n                tempCanvas.height = img.height;\r\n                tempCtx.drawImage(img, 0, 0);\r\n\r\n                for(let childNode of atlasChildNodes) {\r\n                    const nodeAttr = childNode.attributes,\r\n                        fullName = nodeAttr.getNamedItem(\"name\").value,\r\n                        name = fullName.includes(\".\") ? fullName.split(\".\")[0] : fullName, // remove name ext\r\n                        x = nodeAttr.getNamedItem(\"x\").value,\r\n                        y = nodeAttr.getNamedItem(\"y\").value,\r\n                        width = nodeAttr.getNamedItem(\"width\").value,\r\n                        height = nodeAttr.getNamedItem(\"height\").value;\r\n                    \r\n                    // images are not cropped correctly in the mozilla@124.0, issue:\r\n                    // https://bugzilla.mozilla.org/show_bug.cgi?id=1797567\r\n                    // getImageData() crop them manually before \r\n                    // creating imageBitmap from atlas\r\n                    imageBitmapPromises.push(createImageBitmap(tempCtx.getImageData(x, y, width, height), {premultiplyAlpha:\"premultiply\"}));\r\n                    imageAtlasKeys.push(name);\r\n                }\r\n                this.#dispatchCurrentLoadingProgress();\r\n                Promise.all(imageBitmapPromises).then((results) => {\r\n                    results.forEach((image, idx) => {\r\n                        const name = imageAtlasKeys[idx];\r\n                        imageAtlas.set(name, image);\r\n                        this.addImage(name, \"empty url\", image);\r\n                    });\r\n                    tempCanvas.remove();\r\n                    resolve(imageAtlas);\r\n                });\r\n            };\r\n            img.onerror = () => {\r\n                const err = new Error(ERROR_MESSAGES.ATLAS_IMAGE_LOADING_FAILED + url);\r\n                this.#dispatchLoadingError(err);\r\n                resolve(null);\r\n                //reject(err);\r\n            };\r\n            img.src = url;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads tileset\r\n     * @param {string} key\r\n     * @param {string} url \r\n     * @param {number} gid\r\n     * @param {string} relativePath\r\n     * @returns {Promise<Object>}\r\n     */\r\n    _loadTileSet = (key, url, gid=1, relativePath) => {\r\n        const file_format = this.#checkTilesetUrl(url),\r\n            loadPath = relativePath ? relativePath + url : url;\r\n        if (file_format === FILE_FORMAT.JSON) {\r\n            return fetch(loadPath)\r\n                .then((response) => response.json())\r\n                .then((data) => this._processTilesetData(data, relativePath, gid, url))\r\n                .catch(() => {\r\n                    const err = new Error(ERROR_MESSAGES.TILESET_LOADING_FAILED + url);\r\n                    this.#dispatchLoadingError(err);\r\n                    return Promise.resolve(null);\r\n                    //return Promise.reject(err);\r\n                });\r\n        } else if (file_format === FILE_FORMAT.XML) {\r\n            return fetch(loadPath)\r\n                .then(response => response.text())\r\n                .then(str => new window.DOMParser().parseFromString(str, \"text/xml\"))\r\n                .then(xmlString => this._processTilesetXmlData(xmlString.documentElement))\r\n                .then((data) => this._processTilesetData(data, relativePath, gid, url))\r\n                .catch(() => {\r\n                    const err = new Error(ERROR_MESSAGES.TILESET_LOADING_FAILED + url);\r\n                    this.#dispatchLoadingError(err);\r\n                    return Promise.resolve(null);\r\n                });\r\n        } else {\r\n            return Promise.reject(loadPath + ERROR_MESSAGES.TILEMAP_FILE_EXTENSION_INCORRECT);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Object} doc \r\n     * @returns {Object}\r\n     */\r\n    _processTilesetXmlData = (doc) => {\r\n        const tilesetData = {\r\n            columns: Number(doc.attributes?.columns?.value),\r\n            name: doc.attributes?.name?.value,\r\n            tilecount: Number(doc.attributes?.tilecount?.value),\r\n            tiledversion: doc.attributes?.tiledversion?.value,\r\n            tileheight: Number(doc.attributes?.tileheight?.value),\r\n            tilewidth: Number(doc.attributes?.tilewidth?.value),\r\n            version: doc.attributes?.version?.value,\r\n            margin: doc.attributes?.margin ? Number(doc.attributes.margin.value) : 0,\r\n            spacing: doc.attributes?.spacing ? Number(doc.attributes.margin.value) : 0,\r\n            type: doc.tagName\r\n        };\r\n        \r\n        this._processTilesetXmlChildData(tilesetData, doc.childNodes);\r\n        \r\n        return tilesetData;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {any} tilesetData \r\n     * @param {any} nodes\r\n     * @returns {void} \r\n     */\r\n    _processTilesetXmlChildData(tilesetData, nodes) {\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i],\r\n                name = node.nodeName;\r\n                \r\n            if (name === \"image\") {\r\n                tilesetData.image = node?.attributes?.source?.value;\r\n                tilesetData.imagewidth = node?.attributes?.width ? Number(node.attributes.width.value) : 0;\r\n                tilesetData.imageheight = node?.attributes?.height ? Number(node.attributes.height.value) : 0;\r\n            } else if (name === \"tileoffset\") {\r\n                tilesetData.tileoffset = {\r\n                    x: Number(node.attributes.x.value),\r\n                    y: Number(node.attributes.y.value)\r\n                };\r\n            } else if (name === \"tile\") {\r\n                if (!tilesetData.tiles) {\r\n                    tilesetData.tiles = [];\r\n                }\r\n                \r\n                const tile = {\r\n                    id: Number(node.attributes?.id?.value)\r\n                }\r\n                const childN = node.childNodes;\r\n                \r\n                for (let j = 0; j < childN.length; j++) {\r\n                    const child = childN[j],\r\n                        childName = child.nodeName;\r\n                    if (childName === \"objectgroup\") {\r\n                        tile.objectgroup = {\r\n                            type: childName\r\n                        }\r\n\r\n                        if (child.attributes?.id) {\r\n                            tile.objectgroup.id = Number(child.attributes?.id?.value);\r\n                        }\r\n                        if (child.attributes?.draworder) {\r\n                            tile.objectgroup.draworder = child.attributes.draworder.value;\r\n                        }\r\n                        if (child.attributes?.opacity) {\r\n                            tile.objectgroup.opacity = child.attributes.opacity.value;\r\n                        }\r\n                        if (child.attributes?.x && child.attributes?.y) {\r\n                            tile.objectgroup.x = child.attributes.x.value;\r\n                            tile.objectgroup.y = child.attributes.y.value;\r\n                        }\r\n\r\n                        tile.objectgroup.objects = [];\r\n\r\n                        const objects = child.childNodes;\r\n                        for (let k = 0; k < objects.length; k++) {\r\n                            const obj = objects[k];\r\n                            \r\n                            if (obj.nodeName === \"object\") {\r\n                                const objInc = {\r\n                                    id: Number(obj.attributes?.id?.value),\r\n                                    visible: obj.attributes.visible && obj.attributes.visible.value === \"0\" ? false : true,\r\n                                    x: Number(obj.attributes?.x?.value),\r\n                                    y: Number(obj.attributes?.y?.value),\r\n                                    rotation: obj.attributes?.rotation ? Number(obj.attributes.rotation.value) :0,\r\n                                };\r\n                                if (obj.attributes?.width) {\r\n                                    objInc.width = Number(obj.attributes.width.value); \r\n                                }\r\n                                if (obj.attributes?.height) {\r\n                                    objInc.height = Number(obj.attributes.height.value);\r\n                                }\r\n                                \r\n                                const childObjects = obj.childNodes;\r\n                                if (childObjects && childObjects.length > 0) {\r\n                                    for (let n = 0; n < childObjects.length; n++) {\r\n                                        const childObj = childObjects[n];\r\n                                \r\n                                        if (childObj.nodeName === \"ellipse\") {\r\n                                            objInc.ellipse = true;\r\n                                        } else if (childObj.nodeName === \"point\") {\r\n                                            objInc.point = true;\r\n                                        } else if (childObj.nodeName === \"polygon\") {\r\n                                            const points = childObj.attributes?.points?.value;\r\n                                            if (points && points.length > 0) {\r\n                                                const pointsArr = points.split(\" \").map((point) => {\r\n                                                    const [x, y] = point.split(\",\");\r\n                                                    return {x:Number(x), y:Number(y)};\r\n                                                });\r\n                                                objInc.polygon = pointsArr;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                tile.objectgroup.objects.push(objInc);\r\n                            }\r\n                        }\r\n                    } else if (childName === \"animation\") {\r\n                        //\r\n                        tile.animation = [];\r\n                        \r\n                        const frames = child.childNodes;\r\n                        for (let t = 0; t < frames.length; t++) {\r\n                            const frame = frames[t];\r\n\r\n                            if (frame.nodeName === \"frame\") {\r\n                                const frameObject = {\r\n                                    tileid: Number(frame.attributes?.tileid?.value),\r\n                                    duration: Number(frame.attributes?.duration?.value)\r\n                                }\r\n                                tile.animation.push(frameObject);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                tilesetData.tiles.push(tile);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * \r\n     * @param {Object} data \r\n     * @param {string} relativePath\r\n     * @param {number=} gid\r\n     * @param {string=} source\r\n     * @returns {Promise<Object>}\r\n     */\r\n    _processTilesetData = (data, relativePath, gid, source) => {\r\n        const {name, image } = data;\r\n        if (name && image && !this.isFileInQueue(\"Image\", name)) {\r\n            this.addImage(name, relativePath ? relativePath + image : image);\r\n        }\r\n        if (gid) {\r\n            data.firstgid = gid;\r\n        }\r\n        // if it is an external file\r\n        if (source) {\r\n            data.source = source;\r\n        }\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} key \r\n     * @param {string} url \r\n     * @returns {Promise<any>}\r\n     */\r\n    _defaultUploadMethod = (key, url) => {\r\n        return fetch(url);\r\n    }\r\n\r\n    /**\r\n     * Loads tilemap file and related data\r\n     * @param {string} key \r\n     * @param {string} url \r\n     * @param {boolean} [attachTileSetData = true] - indicates, whenever tilesetData is attached, or will be loaded separately\r\n     * @returns {Promise}\r\n     */\r\n    _loadTileMap = (key, url, attachTileSetData = true) => {\r\n        const file_format = this.#checkTilemapUrl(url);\r\n        \r\n        let fetchData;\r\n        if (file_format === FILE_FORMAT.JSON) {\r\n            fetchData = fetch(url)\r\n                .then((response) => response.json())\r\n                .then((data) => this._processTileMapData(data, url, attachTileSetData))\r\n                .catch((err) => {\r\n                    if (err.message.includes(\"JSON.parse:\")) {\r\n                        err = new Error(ERROR_MESSAGES.TILEMAP_LOADING_FAILED + url);\r\n                    }\r\n                    this.#dispatchLoadingError(err);\r\n                    return Promise.resolve(null);\r\n                    //return Promise.reject(err);\r\n                });\r\n        } else if (FILE_FORMAT.XML) {\r\n            fetchData = fetch(url)\r\n                .then((response) => response.text())\r\n                .then((rawText) => this._processTileMapXML(rawText))\r\n                .then((tilemapData) => this._processTileMapData(tilemapData, url, attachTileSetData))\r\n                .catch((err) => {\r\n                    this.#dispatchLoadingError(err);\r\n                    return Promise.resolve(null);\r\n                    //return Promise.reject(err);\r\n                });\r\n        } else {\r\n            return Promise.reject(url + ERROR_MESSAGES.TILEMAP_FILE_EXTENSION_INCORRECT);\r\n        }\r\n\r\n        return fetchData;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} rawText \r\n     * @returns {Object}\r\n     */\r\n    _processTileMapXML = (rawText) => {\r\n        const xmlDoc = new DOMParser().parseFromString(rawText, \"text/xml\");\r\n                \r\n        /** @type {Object} */\r\n        const doc = xmlDoc.documentElement;\r\n        const tilemapData = {\r\n            type: doc.tagName,\r\n            width: Number(doc.attributes?.width?.value),\r\n            height: Number(doc.attributes?.height?.value),\r\n            infinite: doc.attributes.infinite && doc.attributes.infinite.value === \"1\" ? true : false,\r\n            nextlayerid: Number(doc.attributes?.nextlayerid?.value),\r\n            nextobjectid: Number(doc.attributes?.nextobjectid?.value),\r\n            orientation: doc.attributes?.orientation?.value,\r\n            renderorder: doc.attributes?.renderorder?.value,\r\n            tiledversion: doc.attributes?.tiledversion?.value,\r\n            tileheight: Number(doc.attributes?.tileheight?.value),\r\n            tilewidth: Number(doc.attributes?.tilewidth?.value),\r\n            version: doc.attributes?.version?.value,\r\n            /** @type {Array<Object>} */\r\n            tilesets: [],\r\n            /** @type {Array<Object>} */\r\n            layers: []\r\n        };\r\n        const nodes = xmlDoc.documentElement.childNodes;\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            /** @type {Object} */\r\n            const node = nodes[i],\r\n                name = node.nodeName;\r\n                \r\n            if (name === \"tileset\") {\r\n                const tileset = {\r\n                    firstgid: Number(node.attributes?.firstgid?.value)\r\n                };\r\n                if (node.attributes?.source) { // external tileset (will be loaded later)\r\n                    tileset.source = node.attributes?.source?.value;\r\n                } else {\r\n                    // inline tileset\r\n                    tileset.columns = Number(node.attributes?.columns?.value);\r\n                    if (node.attributes?.margin) {\r\n                        tileset.margin = Number(node.attributes?.margin?.value);\r\n                    }\r\n                    if (node.attributes?.spacing) {\r\n                        tileset.spacing = node.attributes?.spacing?.value;\r\n                    }\r\n                    tileset.name = node.attributes?.name?.value;\r\n                    \r\n                    tileset.tilecount = Number(node.attributes?.tilecount?.value);\r\n                    tileset.tilewidth = Number(node.attributes?.tilewidth?.value);\r\n                    tileset.tileheight = Number(node.attributes?.tileheight?.value);\r\n\r\n                    this._processTilesetXmlChildData(tileset, node.childNodes);\r\n                }\r\n                tilemapData.tilesets.push(tileset);\r\n            } else if (name === \"layer\") {\r\n                const layer = {\r\n                    height: Number(node.attributes?.height?.value),\r\n                    id: Number(node.attributes?.id?.value),\r\n                    name: node.attributes?.name?.value,\r\n                    width: Number(node.attributes?.width?.value),\r\n                    data: node.textContent ? node.textContent.trim().split(\",\").map((val) => Number(val)): null\r\n                }\r\n                tilemapData.layers.push(layer);\r\n            }\r\n        }\r\n\r\n        return tilemapData;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {any} data \r\n     * @param {string} url \r\n     * @param {boolean} attachTileSetData \r\n     * @returns {Promise<any>}\r\n     */\r\n    _processTileMapData = (data, url, attachTileSetData) => {\r\n        const relativePath = this.#calculateRelativePath(url);\r\n        \r\n        if (attachTileSetData === true && data.tilesets && data.tilesets.length > 0) {\r\n            const tilesetPromises = [];\r\n            // upload additional tileset data\r\n            data.tilesets.forEach((tileset, idx) => {\r\n                const { firstgid, source } = tileset;\r\n                if (source) { // external tileset\r\n                    const loadTilesetPromise = this._loadTileSet(\"default-\" + firstgid, source, firstgid, relativePath)\r\n                        .then((tilesetData) => {\r\n                            this.#dispatchCurrentLoadingProgress();\r\n                            return Promise.resolve(tilesetData);\r\n                        });\r\n                    tilesetPromises.push(loadTilesetPromise);\r\n                } else { // inline tileset\r\n                    const loadTilesetPromise = this._processTilesetData(tileset, relativePath)\r\n                        .then((tilesetData) => {\r\n                            this.#dispatchCurrentLoadingProgress();\r\n                            return Promise.resolve(tilesetData);\r\n                        });\r\n                    tilesetPromises.push(loadTilesetPromise);\r\n                }\r\n            });\r\n            //attach additional tileset data to tilemap data\r\n            return Promise.all(tilesetPromises).then((tilesetDataArray) => {\r\n                for (let i = 0; i < tilesetDataArray.length; i++) {\r\n                    const tilesetData = tilesetDataArray[i];\r\n                    data.tilesets[i] = tilesetData;\r\n                    // @depricated\r\n                    // save backward capability with jsge@1.5.71\r\n                    data.tilesets[i].data = Object.assign({}, tilesetData);\r\n                }\r\n                return Promise.resolve(data);\r\n            });\r\n        } else {\r\n            return Promise.resolve(data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads audio file\r\n     * @param {string} key \r\n     * @param {string} url \r\n     * @returns {Promise}\r\n     */\r\n    _loadAudio = (key, url) => {\r\n        return new Promise((resolve) => {\r\n            const audio = new Audio(url);\r\n            \r\n            audio.addEventListener(\"loadeddata\", () => {\r\n                this.#dispatchCurrentLoadingProgress();\r\n                resolve(audio);\r\n            });\r\n\r\n            audio.addEventListener(\"error\", () => {\r\n                const err = new Error(ERROR_MESSAGES.AUDIO_LOADING_FAILED + url);\r\n                this.#dispatchLoadingError(err);\r\n                resolve(null);\r\n                //reject(err);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads image file.\r\n     * @param {string} key \r\n     * @param {string} url\r\n     * @param {ImageBitmap=} image - image could be add from another source\r\n     * @param {string} [cors=\"anonymous\"] // https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images\r\n     * @returns {Promise}\r\n     */\r\n    _loadImage = (key, url, image, cors = \"anonymous\") => {\r\n        return new Promise((resolve, reject) => {\r\n            if (image) {\r\n                resolve(image);\r\n            } else {\r\n                const img = new Image();\r\n                img.crossOrigin = cors;\r\n                img.onload = () => {\r\n                    // do we need a bitmap? Without creating bitmap images has not premultiplied\r\n                    // transparent pixels, and in some cases it creates white ages,\r\n                    // in other - multiply pixels with the background\r\n                    createImageBitmap(img, {premultiplyAlpha:\"premultiply\"}).then((imageBitmap) => {\r\n                        this.#dispatchCurrentLoadingProgress();\r\n                        resolve(imageBitmap);\r\n                    });\r\n                };\r\n                img.onerror = () => {\r\n                    const err = new Error(ERROR_MESSAGES.IMAGE_LOADING_FAILED + url);\r\n                    this.#dispatchLoadingError(err);\r\n                    resolve(null);\r\n                    // reject(err);\r\n                };\r\n                img.src = url;\r\n            }\r\n        });\r\n    }\r\n\r\n    #checkXmlUrl(url) {\r\n        if (url.includes(\".xml\")) {\r\n            return;\r\n        } else {\r\n            Exception(url + ERROR_MESSAGES.XML_FILE_EXTENSION_INCORRECT);\r\n        }\r\n    }\r\n\r\n    #checkTilesetUrl(url) {\r\n        if (url.includes(\".tsj\") || url.includes(\".json\")) {\r\n            return FILE_FORMAT.JSON;\r\n        } else if (url.includes(\".tsx\") || url.includes(\".xml\")) {\r\n            return FILE_FORMAT.XML;\r\n        } else {\r\n            return FILE_FORMAT.UNKNOWN;\r\n        }\r\n    }\r\n\r\n    #checkTilemapUrl(url) {\r\n        if (url.includes(\".tmj\") || url.includes(\".json\")) {\r\n            return FILE_FORMAT.JSON;\r\n        } else if (url.includes(\".tmx\") || url.includes(\".xml\")) {\r\n            return FILE_FORMAT.XML;\r\n        } else {\r\n            return FILE_FORMAT.UNKNOWN;\r\n        }\r\n    }\r\n\r\n    #isUploadErrorCritical(error) {\r\n        return error.message.includes(ERROR_MESSAGES.NOT_CORRECT_METHOD_TYPE)\r\n            || error.message.includes(ERROR_MESSAGES.XML_FILE_EXTENSION_INCORRECT)\r\n            || error.message.includes(ERROR_MESSAGES.TILESET_FILE_EXTENSION_INCORRECT)\r\n            || error.message.includes(ERROR_MESSAGES.TILEMAP_FILE_EXTENSION_INCORRECT)\r\n            || error.message.includes(ERROR_MESSAGES.INPUT_PARAMS_ARE_INCORRECT)\r\n            || error.message.includes(ERROR_MESSAGES.LOADER_NOT_REGISTERED);\r\n    }\r\n\r\n    /**\r\n     * Calculate relative path for current url\r\n     * for example: /folder/images/map.xml -> /folder/images/\r\n     * @param {string} url \r\n     * @returns {string}\r\n     */\r\n    #calculateRelativePath(url) {\r\n        let split = url.split(\"/\"),\r\n            length = split.length,\r\n            lastEl = split[length - 1],\r\n            //prelastEl = split[length - 2],\r\n            relativePath = \"/\";\r\n        \r\n        // url ends with .ext\r\n        if (lastEl.includes(\".tmj\") || lastEl.includes(\".tmx\") || lastEl.includes(\".xml\") || lastEl.includes(\".json\")) {\r\n            split.pop();\r\n            relativePath = split.join(\"/\") + \"/\";\r\n        // url ends with /\r\n        }/* else if (prelastEl.includes(\".tmj\") || lastEl.includes(\".tmx\") || prelastEl.includes(\".xml\") || prelastEl.includes(\".json\")) {\r\n            split.splice(length - 2, 2);\r\n            relativePath = split.join(\"/\") + \"/\";\r\n        }*/\r\n        return relativePath;\r\n    }\r\n\r\n    addFile(fileType, fileKey, url, ...args) {\r\n        const loader = this.#registeredLoaders.get(fileType);\r\n        if (loader) {\r\n            this.#checkInputParams(fileKey, url, fileType);\r\n            loader._addFile(fileKey, [url, ...args]);\r\n        } else {\r\n            Exception(fileType + ERROR_MESSAGES.LOADER_NOT_REGISTERED);\r\n        }\r\n\r\n    }\r\n\r\n    isFileInQueue(fileType, fileKey) {\r\n        const loader = this.#registeredLoaders.get(fileType);\r\n        if (loader) {\r\n            return loader._isFileInQueue(fileKey);\r\n        } else {\r\n            Exception(\"Loader for \" + fileType + \" is not registered!\");\r\n        }\r\n    }\r\n\r\n    getFile(fileType, fileKey) {\r\n        const loader = this.#registeredLoaders.get(fileType);\r\n        if (loader) {\r\n            return loader._getFile(fileKey);\r\n        } else {\r\n            Exception(\"Loader for \" + fileType + \" is not registered!\");\r\n        }\r\n    }\r\n\r\n    #checkInputParams(fileKey, url, fileType) {\r\n        const errorMessage = ERROR_MESSAGES.INPUT_PARAMS_ARE_INCORRECT;\r\n        if (!fileKey || fileKey.trim().length === 0) {\r\n            Exception(\"add\" + fileType + \"()\" + errorMessage);\r\n        }\r\n        if (!url || url.trim().length === 0) {\r\n            Exception(\"add\" + fileType + \"()\" + errorMessage);\r\n        }\r\n        return;\r\n    }\r\n\r\n    #dispatchLoadingStart() {\r\n        let total = this.filesWaitingForUpload;\r\n        this.#emitter.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart, { total }));\r\n    }\r\n\r\n    #dispatchLoadingFinish() {\r\n        this.#emitter.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load));\r\n    }\r\n\r\n    #dispatchCurrentLoadingProgress() {\r\n        const total = this.filesWaitingForUpload;\r\n        this.#itemsLoaded += 1;\r\n        this.#emitter.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress, { lengthComputable: true, loaded: this.#itemsLoaded, total }));\r\n    }\r\n\r\n    #dispatchLoadingError(error) {\r\n        Warning(\"AssetsManger: \" + error.message);\r\n        this.#emitter.dispatchEvent(new ErrorEvent(PROGRESS_EVENT_TYPE.error, { error }));\r\n    }\r\n}\r\n\r\nfunction Exception (message) {\r\n    throw new Error(message);\r\n}\r\n\r\nfunction Warning (message) {\r\n    console.warn(message);\r\n}","import { DRAW_TYPE } from \"../../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Circle object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawCircleObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #radius;\n\n    /**\n     * @type {Array<number>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, radius, bgColor) {\n        super(DRAW_TYPE.CIRCLE, x, y, bgColor);\n        this.#radius = radius;\n        this.#vertices = this._interpolateConus(radius);\n    }\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get radius() {\n        return this.#radius;\n    }\n}","import { DRAW_TYPE } from \"../../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Conus object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawConusObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #radius;\n\n    /**\n     * @type {number}\n     */\n    #angle;\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    #vertices;\n    #fade_min;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, radius, bgColor, angle, fade = 0) {\n        super(DRAW_TYPE.CONUS, x, y, bgColor);\n        this.#radius = radius;\n        this.#angle = angle;\n        this.#fade_min = fade;\n        this.#vertices = this._interpolateConus(radius, angle);\n    }\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get radius() {\n        return this.#radius;\n    }\n\n    /**\n     * @type {number}\n     */\n    get angle() {\n        return this.#angle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get fade_min() {\n        return this.#fade_min;\n    }\n\n    /**\n     * @param {number} value - fade start pos in px\n     */\n    set fade_min(value) {\n        this.#fade_min = value;\n    }\n}","import { AnimationEvent } from \"../AnimationEvent.js\";\nimport { DRAW_TYPE, ERROR_CODES } from \"../../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { ImageTempStorage } from \"../Temp/ImageTempStorage.js\";\nimport { Exception, Warning } from \"../Exception.js\";\n/**\n * Image object to draw\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawImageObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #w;\n    /**\n     * @type {number}\n     */\n    #h;\n    /**\n     * Image sprite key\n     * @type {string}\n     */\n    #key;\n    /**\n     * @type {ImageBitmap}\n     */\n    #image;\n    /**\n     * @type {EventTarget}\n     */\n    #emitter;\n    /**\n     * @type {Map<string, AnimationEvent>}\n     */\n    #animations;\n    /**\n     * @type {null | string}\n     */\n    #activeAnimation;\n    /**\n     * @type {number}\n     */\n    #imageIndex;\n    /**\n     * @type {number}\n     */\n    #spacing = 0;\n    /**\n     * @type {number}\n     */\n    #margin = 0;\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n    /**\n     * @type {Object | null}\n     */\n    #circleCollisionShapes;\n    /**\n     * @type {ImageTempStorage}\n     */\n    #textureStorage;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(mapX, mapY, width, height, key, imageIndex = 0, collisionShapes, image, spacing = 0, margin = 0) {\n        super(DRAW_TYPE.IMAGE, mapX, mapY);\n        this.#key = key;\n        this.#emitter = new EventTarget();\n        this.#animations = new Map();\n        this.image = image;\n        this.#imageIndex = imageIndex;\n        this.#spacing = spacing;\n        this.#margin = margin;\n        this.#w = width;\n        this.#h = height;\n        this.#vertices = collisionShapes && !collisionShapes.r ? this._convertVerticesArray(collisionShapes) : collisionShapes && collisionShapes.r ? this._calculateConusShapes(collisionShapes.r) : this._calculateRectVertices(width, height);\n        this.#circleCollisionShapes = collisionShapes && typeof collisionShapes.r !== \"undefined\" ? collisionShapes : null;\n    }\n\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n\n    set width(w) {\n        this.#w = w;\n    }\n\n    set height(h) {\n        this.#h = h;\n    }\n\n    /**\n     * A key should match an image loaded through AssetsManager\n     * @type {string}\n     */\n    get key() {\n        return this.#key;\n    }\n\n    /**\n     * @type {ImageBitmap}\n     */\n    get image() {\n        return this.#image;\n    }\n\n    set image(value) {\n        if (this.#textureStorage) {\n            this.#textureStorage._isTextureRecalculated = true;\n        }\n\n        this.#image = value;\n    }\n\n    /**\n     * Current image index\n     * @type {number}\n     */\n    get imageIndex() {\n        return this.#imageIndex;\n    }\n\n    set imageIndex(value) {\n        this.#imageIndex = value;\n    }\n\n    /**\n     * Image spacing (for tilesets.spacing > 0)\n     * @type {number}\n     */\n    get spacing() {\n        return this.#spacing;\n    }\n\n    /**\n     * Image spacing (for tilesets.margin > 0)\n     * @type {number}\n     */\n    get margin() {\n        return this.#margin;\n    }\n\n    /**\n     * Determines if image is animated or not\n     * @type {boolean}\n     */\n    get hasAnimations() {\n        return this.#animations.size > 0;\n    }\n\n    /**\n     * @type {null | string}\n     */\n    get activeAnimation() {\n        return this.#activeAnimation;\n    }\n\n    /**\n     * @deprecated \n     * use vertices\n     * @type {Array<Array<number>>}\n     */\n    get boundaries() {\n        return this.#vertices;\n    }\n\n    get vertices() {\n        return this.#vertices;\n    }\n\n    get circleCollisionShapes() {\n        return this.#circleCollisionShapes;\n    }\n\n    /**\n     * @ignore\n     */\n    _processActiveAnimations() {\n        const activeAnimation = this.#activeAnimation;\n        if (activeAnimation) {\n            const animationEvent = this.#animations.get(activeAnimation);\n            if (animationEvent.isActive === false) {\n                this.#activeAnimation = null;\n            } else {\n                animationEvent.iterateAnimationIndex();\n                this.#imageIndex = animationEvent.currentSprite;\n            }\n        }\n    }\n    /**\n     * @ignore\n     */\n    get _textureStorage() {\n        return this.#textureStorage;\n    }\n\n    /**\n     * @ignore\n     */\n    set _textureStorage(texture) {\n        this.#textureStorage = texture;\n    }\n\n    /**\n     * Emit event\n     * @param {string} eventName \n     * @param  {...any} eventParams \n     */\n    emit(eventName, ...eventParams) {\n        const event = new Event(eventName);\n        event.data = [...eventParams];\n        this.#emitter.dispatchEvent(event);\n    }\n\n    /**\n     * Subscribe\n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*} options \n     */\n    addEventListener(eventName, listener, options) {\n        this.#emitter.addEventListener(eventName, listener, options);\n    }\n\n    /**\n     * Unsubscribe\n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*} options \n     */\n    removeEventListener(eventName, listener, options) {\n        this.#emitter.removeEventListener(eventName, listener, options);\n    }\n\n    /**\n     * Adds image animations\n     * @param { string } eventName -animation name\n     * @param { Array<number> | Array<{duration:number, id:number}> } animationSpriteIndexes - animation image indexes\n     * @param { boolean } [isRepeated = false] - animation is cycled or not, cycled animation could be stopped only with stopRepeatedAnimation();\n     */\n    addAnimation (eventName, animationSpriteIndexes, isRepeated) {\n        if (!this.#checkAnimationParams(animationSpriteIndexes)) {\n            Exception(ERROR_CODES.UNEXPECTED_INPUT_PARAMS, \" animationSpriteIndexes should be Array of indexes, or Array of objects {duration:number, id:number}\");\n        }\n        const animationEvent = new AnimationEvent(eventName, animationSpriteIndexes, isRepeated);\n        this.#animations.set(eventName, animationEvent);\n        this.addEventListener(eventName, this.#activateAnimation);\n    }\n\n    #checkAnimationParams (animationSpriteIndexes) {\n        let isCorrect = true;\n        animationSpriteIndexes.forEach(element => {\n            if (typeof element !== \"number\") {\n                if (typeof element.duration !== \"number\" || typeof element.id !== \"number\") {\n                    isCorrect = false;\n                }\n            }     \n        });\n        return isCorrect;\n    }\n    #activateAnimation = (event) => {\n        const animationName = event.type,\n            animationEvent = this.#animations.get(animationName);\n        // only one active animation can exist at a time\n        if (this.#activeAnimation && this.#activeAnimation !== animationName) {\n            this.stopRepeatedAnimation(this.#activeAnimation);\n        }\n        animationEvent.activateAnimation();\n        this.#activeAnimation = animationName;\n        this.#imageIndex = animationEvent.currentSprite;\n    }; \n\n    /**\n     *\n     * @param {string=} eventName - animation name, if not provided - stop current active animation event\n     */\n    stopRepeatedAnimation (eventName) {\n        this.#animations.get(eventName).deactivateAnimation();\n        this.#activeAnimation = null;\n    }\n\n    /**\n     * Removes animations\n     */\n    removeAllAnimations() {\n        for (let [eventName, animationEvent] of this.#animations.entries()) {\n            this.removeEventListener(eventName, animationEvent.activateAnimation);\n            animationEvent.deactivateAnimation();\n        }\n        this.#animations.clear();\n        this.#animations = undefined;\n    }\n\n    destroy() {\n        this.removeAllAnimations();\n        super.destroy();\n    }\n}","import { DRAW_TYPE } from \"../../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Line object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawLineObject extends DrawShapeObject {\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(vertices, bgColor) {\n        super(DRAW_TYPE.LINE, vertices[0][0], vertices[0][1], bgColor);\n        this.#vertices = vertices;\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n}","import { DRAW_TYPE } from \"../../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawPolygonObject extends DrawShapeObject {\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(vertices, bgColor) {\n        super(DRAW_TYPE.POLYGON, vertices[0].x, vertices[0].y, bgColor);\n        this.#vertices = this._convertVerticesArray(vertices);\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n}","import { DRAW_TYPE } from \"../../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawRectObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #w;\n    /**\n     * @type {number}\n     */\n    #h;\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, w, h, bgColor) {\n        super(DRAW_TYPE.RECTANGLE, x, y, bgColor);\n        this.#w = w;\n        this.#h = h;\n        this.#vertices = this._calculateRectVertices(w,h);\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n\n    set width(w) {\n        this.#w = w;\n    }\n\n    set height(h) {\n        this.#h = h;\n    }\n}","import { DRAW_TYPE } from \"../../constants.js\";\nimport { utils } from \"../../index.js\";\n\n/**\n * A base draw object.\n */\nexport class DrawShapeObject {\n    #x;\n    #y;\n    #bg;\n    /**\n     * @type {DRAW_TYPE}\n     */\n    #type;\n    /**\n     * Is used for blending pixel arithmetic\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc.\n     * @type {Array<number>}\n     */\n    #blendFunc;\n    \n    /**\n     * @type {number}\n     */\n    #sortIndex = 0;\n    /**\n     * @type {number}\n     */\n    #rotation = 0;\n    /**\n     * @type {number}\n     */\n    #id = utils.generateUniqId();\n    /**\n     * @type {boolean}\n     */\n    #isRemoved = false;\n    /**\n     * @type {undefined | number | null}\n     */\n    #attachedMaskId;\n    /**\n     * @type {boolean}\n     */\n    #isMask;\n    /**\n     * @type {boolean}\n     */\n    #isOffsetTurnedOff = false;\n\n    /**\n     * @type {boolean}\n     */\n    #isChanged = false;\n    /**\n     * @hideconstructor\n     */\n    constructor(type, mapX, mapY, bgColor) {\n        this.#x = mapX;\n        this.#y = mapY;\n        this.#bg = bgColor;\n        this.#type = type;\n    }\n\n    /**\n     * Background color as rgba(r,g,b,a).\n     * @type {string}\n     */\n    get bgColor() {\n        return this.#bg;\n    }\n\n    set bgColor(value) {\n        this.#bg = value;\n    }\n\n    /**\n     * @type {DRAW_TYPE}\n     */\n    get type() {\n        return this.#type;\n    }\n\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n\n    /**\n     * @type {number}\n     */\n    get y () {\n        return this.#y;\n    }\n\n    set x(posX) {\n        this.#x = posX;\n    }\n\n    set y(posY) {\n        this.#y = posY;\n    }\n\n    /**\n     * @type {number}\n     */\n    get sortIndex () {\n        return this.#sortIndex;\n    }\n\n    set sortIndex(value) {\n        this.#sortIndex = value;\n    }\n\n    get blendFunc () {\n        return this.#blendFunc;\n    }\n\n    set blendFunc(value) {\n        this.#blendFunc = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n        return this.#rotation;\n    }\n\n    set rotation(value) {\n        this.#rotation = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get id() {\n        return this.#id;\n    }\n\n    /**\n     * @type {boolean}\n     */\n    get isRemoved() {\n        return this.#isRemoved;\n    }\n    /**\n     * Destroy object on next render iteration.\n     */\n    destroy() {\n        this.#isRemoved = true;\n    }\n\n    get isMaskAttached() {\n        return !!this.#attachedMaskId;\n    }\n\n    /**\n     * @ignore\n     */\n    get _maskId() {\n        return this.#attachedMaskId;\n    }\n\n    /**\n     * \n     * @param {DrawShapeObject} mask \n     */\n    setMask(mask) {\n        mask._isMask = true;\n        this.#attachedMaskId = mask.id;\n    }\n\n    removeMask() {\n        this.#attachedMaskId = null;\n    }\n\n    set _isMask(isSet) {\n        this.#isMask = isSet;\n    }\n\n    get _isMask() {\n        return this.#isMask;\n    }\n\n    get isOffsetTurnedOff() {\n        return this.#isOffsetTurnedOff;\n    }\n\n    /**\n     * turn off offset for specific draw object\n     * gameStageData.centerCameraPosition() will take no effect on such object\n     * Can be used for something that should be always on screen: control buttons, overlay masks etc.\n     */\n    turnOffOffset() {\n        this.#isOffsetTurnedOff = true;\n    }\n    /**\n     * @ignore\n     * @param {number} width \n     * @param {number} height \n     * @returns {Array<Array<number>>}\n     */\n    _calculateRectVertices = (width, height) => {\n        const halfW = width/2,\n            halfH = height/2;\n        return [[-halfW, -halfH], [halfW, -halfH], [halfW, halfH], [-halfW, halfH]];\n    };\n\n    /**\n     * @param {number} radius \n     * @param {number} [angle = 2 * Math.PI]\n     * @param {number} [step = Math.PI/12] \n     * @returns {Array<number>}\n     * @ignore\n     */\n    _interpolateConus(radius, angle = 2*Math.PI, step = Math.PI/14) {\n        let conusPolygonCoords = [0, 0];\n\n        for (let r = 0; r <= angle; r += step) {\n            let x2 = Math.cos(r) * radius,\n                y2 = Math.sin(r) * radius;\n\n            conusPolygonCoords.push(x2, y2);\n        }\n\n        return conusPolygonCoords;\n    }\n\n    /**\n     * @param {number} radius \n     * @param {number} [angle = 2 * Math.PI]\n     * @param {number} [step = Math.PI/12] \n     * @returns {Array<Array<number>>}\n     * @ignore\n     */\n    _calculateConusShapes(radius, angle = 2*Math.PI, step = Math.PI/14) {\n        let conusPolygonCoords = [];\n\n        for (let r = 0; r <= angle; r += step) {\n            let x2 = Math.cos(r) * radius,\n                y2 = Math.sin(r) * radius;\n\n            conusPolygonCoords.push([x2, y2]);\n        }\n\n        return conusPolygonCoords;\n    }\n\n\n    /**\n     * @param {Array<Array<number>> | Array<{x:number, y:number}>} collision_shapes\n     * @returns {Array<Array<number>>}\n     * @ignore\n     */\n    _convertVerticesArray(collision_shapes) {\n        if (typeof collision_shapes[0].x !== \"undefined\" && typeof collision_shapes[0].y !== \"undefined\") {\n            return utils.verticesArrayToArrayNumbers(collision_shapes);\n        } else {\n            return collision_shapes;\n        }\n    }\n}","import { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { Rectangle } from \"./Primitives.js\";\nimport { DRAW_TYPE, ERROR_CODES } from \"../../constants.js\";\nimport { Exception } from \"../Exception.js\";\nimport { ImageTempStorage } from \"../Temp/ImageTempStorage.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawTextObject extends DrawShapeObject {\n    #font;\n    #textAlign;\n    #textBaseline;\n    #fillStyle;\n    #strokeStyle;\n    #text;\n    #textMetrics;\n    /**\n     * @type {HTMLCanvasElement}\n     */\n    #textureCanvas = document.createElement(\"canvas\");\n\n    /**\n     * @type {ImageTempStorage}\n     */\n    #textureStorage;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(mapX, mapY, text, font, fillStyle) {\n        super(DRAW_TYPE.TEXT, mapX, mapY);\n        this.#text = text;\n        this.#font = font;\n        this.#fillStyle = fillStyle;\n        this.#textMetrics;\n        this.#calculateCanvasTextureAndMeasurements();\n    }\n\n    /**\n     * @deprecated\n     * Use collisionShapes()\n     * @type {Rectangle}\n     */\n    get boundariesBox() {\n        return this.collisionShapes;\n    }\n\n    /**\n     * Rectangle text box.\n     * @type {Rectangle}\n     */\n    get collisionShapes() {\n        const width = this.textMetrics ? Math.floor(this.textMetrics.width) : 300,\n            height = this.textMetrics ? Math.floor(this.textMetrics.fontBoundingBoxAscent + this.textMetrics.fontBoundingBoxDescent): 30;\n        return new Rectangle(this.x, this.y - height, width, height);\n    }\n\n    get vertices() {\n        const bb = this.collisionShapes;\n        return this._calculateRectVertices(bb.width, bb.height);\n    }\n\n    /**\n     * @type {string}\n     */\n    get text() {\n        return this.#text;\n    }\n\n    set text(value) {\n        if (value !== this.#text) {\n            this.#text = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get font() {\n        return this.#font;\n    }\n\n    set font(value) {\n        if (value !== this.#font) {\n            this.#font = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get textAlign() {\n        return this.#textAlign;\n    }\n\n    set textAlign(value) {\n        if (value !== this.#textAlign) {\n            this.#textAlign = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {string}\n     */\n    get textBaseline() {\n        return this.#textBaseline;\n    }\n\n    set textBaseline(value) {\n        if (value !== this.#textBaseline) {\n            this.#textBaseline = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * font color\n     * @type {string}\n     */\n    get fillStyle() {\n        return this.#fillStyle;\n    }\n\n    /**\n     * font color\n     */\n    set fillStyle(value) {\n        if (value !== this.#fillStyle) {\n            this.#fillStyle = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * font stroke color\n     * @type {string}\n     */\n    get strokeStyle() {\n        return this.#strokeStyle;\n    }\n\n    /**\n     * font stroke color\n     */\n    set strokeStyle(value) {\n        if (value !== this.#strokeStyle) {\n            this.#strokeStyle = value;\n            this.#calculateCanvasTextureAndMeasurements();\n        }\n    }\n\n    /**\n     * @type {TextMetrics}\n     */\n    get textMetrics() {\n        return this.#textMetrics;\n    }\n\n    /**\n     * @ignore\n     */\n    set _textMetrics(value) {\n        this.#textMetrics = value;\n    }\n\n    /**\n     * @ignore\n     */\n    get _textureStorage() {\n        return this.#textureStorage;\n    }\n\n    /**\n     * @ignore\n     */\n    set _textureStorage(texture) {\n        this.#textureStorage = texture;\n    }\n\n    /**\n     * @ignore\n     */\n    get _textureCanvas() {\n        return this.#textureCanvas;\n    }\n\n    /**\n     * \n     * @returns {void}\n     */\n    #calculateCanvasTextureAndMeasurements() {\n        const ctx = this.#textureCanvas.getContext(\"2d\", { willReadFrequently: true }); // cpu counting instead gpu\n        if (ctx) {\n            //ctx.clearRect(0, 0, this.#textureCanvas.width, this.#textureCanvas.height);\n            ctx.font = this.font;\n            this._textMetrics = ctx.measureText(this.text);\n            const boxWidth = this.collisionShapes.width, \n                boxHeight = this.collisionShapes.height;\n            \n            ctx.canvas.width = boxWidth;\n            ctx.canvas.height = boxHeight;\n            // after canvas resize, have to cleanup and set the font again\n            ctx.clearRect(0, 0, boxWidth, boxHeight);\n            ctx.font = this.font;\n            ctx.textBaseline = \"bottom\";// bottom\n            if (this.fillStyle) {\n                ctx.fillStyle = this.fillStyle;\n                ctx.fillText(this.text, 0, boxHeight);\n            } \n            if (this.strokeStyle) {\n                ctx.strokeStyle = this.strokeStyle;\n                ctx.strokeText(this.text, 0, boxHeight);\n            }\n            \n            if (this.#textureStorage) {\n                this.#textureStorage._isTextureRecalculated = true;\n            }\n\n            // debug canvas\n            // this.#textureCanvas.style.position = \"absolute\";\n            // document.body.appendChild(this.#textureCanvas);\n            \n        } else {\n            Exception(ERROR_CODES.UNHANDLED_EXCEPTION, \"can't getContext('2d')\");\n        }\n    }\n}","import { AnimationEvent } from \"../AnimationEvent.js\";\r\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\r\nimport { ImageTempStorage } from \"../Temp/ImageTempStorage.js\";\r\nimport { TiledLayerTempStorage } from \"../Temp/TiledLayerTempStorage.js\";\r\n/**\r\n * A render object represents a layer from tiled editor\r\n * @see {@link DrawObjectFactory} should be created with factory method\r\n */\r\nexport class DrawTiledLayer {\r\n    #layerKey;\r\n    #tileMapKey;\r\n    #tilemap;\r\n    #tilesets;\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #DELIMITER = \"-#-\";\r\n    #tilesetImages;\r\n    /**\r\n     * @type {Array<ImageTempStorage>}\r\n     */\r\n    #textureStorages;\r\n    #layerData;\r\n    #setCollisionShapes;\r\n    #drawCollisionShapes;\r\n    #attachedMaskId;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #sortIndex = 0;\r\n    /**\r\n     * @type {Map<string, AnimationEvent>}\r\n     */\r\n    #animations = new Map();\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isOffsetTurnedOff;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isRemoved = false;\r\n\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(layerKey, tileMapKey, tilemap, tilesets, tilesetImages, layerData, setCollisionShapes = false, shapeMask) {\r\n        this.#layerKey = layerKey;\r\n        this.#tileMapKey = tileMapKey;\r\n        this.#tilemap = tilemap;\r\n        this.#tilesets = tilesets;\r\n        this.#textureStorages = [];\r\n        this.#tilesetImages = tilesetImages;\r\n        this.#layerData = layerData;\r\n        \r\n        this.#setCollisionShapes = setCollisionShapes;\r\n        this.#drawCollisionShapes = setCollisionShapes ? setCollisionShapes : false;\r\n        if (shapeMask) {\r\n            this.setMask(shapeMask);\r\n        }\r\n        this.#processData(tilesets, layerData);\r\n    }\r\n\r\n    /**\r\n     * A layer name.\r\n     * @type {string}\r\n     */\r\n    get layerKey() {\r\n        return this.#layerKey;\r\n    }\r\n\r\n    /**\r\n     * A tilemap layer key, should match key from the tilemap.\r\n     * @type {string}\r\n     */\r\n    get tileMapKey() {\r\n        return this.#tileMapKey;\r\n    }\r\n\r\n    get tilemap() {\r\n        return this.#tilemap;\r\n    }\r\n    \r\n    get tilesets() {\r\n        return this.#tilesets;\r\n    }\r\n\r\n    get tilesetImages() {\r\n        return this.#tilesetImages;\r\n    }\r\n\r\n    get layerData() {\r\n        return this.#layerData;\r\n    }\r\n    /**\r\n     * Should the layer borders used as collision shapes, or not\r\n     * Can be set in GameStage.addRenderLayer() method.\r\n     * @type {boolean}\r\n     */\r\n    get setCollisionShapes() {\r\n        return this.#setCollisionShapes;\r\n    }\r\n\r\n    /**\r\n     * Should draw a collision shapes helper, or not\r\n     * Can be set in SystemSettings.\r\n     * @type {boolean}\r\n     */\r\n    get drawCollisionShapes() {\r\n        return this.#drawCollisionShapes;\r\n    }\r\n\r\n    set drawCollisionShapes(value) {\r\n        this.#drawCollisionShapes = value;\r\n    }\r\n\r\n    get isRemoved() {\r\n        return this.#isRemoved;\r\n    }\r\n\r\n    set isRemoved(value) {\r\n        this.#isRemoved = value;\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    get _maskId() {\r\n        return this.#attachedMaskId;\r\n    }\r\n    /**\r\n     * \r\n     * @param {DrawShapeObject} mask \r\n     */\r\n    setMask(mask) {\r\n        mask._isMask = true;\r\n        this.#attachedMaskId = mask.id;\r\n    }\r\n\r\n    removeMask() {\r\n        this.#attachedMaskId = null;\r\n    }\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    get sortIndex () {\r\n        return this.#sortIndex;\r\n    }\r\n\r\n    set sortIndex(value) {\r\n        this.#sortIndex = value;\r\n    }\r\n\r\n    get isOffsetTurnedOff() {\r\n        return this.#isOffsetTurnedOff;\r\n    }\r\n    turnOffOffset() {\r\n        this.#isOffsetTurnedOff = true;\r\n    }\r\n\r\n    /**\r\n     * Determines if image is animated or not\r\n     * @type {boolean}\r\n     */\r\n    get hasAnimations() {\r\n        return this.#animations.size > 0;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    get _textureStorages() {\r\n        return this.#textureStorages;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    _setTextureStorage(index, value) {\r\n        this.#textureStorages[index] = value;\r\n    }\r\n\r\n    /**\r\n     * Tilesets has a property tiles, which could contain tile animations\r\n     * or object collision shapes, this is workaround for split this and add\r\n     * additional properties for use in draw phase:\r\n     * _hasAnimations\r\n     * _animations - Map<id:activeSprite>\r\n     * _hasCollisionShapes\r\n     * _collisionShapes - Map<id:objectgroup>\r\n     * @param {*} tilesets\r\n     */\r\n    #processData(tilesets, layerData) {\r\n        //     ,       \r\n        //       \r\n        //        \r\n        let ellipseBLen = 0,\r\n            pointBLen = 0,\r\n            polygonBLen = 0;\r\n        tilesets.forEach((tileset, idx) => {\r\n            const tiles = tileset.tiles,\r\n                name = tileset.name,\r\n                firstgid = tileset.firstgid,\r\n                nextTileset = this.tilesets[idx + 1],\r\n                nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000;\r\n                \r\n            if (tiles) {\r\n                for (let tile of tiles) {\r\n                    const animation = tile.animation,\r\n                        objectgroup = tile.objectgroup,\r\n                        id = tile.id;\r\n                    if (animation) {\r\n                        const eventName = name + this.#DELIMITER + id, \r\n                            animationIndexes = this.#fixAnimationsItems(animation),\r\n                            animationEvent = new AnimationEvent(eventName, animationIndexes, true);\r\n\r\n                        this.#animations.set(eventName, animationEvent);\r\n                        // add additional properties\r\n                        if (!tileset._hasAnimations) {\r\n                            tileset._hasAnimations = true;\r\n                            tileset._animations = new Map();\r\n                            //\r\n                            tileset._animations.set(id, animationIndexes[0][0]);\r\n                        }\r\n                        this.#activateAnimation(animationEvent);\r\n                    }\r\n                    if (objectgroup && this.#setCollisionShapes) {\r\n                        if (tileset._hasCollisionShapes) {\r\n                            tileset._collisionShapes.set(id, objectgroup);\r\n                        } else {\r\n                            // add additional properties\r\n                            tileset._hasCollisionShapes = true;\r\n                            tileset._collisionShapes = new Map();\r\n                            tileset._collisionShapes.set(id, objectgroup);\r\n                        }\r\n                        objectgroup.objects.forEach((object) => {\r\n                            if (object.ellipse) {\r\n                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;\r\n                                ellipseBLen += (4 * cellsWithB); // (x, y, wRad, hRad) * layer items\r\n                            } else if (object.point) {\r\n                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;\r\n                                pointBLen += (2 * cellsWithB); // (x, y) * layer items\r\n                            } else if (object.polygon) {\r\n                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;\r\n                                polygonBLen += (object.polygon.length * 2 * cellsWithB); // (each point * 2(x,y) ) * layer items\r\n                            } else { // rect object\r\n                                const cellsWithB = layerData.data.filter((tile) => tile === id + firstgid).length;\r\n                                polygonBLen += (16 * cellsWithB); // (4 faces * 4 cords for each one) * layer items\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            \r\n            const nonEmptyCells = layerData.data.filter((tile) => ((tile >= firstgid) && (tile < nextgid))).length,\r\n                cells = layerData.data.length;\r\n\r\n            if (this.#setCollisionShapes) {\r\n                polygonBLen+=(nonEmptyCells * 16); // potential collision shapes also nonEmptyCells\r\n            }\r\n            //         \r\n            // help class for draw calculations\r\n            tileset._temp = new TiledLayerTempStorage(cells, nonEmptyCells);\r\n        });\r\n        \r\n        // save collision shapes max possible lengths\r\n        layerData.ellipseCollisionShapesLen = ellipseBLen;\r\n        layerData.pointCollisionShapesLen = pointBLen;\r\n        layerData.polygonCollisionShapesLen = polygonBLen;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Array<{duration:number, tileid:number}>} animation \r\n     * @returns {Array<{duration:number, id:number}>}\r\n     */\r\n    #fixAnimationsItems(animation) {\r\n        return animation.map((animation_item) => ({duration:animation_item.duration, id: animation_item.tileid}));\r\n    }\r\n    /**\r\n     * @ignore\r\n     */\r\n    _processActiveAnimations() {\r\n        for (let animationEvent of this.#animations.values()) {\r\n            if (animationEvent.isActive) {\r\n                animationEvent.iterateAnimationIndex();\r\n                this.#switchCurrentActiveSprite(animationEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    #activateAnimation = (animationEvent) => {\r\n        animationEvent.activateAnimation();\r\n        this.#switchCurrentActiveSprite(animationEvent);\r\n    }; \r\n\r\n    #switchCurrentActiveSprite = (animationEvent) => {\r\n        const [tilesetKey, animationId] = animationEvent.name.split(this.#DELIMITER),\r\n            tilesetIndex = this.#tilesets.findIndex(tileset => tileset.name === tilesetKey),\r\n            tileset = this.#tilesets[tilesetIndex];\r\n            \r\n        tileset._animations.set(parseInt(animationId), animationEvent.currentSprite);\r\n    };\r\n\r\n    /**\r\n     *\r\n     * @param {string} eventName - animation name\r\n     */\r\n    stopRepeatedAnimation (eventName) {\r\n        this.#animations.get(eventName).deactivateAnimation();\r\n    }\r\n\r\n    /**\r\n     * Removes animations\r\n     */\r\n    removeAllAnimations() {\r\n        for (let [eventName, animationEvent] of this.#animations.entries()) {\r\n            this.removeEventListener(eventName, animationEvent.activateAnimation);\r\n            animationEvent.deactivateAnimation();\r\n        }\r\n        this.#animations.clear();\r\n        this.#animations = undefined;\r\n    }\r\n\r\n    destroy() {\r\n        this.removeAllAnimations();\r\n        super.destroy();\r\n    }\r\n}\r\n","class Vertex {\n    #x;\n    #y;\n    constructor(x, y) {\n        this.#x = x;\n        this.#y = y;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n}\n\nclass Rectangle {\n    #x;\n    #y;\n    #w;\n    #h;\n    constructor(x, y, w, h) {\n        this.#x = x;\n        this.#y = y;\n        this.#w = w;\n        this.#h = h; \n    }\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n    /**\n     * @type {number}\n     */\n    get y() {\n        return this.#y;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n}\n\nclass Vector {\n    #x;\n    #y;\n    constructor(x1, y1, x2, y2) {\n        this.#x = x2 - x1;\n        this.#y = y2 - y1;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n\n    get length() {\n        return Math.sqrt(Math.pow(this.#x, 2) + Math.pow(this.#y, 2));\n    }\n\n    get tetaAngle() {\n        return Math.atan2(this.#y, this.#x);\n    }\n}\n\nexport { Vertex, Rectangle, Vector };","export class AnimationEvent {\n    #eventName;\n    /**\n     * @type {number}\n     */\n    #defaultDurationTime = 100;\n    /**\n     * Array [sprite index, duration]\n     * @type { Array<Array<number, number>> }\n     */\n    #animationSpriteIndexes;\n    /**\n     * \n     * @type {number}\n     */\n    #currentAnimationItemIndex;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {boolean}\n     */\n    #isRepeated;\n    /**\n     * @type {number}\n     */\n    #lastAnimationTimeStamp;\n    \n    constructor(eventName, animationSpriteIndexes, isRepeated = false, currentSpriteIndex, isActive = false) {\n        this.#eventName = eventName;\n        this.#animationSpriteIndexes = this.#convertToArray(animationSpriteIndexes);\n        this.#currentAnimationItemIndex = currentSpriteIndex ? currentSpriteIndex : 0;\n        this.#isActive = isActive;\n        this.#isRepeated = isRepeated;\n    }\n\n    get name() {\n        return this.#eventName;\n    }\n\n    get isActive() {\n        return this.#isActive;\n    }\n\n    get currentSprite() {\n        return this.#animationSpriteIndexes[this.#currentAnimationItemIndex][0];\n    }\n\n    get _isLastSprite() {\n        return (this.#animationSpriteIndexes.length - 1) === this.#currentAnimationItemIndex;\n    }\n\n    iterateAnimationIndex() {\n        const currentIndex = this.#currentAnimationItemIndex,\n            currentDuration = this.#animationSpriteIndexes[currentIndex][1],\n            lastIterationTime = Date.now() - this.#lastAnimationTimeStamp;\n        // iterate or skip\n        if (currentDuration < lastIterationTime) {\n            if (!this._isLastSprite) {\n                this.#currentAnimationItemIndex++;\n            } else {\n                if (!this.#isRepeated) {\n                    this.deactivateAnimation();\n                } else {\n                    // take first element\n                    this.#currentAnimationItemIndex = 0;\n                    \n                }\n            }\n            // reset timestamp\n            this.#lastAnimationTimeStamp = Date.now();\n        }\n    }\n\n    activateAnimation = () => {\n        this.#isActive = true;\n        this.#currentAnimationItemIndex = 0;\n        this.#lastAnimationTimeStamp = Date.now();\n    };\n\n    deactivateAnimation = () => {\n        this.#isActive = false;\n    };\n\n    #convertToArray(animationSpriteIndexes) {\n        let animationArray = [];\n        animationSpriteIndexes.forEach(element => {\n            if (typeof element.id === \"number\" && typeof element.duration === \"number\") {\n                animationArray.push([element.id, element.duration]);\n            } else {\n                animationArray.push([element, this.#defaultDurationTime]);\n            }\n            \n        });\n        return animationArray;\n    }\n}","import { DrawRectObject } from \"./2d/DrawRectObject.js\";\r\nimport { DrawTextObject } from \"./2d/DrawTextObject.js\";\r\nimport { DrawConusObject } from \"./2d/DrawConusObject.js\";\r\nimport { DrawImageObject } from \"./2d/DrawImageObject.js\";\r\nimport { DrawLineObject } from \"./2d/DrawLineObject.js\";\r\nimport { DrawPolygonObject } from \"./2d/DrawPolygonObject.js\";\r\nimport { DrawCircleObject } from \"./2d/DrawCircleObject.js\";\r\nimport { DrawTiledLayer } from \"./2d/DrawTiledLayer.js\";\r\nimport { DrawShapeObject } from \"./2d/DrawShapeObject.js\";\r\nimport { GameStageData } from \"./GameStageData.js\";\r\nimport { Exception, Warning } from \"./Exception.js\";\r\nimport { ERROR_CODES, WARNING_CODES } from \"../constants.js\";\r\nimport AssetsManager from \"../../modules/assetsm/src/AssetsManager.js\";\r\n\r\n/**\r\n * Creates drawObjects instances.<br>\r\n * accessible via GameStage.draw <br>\r\n * Attach images for image objects and tilemaps <br>\r\n * Adds drawObjects to current GameStage.stageData\r\n * @see {@link GameStage} a part of GameStage\r\n */\r\nexport class DrawObjectFactory {\r\n    /**\r\n     * @type {AssetsManager}\r\n     */\r\n    #iLoader;\r\n    /**\r\n     * @type {GameStageData | null}\r\n     */\r\n    #currentPageData;\r\n    /**\r\n     * @hideconstructor \r\n     */\r\n    constructor(iLoader) {\r\n        this.#iLoader = iLoader;\r\n    }\r\n\r\n    get stageData() {\r\n        return this.#currentPageData;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} renderObject \r\n     * @returns {void}\r\n     */\r\n    #addObjectToPageData(renderObject) {\r\n        this.#currentPageData._renderObject = renderObject;\r\n    }\r\n    /**\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @param {string} backgroundColor - rgba(r,g,b,a)\r\n     * @returns {DrawRectObject}\r\n     */\r\n    rect(x, y, width, height, backgroundColor) {\r\n        const renderObject = new DrawRectObject(x, y, width, height, backgroundColor);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject; \r\n    }\r\n\r\n    /**\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {string} text \r\n     * @param {string} font - size fontFamily\r\n     * @param {string} color - rgba(r,g,b,a)\r\n     * @returns {DrawTextObject}\r\n     */\r\n    text(x, y, text, font, color) {\r\n        const renderObject = new DrawTextObject(x, y, text, font, color);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} radius \r\n     * @param {string} bgColor - rgba(r,g,b,a)\r\n     * @param {number=} angle\r\n     * @param {number=} [fade=0] (0 - 1)\r\n     * @returns {DrawConusObject}\r\n     */\r\n    conus(x, y, radius, bgColor, angle, fade = 0) {\r\n        const renderObject = new DrawConusObject(x, y, radius, bgColor, angle, fade);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} radius \r\n     * @param {string} bgColor - rgba(r,g,b,a)\r\n     * @returns {DrawCircleObject}\r\n     */\r\n    circle(x, y, radius, bgColor) {\r\n        const renderObject = new DrawCircleObject(x, y, radius, bgColor);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @param {string} key \r\n     * @param {number} [imageIndex = 0]\r\n     * @param {Array<{x:Number, y:Number}> | {r:number}=} collisionShapes - collision shapes as polygon, or circle\r\n     * @param {number} [spacing = 0] - for tilesets.spacing > 0\r\n     * @param {number} [margin = 0] - for tilesets.margin > 0\r\n     * @returns {DrawImageObject}\r\n     */\r\n    image(x, y, width, height, key, imageIndex = 0, collisionShapes, spacing = 0, margin = 0) {\r\n        const image = this.#iLoader.getImage(key);\r\n\r\n        if (!image) {\r\n            Exception(ERROR_CODES.CANT_GET_THE_IMAGE, \"iLoader can't get the image with key: \" + key);\r\n        }\r\n            \r\n        const renderObject = new DrawImageObject(x, y, width, height, key, imageIndex, collisionShapes, image, spacing, margin);\r\n        \r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * @param {Array<number>} vertices \r\n     * @param {string} color - rgba(r,g,b,a)\r\n     * @returns {DrawLineObject}\r\n     */\r\n    line(vertices, color) {\r\n        const renderObject = new DrawLineObject(vertices, color);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * @param {Array<{x:number, y:number}>} vertices - should go in anticlockwise order\r\n     * @param {string} bgColor - rgba(r,g,b,a)\r\n     * @returns {DrawPolygonObject}\r\n     */\r\n    polygon(vertices, bgColor) {\r\n        const renderObject = new DrawPolygonObject(vertices, bgColor);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} layerKey \r\n     * @param {string} tileMapKey \r\n     * @param {boolean=} setCollisionShapes \r\n     * @param {DrawShapeObject=} shapeMask \r\n     * @returns {DrawTiledLayer}\r\n     */\r\n    tiledLayer(layerKey, tileMapKey, setCollisionShapes, shapeMask) {\r\n        const tilemap = this.#iLoader.getTileMap(tileMapKey),\r\n            layerData = Object.assign({}, tilemap.layers.find((layer) => layer.name === layerKey)), // copy to avoid change same tilemap instance in different tiledLayers\r\n            tilesetIds = Array.from(new Set(layerData.data.filter((id) => id !== 0))).sort((a, b) => a - b),\r\n            tilesets = tilemap.tilesets.map((tileset) => Object.assign({}, tileset)).filter((tileset) => {\r\n                const tilesetStartI = tileset.firstgid,\r\n                    tilesetLastI = tilesetStartI + tileset.tilecount;\r\n                if (tilesetIds.find((id) => ((id >= tilesetStartI) && (id < tilesetLastI)))) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            }), // copy to avoid change same tilemap instance in different tiledLayers\r\n            tilesetImages = tilesets.map((tileset) => this.#iLoader.getImage(tileset.name)),\r\n            renderObject = new DrawTiledLayer(layerKey, tileMapKey, tilemap, tilesets, tilesetImages, layerData, setCollisionShapes, shapeMask);\r\n        if (tilesetImages.length > 1) {\r\n            Warning(WARNING_CODES.MULTIPLE_IMAGE_TILESET, \" tileset \" + layerKey + \" includes multiple images, it can case performance issues!\");\r\n        }\r\n        //console.log(layerKey);\r\n        //console.log(tilesetIds);\r\n        this.#addObjectToPageData(renderObject);\r\n        return renderObject;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {string} methodKey \r\n     * @param {Function} createObjectInstance\r\n     */\r\n    _registerNewObjectMethod = (methodKey, createObjectInstance) => {\r\n        this[methodKey] = (...args) => this.#createObjectAndAddToPageData(createObjectInstance, ...args);\r\n    };\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {Function} createInstance\r\n     * @param {Array<any>} args\r\n     */\r\n    #createObjectAndAddToPageData = (createInstance, ...args) => {\r\n        const instance = createInstance(...args);\r\n        this.#addObjectToPageData(instance);\r\n        return instance;\r\n    };\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {GameStageData} pageData;\r\n     */\r\n    _attachPageData = (pageData) => {\r\n        this.#currentPageData = pageData;\r\n    };\r\n    /**\r\n     * @ignore\r\n     */\r\n    _detachPageData = () => {\r\n        this.#currentPageData = null;\r\n    };\r\n}","import { CONST, ERROR_CODES } from \"../../constants.js\";\nimport { Exception } from \"../Exception.js\";\n\nexport class SystemEvent extends Event {\n    #data;\n    constructor(eventValue, data){\n        super(eventValue);\n        if (!this.#isEventExist(eventValue)) {\n            Exception(ERROR_CODES.UNEXPECTED_EVENT_NAME, \", Please check if event is exist\");\n        }\n        this.#data = data;\n    }\n\n    #isEventExist(eventValue) {\n        return Object.values(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT).find(eventVal => eventVal === eventValue);\n    }\n\n    get data () {\n        return this.#data;\n    }\n}","export function Exception (code, message) {\n    throw new Error(code + \": \" + message);\n}\n\nexport function Warning (code, message) {\n    console.warn(code, message);\n}","import { DRAW_TYPE, ERROR_CODES, WARNING_CODES } from \"../constants.js\";\r\nimport { GameStageData } from \"./GameStageData.js\";\r\nimport { Exception, Warning } from \"./Exception.js\";\r\nimport AssetsManager from \"../../modules/assetsm/src/AssetsManager.js\";\r\nimport { DrawObjectFactory } from \"./DrawObjectFactory.js\";\r\nimport { DrawCircleObject } from \"./2d/DrawCircleObject.js\";\r\nimport { DrawConusObject } from \"./2d/DrawConusObject.js\";\r\nimport { DrawImageObject } from \"./2d/DrawImageObject.js\";\r\nimport { DrawLineObject } from \"./2d/DrawLineObject.js\";\r\nimport { DrawPolygonObject } from \"./2d/DrawPolygonObject.js\";\r\nimport { DrawRectObject } from \"./2d/DrawRectObject.js\";\r\nimport { DrawTextObject } from \"./2d/DrawTextObject.js\";\r\nimport { ISystem } from \"./ISystem.js\";\r\nimport { ISystemAudio } from \"./ISystemAudio.js\";\r\nimport { SystemSettings } from \"../configs.js\";\r\nimport { isPointLineIntersect, isEllipseCircleIntersect, isPointCircleIntersect, isEllipsePolygonIntersect, isPolygonLineIntersect, isPointPolygonIntersect, angle_2points, isCircleLineIntersect } from \"../utils.js\";\r\nimport { Vector } from \"./2d/Primitives.js\";\r\n\r\n/**\r\n * Represents the stage of the game,<br>\r\n * Contains pages logic.<br>\r\n * Instances should be created and registered with System.registerStage() factory method\r\n * \r\n * @see {@link System} instances of this class holds by the System class\r\n * @hideconstructor\r\n * @abstract\r\n */\r\nexport class GameStage {\r\n    /**\r\n     * @type {string}\r\n     */\r\n    #name;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isInitiated = false;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isActive;\r\n    /**\r\n     * @type {ISystem}\r\n     */\r\n    #iSystemReference;\r\n    /**\r\n     * @type {GameStageData}\r\n     */\r\n    #stageData;\r\n\r\n    constructor() {\r\n        this.#isActive = false;\r\n        \r\n    }\r\n\r\n    /**\r\n     * Register stage\r\n     * @param {string} name\r\n     * @param {ISystem} system \r\n     * @ignore\r\n     */\r\n    _register(name, system) {\r\n        this.#name = name;\r\n        this.#iSystemReference = system;\r\n        this.#stageData = new GameStageData(this.#iSystemReference.systemSettings.gameOptions);\r\n        this.#setWorldDimensions();\r\n        this.#setCanvasSize();\r\n        this.register();\r\n    }\r\n\r\n    /**\r\n     * Initialization stage\r\n     * @ignore\r\n     */\r\n    _init() {\r\n        this.init();\r\n        this.#isInitiated = true;\r\n    }\r\n\r\n    /**\r\n     * @tutorial stages_lifecycle\r\n     * Custom logic for register stage\r\n     */\r\n    register() {}\r\n    /**\r\n     * @tutorial stages_lifecycle\r\n     * Custom logic for init stage\r\n     */\r\n    init() {}\r\n    /**\r\n     * Custom logic for start stage\r\n     * @param {Object=} options\r\n     */\r\n    start(options) {}\r\n    /**\r\n     * @tutorial stages_lifecycle\r\n     * Custom logic for stop stage\r\n     */\r\n    stop() {}\r\n    /**\r\n     * Custom logic for resize stage\r\n     */\r\n    resize() {}\r\n\r\n    /**\r\n     * @tutorial assets_manager\r\n     * @returns {AssetsManager}\r\n     */\r\n    get iLoader() {\r\n        return this.#iSystemReference.iLoader;\r\n    }\r\n\r\n    /**\r\n     * @returns {DrawObjectFactory}\r\n     */\r\n    get draw() {\r\n        return this.#iSystemReference.drawObjectFactory;\r\n    }\r\n\r\n    /**\r\n     * Attach all canvas elements from the #views to container\r\n     * @param {HTMLElement} container\r\n     * @ignore\r\n     */\r\n    _attachCanvasToContainer(container) {\r\n        this.#attachElementToContainer(this.canvasHtmlElement, container);\r\n    }\r\n\r\n    /**\r\n     * Add render object to the stageData\r\n     * @param { DrawConusObject | DrawImageObject | \r\n     *          DrawLineObject | DrawPolygonObject | \r\n     *          DrawRectObject | DrawCircleObject | \r\n     *          DrawTextObject } renderObject \r\n     */\r\n    addRenderObject = (renderObject) => {\r\n        const data = this.stageData,\r\n            isDataAlreadyAdded = data.renderObjects.indexOf(renderObject) !== -1;\r\n        if (isDataAlreadyAdded) {\r\n            Warning(WARNING_CODES.NEW_BEHAVIOR_INTRODUCED, \"stage.draw methods add objects to pageData, no need to call addRenderObject\");\r\n        } else {\r\n            data._renderObject = renderObject;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determines if this stage render is Active or not\r\n     * @returns {boolean}\r\n     */\r\n    get isActive() {\r\n        return this.#isActive;\r\n    }\r\n\r\n    /**\r\n     * Determines if this stage is initialized or not\r\n     * @returns {boolean}\r\n     */\r\n    get isInitiated() {\r\n        return this.#isInitiated;\r\n    }\r\n\r\n    /**\r\n     * Current stage name\r\n     * @returns {string}\r\n     */\r\n    get name () {\r\n        return this.#name;\r\n    }\r\n\r\n    /**\r\n     * @returns {GameStageData}\r\n     */\r\n    get stageData() {\r\n        return this.#stageData;\r\n    }\r\n\r\n    /**\r\n     * @returns {SystemSettings}\r\n     */\r\n    get systemSettings() {\r\n        return this.#iSystemReference.systemSettings;\r\n    }\r\n\r\n    /**\r\n     * @returns {ISystemAudio}\r\n     */\r\n    get audio() {\r\n        return this.#iSystemReference.audio;\r\n    }\r\n\r\n    /**\r\n     * @returns {ISystem}\r\n     */\r\n    get iSystem() {\r\n        return this.#iSystemReference;\r\n    }\r\n\r\n    get canvasHtmlElement() {\r\n        return document.getElementsByTagName(\"canvas\")[0];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    addEventListener = (eventName, listener, options) => {\r\n        this.iSystem.addEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    removeEventListener = (eventName, listener, options) => {\r\n        this.iSystem.removeEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * Start stage render\r\n     * @param {Object=} options \r\n     * @ignore\r\n     */\r\n    _start(options) {\r\n        this.start(options);\r\n        this.#isActive = true;\r\n        window.addEventListener(\"resize\", this._resize);\r\n        this._resize();\r\n    }\r\n\r\n    /**\r\n     * Stop stage render\r\n     * @ignore\r\n     */\r\n    _stop() {\r\n        this.#isActive = false;\r\n        window.removeEventListener(\"resize\", this._resize);\r\n        this.stop();\r\n    }\r\n\r\n    /**\r\n     * Resize event\r\n     * @ignore\r\n     */\r\n    _resize = () => {\r\n        this.#setCanvasSize();\r\n        this.resize();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {HTMLCanvasElement} htmlElement \r\n     * @param {HTMLElement} container \r\n     */\r\n    #attachElementToContainer(htmlElement, container) {\r\n        container.appendChild(htmlElement);\r\n    }\r\n\r\n    #setWorldDimensions() {\r\n        const width = this.systemSettings.worldSize ? this.systemSettings.worldSize.width : 0,\r\n            height = this.systemSettings.worldSize ? this.systemSettings.worldSize.height : 0;\r\n            \r\n        this.stageData._setWorldDimensions(width, height);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    //***************************************************/\r\n    //****************** Collisions ********************//\r\n    //**************************************************//\r\n    //////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * \r\n     * Backward capability with jsge before 1.5.9\r\n     * @deprecated\r\n     * isCollision()\r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {DrawImageObject} drawObject \r\n     * @returns {{x:number, y:number, p:number} | boolean}\r\n     */\r\n    isBoundariesCollision = (x, y, drawObject) => {\r\n        return this.isCollision(x, y, drawObject);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {DrawImageObject} drawObject \r\n     * @returns {{x:number, y:number, p:number} | boolean}\r\n     */\r\n    isCollision = (x, y, drawObject) => {\r\n        const drawObjectType = drawObject.type,\r\n            vertices = drawObject.vertices,\r\n            circleCollisionShapes = drawObject.circleCollisionShapes;\r\n        switch(drawObjectType) {\r\n            case DRAW_TYPE.TEXT:\r\n            case DRAW_TYPE.RECTANGLE:\r\n            case DRAW_TYPE.CONUS:\r\n            case DRAW_TYPE.IMAGE:\r\n                if (!circleCollisionShapes) {\r\n                    return this.#isPolygonToCollisionShapesCollision(x, y, vertices, drawObject.rotation);\r\n                } else {\r\n                    return this.#isCircleToCollisionShapesCollision(x, y, drawObject.circleCollisionShapes.r);\r\n                }\r\n            case DRAW_TYPE.CIRCLE:\r\n                Warning(WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\r\n                break;\r\n            case DRAW_TYPE.LINE:\r\n                Warning(WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\r\n                break;\r\n            default:\r\n                Warning(WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\r\n        }\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {DrawImageObject} drawObject\r\n     * @param {Array<DrawImageObject>} objects - objects array to check\r\n     * @returns {Array<Object> | boolean} - array of objects with collisions, or false if no collision happen\r\n     */\r\n    isObjectsCollision = (x, y, drawObject, objects) => {\r\n        const drawObjectType = drawObject.type,\r\n            drawObjectCollisionShapes = drawObject.vertices,\r\n            circleCollisionShapes = drawObject.circleCollisionShapes;\r\n        switch(drawObjectType) {\r\n            case DRAW_TYPE.TEXT:\r\n            case DRAW_TYPE.RECTANGLE:\r\n            case DRAW_TYPE.CONUS:\r\n            case DRAW_TYPE.IMAGE:\r\n                if (!circleCollisionShapes) {\r\n                    return this.#isPolygonToObjectsCollision(x, y, drawObjectCollisionShapes, drawObject.rotation, objects);\r\n                } else {\r\n                    return this.#isCircleToObjectsCollision(x, y, circleCollisionShapes, objects);\r\n                }\r\n            case DRAW_TYPE.CIRCLE:\r\n                Warning(WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\r\n                break;\r\n            case DRAW_TYPE.LINE:\r\n                Warning(WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\r\n                break;\r\n            default:\r\n                Warning(WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\r\n        }\r\n        return false;\r\n    };\r\n    #isPolygonToObjectsCollision(x, y, polygonVertices, polygonRotation, objects) {\r\n        const len = objects.length;\r\n\r\n        let collisions = [];\r\n        for (let i = 0; i < len; i++) {\r\n            const mapObject = objects[i],\r\n                drawMapObjectType = mapObject.type;\r\n\r\n            let coll;\r\n            \r\n            switch(drawMapObjectType) {\r\n            case DRAW_TYPE.TEXT:\r\n            case DRAW_TYPE.RECTANGLE:\r\n            case DRAW_TYPE.CONUS:\r\n            case DRAW_TYPE.IMAGE:\r\n                coll = this.#isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject);\r\n                break;\r\n            case DRAW_TYPE.CIRCLE:\r\n                console.warn(\"isObjectCollision.circle check is not implemented yet!\");\r\n                break;\r\n            case DRAW_TYPE.LINE:\r\n                console.warn(\"isObjectCollision.line check is not implemented, please use rect instead\");\r\n                break;\r\n            default:\r\n                console.warn(\"unknown object type!\");\r\n            }\r\n            if (coll) {\r\n                collisions.push(mapObject);\r\n            }\r\n        }\r\n        if (collisions.length > 0) {\r\n            return collisions;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    #isCircleToObjectsCollision(x, y, drawObjectCollisionShapes, objects) {\r\n        const radius = drawObjectCollisionShapes.r;\r\n\r\n        const len = objects.length;\r\n\r\n        let collisions = [];\r\n        for (let i = 0; i < len; i++) {\r\n            const mapObject = objects[i],\r\n                drawMapObjectType = mapObject.type,\r\n                circleCollisionShapes = mapObject.circleCollisionShapes;\r\n\r\n            /**\r\n             * @type {boolean | Object}\r\n             */\r\n            let coll;\r\n            \r\n            switch(drawMapObjectType) {\r\n                case DRAW_TYPE.TEXT:\r\n                case DRAW_TYPE.RECTANGLE:\r\n                case DRAW_TYPE.CONUS:\r\n                case DRAW_TYPE.IMAGE:\r\n                    if (!circleCollisionShapes) {\r\n                        coll = this.#isCircleToPolygonCollision(x, y, radius, mapObject);\r\n                    } else {\r\n                        coll = this.#isCircleToCircleCollision(x, y, radius, mapObject.x, mapObject.y, circleCollisionShapes.r);\r\n                    }\r\n                    break;\r\n                case DRAW_TYPE.CIRCLE:\r\n                    console.warn(\"isObjectCollision.circle check is not implemented yet!\");\r\n                    break;\r\n                case DRAW_TYPE.LINE:\r\n                    console.warn(\"isObjectCollision.line check is not implemented, please use rect instead\");\r\n                    break;\r\n                default:\r\n                    console.warn(\"unknown object type!\");\r\n            }\r\n            if (coll) {\r\n                collisions.push(mapObject);\r\n            }\r\n        }\r\n        if (collisions.length > 0) {\r\n            return collisions;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    #takeTheClosestCollision(collisions) {\r\n        return collisions.sort((a,b) => a.p < b.p)[0];\r\n    }\r\n\r\n    #isCircleToPolygonCollision(x, y, radius, mapObject) {\r\n        const [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\r\n            xWithOffset = x - mapOffsetX,\r\n            yWithOffset = y - mapOffsetY,\r\n            mapObjXWithOffset = mapObject.x - mapOffsetX,\r\n            mapObjYWithOffset = mapObject.y - mapOffsetY,\r\n            mapObjVertices = mapObject.vertices, \r\n            mapObjRotation = mapObject.rotation,\r\n            len = mapObjVertices.length;\r\n        //console.log(\"map object check:\");\r\n        //console.log(mapObject);\r\n        for (let i = 0; i < len; i+=1) {\r\n            const mapObjFirstVertex = mapObjVertices[i];\r\n            let mapObjNextVertex = mapObjVertices[i + 1];\r\n            if (!mapObjNextVertex) {\r\n                mapObjNextVertex = mapObjVertices[0];\r\n            }\r\n            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\r\n                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\r\n                edge = {\r\n                    x1: vertex[0],\r\n                    y1: vertex[1],\r\n                    x2: nextVertex[0],\r\n                    y2: nextVertex[1]\r\n                },\r\n                intersect = isCircleLineIntersect(xWithOffset, yWithOffset, radius, edge);\r\n            if (intersect) {\r\n            //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n            //console.log(\"intersect: \", intersect);\r\n                return intersect;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    #isCircleToCircleCollision(circle1X, circle1Y, circle1R, circle2X, circle2Y, circle2R) {\r\n        const len = new Vector(circle1X, circle1Y, circle2X, circle2Y).length;\r\n        if ((len - (circle1R + circle2R)) > 0) {\r\n            return false;\r\n        } else {\r\n            //@todo calculate point of intersect\r\n            return true;\r\n        }\r\n    }\r\n\r\n    #isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject) {\r\n        const [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\r\n            xWithOffset = x - mapOffsetX,\r\n            yWithOffset = y - mapOffsetY,\r\n            mapObjXWithOffset = mapObject.x - mapOffsetX,\r\n            mapObjYWithOffset = mapObject.y - mapOffsetY,\r\n            mapObjVertices = mapObject.vertices, \r\n            mapObjRotation = mapObject.rotation,\r\n            polygonWithOffsetAndRotation = polygonVertices.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, polygonRotation))),\r\n            len = mapObjVertices.length;\r\n        //console.log(\"map object check:\");\r\n        //console.log(mapObject);\r\n        for (let i = 0; i < len; i+=1) {\r\n            const mapObjFirstVertex = mapObjVertices[i];\r\n            let mapObjNextVertex = mapObjVertices[i + 1];\r\n            if (!mapObjNextVertex) {\r\n                mapObjNextVertex = mapObjVertices[0];\r\n            }\r\n            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\r\n                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\r\n                edge = {\r\n                    x1: vertex[0],\r\n                    y1: vertex[1],\r\n                    x2: nextVertex[0],\r\n                    y2: nextVertex[1]\r\n                },\r\n                intersect = isPolygonLineIntersect(polygonWithOffsetAndRotation, edge);\r\n            if (intersect) {\r\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                //console.log(\"intersect: \", intersect);\r\n                return intersect;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    #calculateShiftedVertexPos(vertex, centerX, centerY, rotation) {\r\n        const vector = new Vector(0, 0, vertex[0], vertex[1]),\r\n            vertexAngle = angle_2points(0, 0, vertex[0], vertex[1]),\r\n            len = vector.length;\r\n            \r\n        const newX = centerX + (len * Math.cos(rotation + vertexAngle)),\r\n            newY = centerY + (len * Math.sin(rotation + vertexAngle));\r\n        return [newX, newY];\r\n    }\r\n    /**\r\n     * \r\n     * @param {number} x \r\n     * @param {number} y \r\n     * @param {number} r \r\n     * @returns {{x:number, y:number, p:number} | boolean}\r\n     */\r\n    #isCircleToCollisionShapesCollision(x, y, r) {\r\n        const mapObjects = this.stageData.getRawCollisionShapes(),\r\n            ellipseB = this.stageData.getEllipseCollisionShapes(),\r\n            pointB = this.stageData.getPointCollisionShapes(),\r\n            [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\r\n            xWithOffset = x - mapOffsetX,\r\n            yWithOffset = y - mapOffsetY,\r\n            len = this.stageData.collisionShapesLen,\r\n            eLen = this.stageData.ellipseBLen,\r\n            pLen = this.stageData.pointBLen;\r\n\r\n        for (let i = 0; i < len; i+=4) {\r\n            const x1 = mapObjects[i],\r\n                y1 = mapObjects[i + 1],\r\n                x2 = mapObjects[i + 2],\r\n                y2 = mapObjects[i + 3];\r\n\r\n            if (x1 === 0 && y1 === 0 && x2 === 0 && y2 === 0) {\r\n                continue;\r\n            } else {\r\n                const intersect = isCircleLineIntersect(xWithOffset, yWithOffset, r, {x1, y1, x2, y2});\r\n                \r\n                if (intersect) {\r\n                    //console.log(\"rotation: \", rotation);\r\n                    //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                    //console.log(\"intersect: \", intersect);\r\n                    return intersect;\r\n                }\r\n            }\r\n        }\r\n        if (eLen > 0) {\r\n            for (let i = 0; i < eLen; i+=4) {\r\n                const ellipse = [ellipseB[i], ellipseB[i+1], ellipseB[i+2], ellipseB[i+3]],\r\n                    intersect = isEllipseCircleIntersect(ellipse, {x:xWithOffset, y:yWithOffset, r});\r\n                if (intersect) {\r\n                    //console.log(\"rotation: \", rotation);\r\n                    //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                    //console.log(\"intersect: \", intersect);\r\n                    return intersect;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (pLen > 0) {\r\n            for (let i = 0; i < pLen; i+=2) {\r\n                const xP = pointB[i],\r\n                    yP = pointB[i + 1],\r\n                    intersect = isPointCircleIntersect(xP, yP, {x:xWithOffset, y:yWithOffset, r});\r\n                if (intersect) {\r\n                    //console.log(\"rotation: \", rotation);\r\n                    //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                    //console.log(\"intersect: \", intersect);\r\n                    return intersect;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @param {number} x\r\n     * @param {number} y\r\n     * @param {Array<Array<number>>} polygon\r\n     * @param {number} rotation\r\n     * @returns {{x:number, y:number, p:number} | boolean}\r\n     */\r\n    #isPolygonToCollisionShapesCollision(x, y, polygon, rotation) {\r\n        const mapObjects = this.stageData.getRawCollisionShapes(),\r\n            ellipseB = this.stageData.getEllipseCollisionShapes(),\r\n            pointB = this.stageData.getPointCollisionShapes(),\r\n            [mapOffsetX, mapOffsetY] = this.stageData.worldOffset,\r\n            xWithOffset = x - mapOffsetX,\r\n            yWithOffset = y - mapOffsetY,\r\n            polygonWithOffsetAndRotation = polygon.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, rotation))),\r\n            len = this.stageData.collisionShapesLen,\r\n            eLen = this.stageData.ellipseBLen,\r\n            pLen = this.stageData.pointBLen;\r\n\r\n        for (let i = 0; i < len; i+=4) {\r\n            const x1 = mapObjects[i],\r\n                y1 = mapObjects[i + 1],\r\n                x2 = mapObjects[i + 2],\r\n                y2 = mapObjects[i + 3];\r\n\r\n            if (x1 === 0 && y1 === 0 && x2 === 0 && y2 === 0) {\r\n                continue;\r\n            } else {\r\n                const intersect = isPolygonLineIntersect(polygonWithOffsetAndRotation, {x1, y1, x2, y2});\r\n                if (intersect) {\r\n                    //console.log(\"rotation: \", rotation);\r\n                    //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                    //console.log(\"intersect: \", intersect);\r\n                    return intersect;\r\n                }\r\n            }\r\n        }\r\n        if (eLen > 0) {\r\n            for (let i = 0; i < eLen; i+=4) {\r\n                const ellipse = [ellipseB[i], ellipseB[i+1], ellipseB[i+2], ellipseB[i+3]],\r\n                    intersect = isEllipsePolygonIntersect(ellipse, polygonWithOffsetAndRotation);\r\n                if (intersect) {\r\n                    //console.log(\"rotation: \", rotation);\r\n                    //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                    //console.log(\"intersect: \", intersect);\r\n                    return intersect;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (pLen > 0) {\r\n            for (let i = 0; i < pLen; i+=2) {\r\n                const x = pointB[i],\r\n                    y = pointB[i+1],\r\n                    intersect = isPointPolygonIntersect(x, y, polygonWithOffsetAndRotation);\r\n                if (intersect) {\r\n                //console.log(\"rotation: \", rotation);\r\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\r\n                //console.log(\"intersect: \", intersect);\r\n                    return intersect;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    //****************** End Collisions ****************//\r\n\r\n    #setCanvasSize() {\r\n        const canvasWidth = this.systemSettings.canvasMaxSize.width && (this.systemSettings.canvasMaxSize.width < window.innerWidth) ? this.systemSettings.canvasMaxSize.width : window.innerWidth,\r\n            canvasHeight = this.systemSettings.canvasMaxSize.height && (this.systemSettings.canvasMaxSize.height < window.innerHeight) ? this.systemSettings.canvasMaxSize.height : window.innerHeight;\r\n        this.stageData._setCanvasDimensions(canvasWidth, canvasHeight);\r\n    }\r\n}","import { WARNING_CODES } from \"../constants.js\";\r\nimport { Warning } from \"./Exception.js\";\r\n\r\nimport { DrawTiledLayer } from \"./2d/DrawTiledLayer.js\";\r\nimport { DrawImageObject } from \"./2d/DrawImageObject.js\";\r\nimport { DrawCircleObject } from \"./2d/DrawCircleObject.js\";\r\nimport { DrawConusObject } from \"./2d/DrawConusObject.js\";\r\nimport { DrawLineObject } from \"./2d/DrawLineObject.js\";\r\nimport { DrawPolygonObject } from \"./2d/DrawPolygonObject.js\";\r\nimport { DrawRectObject } from \"./2d/DrawRectObject.js\";\r\nimport { DrawTextObject } from \"./2d/DrawTextObject.js\";\r\n/**\r\n * A storage for stage data, such as gameObjects,\r\n * collision shapes, worldDimensions and offset\r\n * @see {@link GameStage} a part of GameStage\r\n * @hideconstructor\r\n */\r\nexport class GameStageData {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #worldWidth;\r\n    #worldHeight;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #viewWidth;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #viewHeight;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #xOffset = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #yOffset = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #centerX = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #centerY = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #rotate = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #maxCollisionShapesSize = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #maxEllipseCollisionShapesSize = 0;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #maxPointBSize = 0;\r\n    /**\r\n     * Points to next empty cell\r\n     * @type {number}\r\n     */\r\n    #bPointer = 0;\r\n    /**\r\n     * Points to next empty cell\r\n     * @type {number}\r\n     */\r\n    #pPointer = 0;\r\n    /**\r\n     * Points to next empty cell\r\n     * @type {number}\r\n     */\r\n    #ePointer = 0;\r\n    /**\r\n     * current screen collision shapes, recalculated every render cycles\r\n     * stored as floatArray, \r\n     * each 4 cells, represent a line with coords x1,y1,x2,y2\r\n     * @type {Float32Array}\r\n     */\r\n    #collision_shapes;\r\n    /**\r\n     * ellipse collision shapes\r\n     * stored as floatArray, \r\n     * each 4 cells, represent am ellipse with cords centerX, centerY, radiusX, radiusY\r\n     * @type {Float32Array}\r\n     */\r\n    #ellipseCollisionShapes;\r\n    /**\r\n     * point collision shapes\r\n     * stored as floatArray, \r\n     * each 2 cells, represent a point with coords x1,y1\r\n     * @type {Float32Array}\r\n     */\r\n    #pointCollisionShapes;\r\n    /**\r\n     * whole world collision shapes, calculated once on prepare stage\r\n     * @type {Array<Array<number>>}\r\n     */\r\n    #wholeWorldCollisionShapes;\r\n    /**\r\n     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer>}\r\n     */\r\n    #renderObjects = [];\r\n    /**\r\n     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer>}\r\n     */\r\n    #pendingRenderObjects = [];\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isOffsetTurnedOff;\r\n    /**\r\n     * @deprecated\r\n     * @type {boolean}\r\n     */\r\n    #isWorldCollisionShapesEnabled = false;\r\n\r\n    /**\r\n     * @type {Array<number>}\r\n     */\r\n    #debugObjectCollisionShapes = [];\r\n    /**\r\n     * \r\n     * @type {boolean}\r\n     */\r\n    #isDebugObjectCollisionShapes = false;\r\n\r\n    constructor(gameOptions) {\r\n        //this.#collision_shapes = new Float32Array(this.#maxCollisionShapesSize);\r\n        //this.#ellipseCollisionShapes = new Float32Array(this.#maxCollisionShapesSize);\r\n        //this.#pointCollisionShapes = new Float32Array(this.#maxCollisionShapesSize);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {boolean}\r\n     */\r\n    isOffsetTurnedOff() {\r\n        return this.#isOffsetTurnedOff;\r\n    }\r\n    set mapRotate(value) {\r\n        this.#rotate = value;\r\n    }\r\n\r\n    /**\r\n     * Add a Collision Shape line\r\n     * @param {{x1:number,y1:number,x2:number, y2:number}} collision_shapes \r\n     */\r\n    #addCollisionShapes(collision_shapes) {\r\n        this._addCollisionShapeLine(collision_shapes.x1,collision_shapes.y1, collision_shapes.x2, collision_shapes.y2);\r\n    }\r\n\r\n    /**\r\n     * Add array of collision shapes lines\r\n     * @param {Array<Array<number>>} collision_shapes \r\n     * @ignore\r\n     */\r\n    _addImageDebugCollisionShapes(collision_shapes) {\r\n        const len = collision_shapes.length;\r\n        for (let i = 0; i < len; i++) {\r\n            this.#debugObjectCollisionShapes.push(...collision_shapes[i]);\r\n        }\r\n    }\r\n\r\n    _enableDebugObjectCollisionShapes() {\r\n        this.#isDebugObjectCollisionShapes = true;\r\n    }\r\n    /**\r\n     * Add array of collision shapes lines\r\n     * @param {Array<Array<number>>} collision_shapes \r\n     * @ignore\r\n     */\r\n    _addCollisionShapesArray(collision_shapes) {\r\n        const len = collision_shapes.length;\r\n        for (let i = 0; i < len; i++) {\r\n            const collision_shape = collision_shapes[i];\r\n            this._addCollisionShapeLine(collision_shape[0], collision_shape[1], collision_shape[2], collision_shape[3]);\r\n        }\r\n    }\r\n\r\n    _addCollisionShapeLine(x1, y1, x2, y2) {\r\n        this.#collision_shapes[this.#bPointer] = x1;\r\n        this.#bPointer++;\r\n        this.#collision_shapes[this.#bPointer] = y1;\r\n        this.#bPointer++;\r\n        this.#collision_shapes[this.#bPointer] = x2;\r\n        this.#bPointer++;\r\n        this.#collision_shapes[this.#bPointer] = y2;\r\n        this.#bPointer++;\r\n    }\r\n\r\n    _addEllipseCollisionShape(w, h, x, y) {\r\n        this.#ellipseCollisionShapes[this.#ePointer] = w;\r\n        this.#ePointer++;\r\n        this.#ellipseCollisionShapes[this.#ePointer] = h;\r\n        this.#ePointer++;\r\n        this.#ellipseCollisionShapes[this.#ePointer] = x;\r\n        this.#ePointer++;\r\n        this.#ellipseCollisionShapes[this.#ePointer] = y;\r\n        this.#ePointer++;\r\n    }\r\n\r\n    _addPointCollisionShape(x,y) {\r\n        this.#pointCollisionShapes[this.#pPointer] = x;\r\n        this.#pPointer++;\r\n        this.#pointCollisionShapes[this.#pPointer] = y;\r\n        this.#pPointer++;\r\n    }\r\n\r\n    _removeCollisionShapeLine(startPos) {\r\n        this.#collision_shapes[startPos] = 0;\r\n        this.#collision_shapes[startPos + 1] = 0;\r\n        this.#collision_shapes[startPos + 2] = 0;\r\n        this.#collision_shapes[startPos + 3] = 0;\r\n    }\r\n\r\n    /**\r\n     * Clear map collision shapes\r\n     * @ignore\r\n     */\r\n    _clearCollisionShapes() {\r\n        this.#collision_shapes.fill(0);\r\n        this.#ellipseCollisionShapes.fill(0);\r\n        this.#pointCollisionShapes.fill(0);\r\n        \r\n        this.#bPointer = 0;\r\n        this.#ePointer = 0;\r\n        this.#pPointer = 0;\r\n        if (this.#isDebugObjectCollisionShapes) {\r\n            this.#debugObjectCollisionShapes = [];\r\n        }\r\n    }\r\n\r\n    _initiateCollisionShapesData() {\r\n        this.#collision_shapes = new Float32Array(this.#maxCollisionShapesSize);\r\n        this.#ellipseCollisionShapes = new Float32Array(this.#maxEllipseCollisionShapesSize);\r\n        this.#pointCollisionShapes = new Float32Array(this.#maxPointBSize);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} bSize\r\n     * @param {number} eSize - ellipse collision shapes size\r\n     * @param {number} pSize - points collision shapes size\r\n     * @ignore\r\n     */\r\n    _setMaxCollisionShapesSize(bSize, eSize = 0, pSize = 0) {\r\n        this.#maxCollisionShapesSize = bSize;\r\n        this.#maxEllipseCollisionShapesSize = eSize;\r\n        this.#maxPointBSize = pSize;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @ignore\r\n     */\r\n    _setWorldDimensions(width, height) {\r\n        this.#worldWidth = width;\r\n        this.#worldHeight = height;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {number} width \r\n     * @param {number} height \r\n     * @ignore\r\n     */\r\n    _setCanvasDimensions(width, height) {\r\n        this.#viewWidth = width;\r\n        this.#viewHeight = height;\r\n    }\r\n\r\n    /**\r\n     * Set map borders\r\n     * @ignore\r\n     */\r\n    _setMapCollisionShapes() {\r\n        const [w, h] = [this.#worldWidth, this.#worldHeight],\r\n            [offsetX, offsetY] = [this.#xOffset, this.#yOffset],\r\n            wOffset = w - offsetX,\r\n            hOffset = h -offsetY;\r\n        if (!w || !h) {\r\n            Warning(WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map collision shapes.\");\r\n        }\r\n        this.#addCollisionShapes({x1: 0, y1: 0, x2: wOffset, y2: 0});\r\n        this.#addCollisionShapes({x1: wOffset, y1: 0, x2: wOffset, y2: hOffset});\r\n        this.#addCollisionShapes({x1: wOffset, y1: hOffset, x2: 0, y2: hOffset});\r\n        this.#addCollisionShapes({x1: 0, y1: hOffset, x2: 0, y2: 0});\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    _setWholeWorldMapCollisionShapes() {\r\n        const [w, h] = [this.#worldWidth, this.#worldHeight];\r\n        if (!w || !h) {\r\n            Warning(WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map collision shapes.\");\r\n        }\r\n        this.#wholeWorldCollisionShapes.push([0, 0, w, 0]);\r\n        this.#wholeWorldCollisionShapes.push([w, 0, w, h]);\r\n        this.#wholeWorldCollisionShapes.push([w, h, 0, h]);\r\n        this.#wholeWorldCollisionShapes.push([0, h, 0, 0]);\r\n    }\r\n\r\n    /**\r\n     * Merge same collision shapes\r\n     * !not used\r\n     * @ignore\r\n     * @deprecated\r\n     */\r\n    _mergeCollisionShapes(isWholeMapCollisionShapes = false) {\r\n        const collision_shapes = isWholeMapCollisionShapes ? this.getWholeWorldCollisionShapes() : this.getCollisionShapes(),\r\n            collisionShapesSet = new Set(collision_shapes);\r\n\r\n        for (const line of collisionShapesSet.values()) {\r\n            const lineX1 = line[0],\r\n                lineY1 = line[1],\r\n                lineX2 = line[2],\r\n                lineY2 = line[3];\r\n            for (const line2 of collisionShapesSet.values()) {\r\n                const line2X1 = line2[0],\r\n                    line2Y1 = line2[1],\r\n                    line2X2 = line2[2],\r\n                    line2Y2 = line2[3];\r\n                if (lineX1 === line2X2 && lineY1 === line2Y2 &&\r\n                    lineX2 === line2X1 && lineY2 === line2Y1) {\r\n                    //remove double lines\r\n                    collisionShapesSet.delete(line);\r\n                    collisionShapesSet.delete(line2);\r\n                }\r\n                if (lineX2 === line2X1 && lineY2 === line2Y1 && (lineX1 === line2X2 || lineY1 === line2Y2)) {\r\n                    //merge lines\r\n                    line2[0] = lineX1;\r\n                    line2[1] = lineY1;\r\n                    collisionShapesSet.delete(line);\r\n                }\r\n            }\r\n        }\r\n        if (isWholeMapCollisionShapes) {\r\n            this.#collision_shapes = Array.from(collisionShapesSet);\r\n        } else {\r\n            this.#wholeWorldCollisionShapes = Array.from(collisionShapesSet);\r\n        }\r\n        collisionShapesSet.clear();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {Array<Array<number>>} collision_shapes \r\n     */\r\n    _setWholeMapCollisionShapes(collision_shapes) {\r\n        this.#wholeWorldCollisionShapes.push(...collision_shapes);\r\n    }\r\n\r\n    /**\r\n     * @deprecated\r\n     * @ignore\r\n     */\r\n    _enableMapCollisionShapes() {\r\n        this.#isWorldCollisionShapesEnabled = true;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    _sortRenderObjectsBySortIndex() {\r\n        this.#renderObjects.sort((obj1, obj2) => obj1.sortIndex - obj2.sortIndex);\r\n    }\r\n\r\n    _processPendingRenderObjects() {\r\n        if (this.#pendingRenderObjects.length > 0) {\r\n            this.#renderObjects.push(...this.#pendingRenderObjects);\r\n            this._sortRenderObjectsBySortIndex();\r\n            this.#pendingRenderObjects = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    set _renderObject(object) {\r\n        this.#pendingRenderObjects.push(object);\r\n    } \r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    set _renderObjects(objects) {\r\n        objects.forEach(object => {\r\n            this._renderObject = object;\r\n        });\r\n    } \r\n\r\n    /**\r\n     * Backward capability with jsge before 1.5.9\r\n     * @deprecated\r\n     * getCollisionShapes()\r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getBoundaries() {\r\n        return this.getCollisionShapes();\r\n    }\r\n    /**\r\n     * current screen collision shapes, \r\n     * this method is for backward capability with jsge@1.4.4\r\n     * recommended to use getRawCollisionShapes()\r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getCollisionShapes() {\r\n        const collision_shapes = this.#collision_shapes, \r\n            len = this.#bPointer;\r\n\r\n        let bTempArray = [],\r\n            bArray = [];\r\n        \r\n        for (let i = 0; i < len; i++) {\r\n            const element = collision_shapes[i];\r\n            bTempArray.push(element);\r\n            if (((i + 1) % 4) === 0) {\r\n                bArray.push(bTempArray);\r\n                bTempArray = [];\r\n            }\r\n        }\r\n        return bArray;\r\n    }\r\n\r\n    /**\r\n     * current screen collision shapes\r\n     * polygon collision shapes from Tiled and Tiled collision shapes layers are merged here\r\n     * each 4 cells, represent a line with coords x1,y1,x2,y2\r\n     * @returns {Float32Array}\r\n     */\r\n    getRawCollisionShapes() {\r\n        return this.#collision_shapes;\r\n    }\r\n    /**\r\n     * Backward capability with jsge before 1.5.9\r\n     * @deprecated\r\n     * getRawCollisionShapes()\r\n     * @returns {Float32Array}\r\n     */\r\n    getRawBoundaries() {\r\n        return this.getRawCollisionShapes();\r\n    }\r\n\r\n    /**\r\n     * ellipse collision shapes from Tiled,\r\n     * stored as floatArray, \r\n     * each 4 cells, represent am ellipse with cords centerX, centerY, radiusX, radiusY\r\n     * @returns {Float32Array}\r\n     */\r\n    getEllipseCollisionShapes() {\r\n        return this.#ellipseCollisionShapes;\r\n    }\r\n    /**\r\n     * Backward capability with jsge before 1.5.9\r\n     * @deprecated\r\n     * getEllipseCollisionShapes()\r\n     * @returns {Float32Array}\r\n     */\r\n    getEllipseBoundaries() {\r\n        return this.getEllipseCollisionShapes();\r\n    }\r\n\r\n    /**\r\n     * point collision shapes from Tiled,\r\n     * stored as floatArray, \r\n     * each 2 cells, represent a point with coords x1,y1\r\n     * @returns {Float32Array}\r\n     */\r\n    getPointCollisionShapes() {\r\n        return this.#pointCollisionShapes;\r\n    }\r\n    /**\r\n     * Backward capability with jsge before 1.5.9\r\n     * @deprecated\r\n     * getPointCollisionShapes()\r\n     * @returns {Float32Array}\r\n     */\r\n    getPointBoundaries() {\r\n        return this.getPointCollisionShapes();\r\n    }\r\n    \r\n    getWholeWorldCollisionShapes() {\r\n        return this.#wholeWorldCollisionShapes;\r\n    }\r\n\r\n    /**\r\n     * @deprecated\r\n     * getWholeWorldCollisionShapes()\r\n     */\r\n    getWholeWorldBoundaries() {\r\n        return this.getWholeWorldCollisionShapes();\r\n    }\r\n\r\n    getDebugObjectCollisionShapes() {\r\n        return this.#debugObjectCollisionShapes;\r\n    }\r\n\r\n    /**\r\n     * @deprecated\r\n     * getDebugObjectCollisionShapes()\r\n     */\r\n    getDebugObjectBoundaries() {\r\n        return this.getDebugObjectCollisionShapes();\r\n    }\r\n\r\n    /**\r\n     * @deprecated\r\n     */\r\n    get isWorldBoundariesEnabled() {\r\n        return this.#isWorldCollisionShapesEnabled;\r\n    }\r\n    /**\r\n     * Current canvas dimensions\r\n     * @returns {Array<number>}\r\n     */\r\n    get canvasDimensions() {\r\n        return [this.#viewWidth, this.#viewHeight];\r\n    }\r\n\r\n    /**\r\n     * Current game world dimensions\r\n     * @returns {Array<number>}\r\n     */\r\n    get worldDimensions() {\r\n        return [this.#worldWidth, this.#worldHeight];\r\n    }\r\n    \r\n    /**\r\n     * Current word x/y offset\r\n     * @returns {Array<number>}\r\n     */\r\n    get worldOffset() {\r\n        return [this.#xOffset, this.#yOffset];\r\n    }\r\n\r\n    /**\r\n     * Current focus point\r\n     * @returns {Array<number>}\r\n     */\r\n    get mapCenter() {\r\n        return [this.#centerX, this.#centerY];\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    get mapRotate() {\r\n        return this.#rotate;\r\n    }\r\n\r\n    /**\r\n     * Tiled polygon and Tiled layer collision shapes length\r\n     * @deprecated\r\n     * Use collisionShapesLen()\r\n     * @returns {number}\r\n     */\r\n    get boundariesLen() {\r\n        return this.#bPointer;\r\n    }\r\n\r\n    /**\r\n     * Tiled polygon and Tiled layer collision shapes length\r\n     * @returns {number}\r\n     */\r\n    get collisionShapesLen() {\r\n        return this.#bPointer;\r\n    }\r\n\r\n    /**\r\n     * Tiled ellipse collision shapes length\r\n     * @returns {number}\r\n     */\r\n    get ellipseBLen() {\r\n        return this.#ePointer;\r\n    }\r\n\r\n    /**\r\n     * Tiled point collision shapes length\r\n     * @returns {number}\r\n     */\r\n    get pointBLen() {\r\n        return this.#pPointer;\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {number} x \r\n     * @param {number} y \r\n     */\r\n    centerCameraPosition = (x, y) => {\r\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\r\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\r\n            [mapWidth, mapHeight] = this.worldDimensions,\r\n            halfScreenWidth = canvasWidth/2,\r\n            halfScreenHeight = canvasHeight/2,\r\n            currentCenterX = halfScreenWidth - mapOffsetX,\r\n            currentCenterY = halfScreenHeight - mapOffsetY;\r\n        if (currentCenterX < x) {\r\n            if (x < mapWidth - halfScreenWidth) {\r\n                const newXOffset = x - halfScreenWidth;\r\n                if (newXOffset >= 0)\r\n                    this.#xOffset = Math.round(newXOffset);\r\n            } else if (mapWidth > canvasWidth) {\r\n                const newXOffset = mapWidth - canvasWidth;\r\n                this.#xOffset = Math.round(newXOffset);\r\n            }\r\n        }\r\n        if (currentCenterY < y) {\r\n            if (y < mapHeight - halfScreenHeight) {\r\n                const newYOffset = y - halfScreenHeight;\r\n                if (newYOffset >= 0)\r\n                    this.#yOffset = Math.round(newYOffset);\r\n            } else if (mapHeight > canvasHeight) {\r\n                const newYOffset = mapHeight - canvasHeight;\r\n                this.#yOffset = Math.round(newYOffset);\r\n            }\r\n        }\r\n\r\n        this.#centerX = x;\r\n        this.#centerY = y;\r\n        //Logger.debug(\"center camera position, offset: \", this.worldOffset);\r\n        //Logger.debug(\"center: \", this.mapCenter);   \r\n    };\r\n\r\n    personRotatedCenterCamera = (x, y, rotationAngle) => {\r\n        console.log(\"new centering algorithm\");\r\n        /*\r\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\r\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\r\n            [mapWidth, mapHeight] = this.worldDimensions,\r\n            halfScreenWidth = canvasWidth/2,\r\n            halfScreenHeight = canvasHeight/2,\r\n            currentCenterX = halfScreenWidth - mapOffsetX,\r\n            currentCenterY = halfScreenHeight - mapOffsetY;\r\n        if (currentCenterX < x) {\r\n            if (x < mapWidth - halfScreenWidth) {\r\n                const newXOffset = x - halfScreenWidth;\r\n                if (newXOffset >= 0)\r\n                    this.#xOffset = Math.round(newXOffset);\r\n            } else if (mapWidth > canvasWidth) {\r\n                const newXOffset = mapWidth - canvasWidth;\r\n                this.#xOffset = Math.round(newXOffset);\r\n            }\r\n        }\r\n        if (currentCenterY < y) {\r\n            if (y < mapHeight - halfScreenHeight) {\r\n                const newYOffset = y - halfScreenHeight;\r\n                if (newYOffset >= 0)\r\n                    this.#yOffset = Math.round(newYOffset);\r\n            } else if (mapHeight > canvasHeight) {\r\n                const newYOffset = mapHeight - canvasHeight;\r\n                this.#yOffset = Math.round(newYOffset);\r\n            }\r\n        }\r\n\r\n        this.#centerX = x;\r\n        this.#centerY = y;\r\n        Logger.debug(\"center camera position, offset: \", this.worldOffset);\r\n        Logger.debug(\"center: \", this.mapCenter);   \r\n        */\r\n    };\r\n\r\n    /**\r\n     * a getter to retrieve all attached renderObjects\r\n     */\r\n    get renderObjects() {\r\n        return this.#renderObjects;\r\n    }\r\n\r\n    /**\r\n     * Retrieve specific objects instances\r\n     * @param {Object} instance - drawObjectInstance to retrieve \r\n     * @returns {Array<Object>}\r\n     */\r\n    getObjectsByInstance(instance) {\r\n        return this.#renderObjects.filter((object) => object instanceof instance);\r\n    }\r\n\r\n    /**\r\n     * Used to remove all render objects,\r\n     * Designed for restart the stage\r\n     */\r\n    cleanUp() {\r\n        this.#renderObjects = [];\r\n        this.#pendingRenderObjects = [];\r\n        this._clearCollisionShapes();\r\n    }\r\n}","import { ISystem } from \"./ISystem.js\";\n\n/**\n * Class for creating modules\n * Accessed via ISystem.extensionInterface\n */\nexport class IExtension {\n    /**\n     * @type {ISystem}\n     */\n    #systemReference;\n    /**\n     * @hideconstructor\n     */\n    constructor(iSystem) {\n        this.#systemReference = iSystem;\n    }\n    /**\n     * Is used for registering new Object in DrawObjectFactory, \\\n     * registered method could be then called with this.draw[createInstanceKey]\n     * @param {string} createInstanceKey - a key for calling method from DrawObjectFactory\n     * @param {function} createInstanceMethod - method \n     */\n    registerDrawObject(createInstanceKey, createInstanceMethod) {\n        this.#systemReference.drawObjectFactory._registerNewObjectMethod(createInstanceKey, createInstanceMethod);\n    }\n\n    /**\n     * Used to register a new draw program\n     * @param {string} programName\n     * @param {string} vertexShader - raw vertex shader program\n     * @param {string} fragmentShader - raw fragment shader program \n     * @param {Array<string>} uVars - program uniform variables names\n     * @param {Array<string>} aVars - program attribute variables names\n     * @returns {Promise<void>}\n     */\n    registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {\n        return this.#systemReference.iRender._registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars);\n    }\n\n    /**\n     * Inject method to render.init stage. Should be Promise based.\n     * @param {function():Promise<void>} method \n     * @returns {void}\n     */\n    registerRenderInit(method) {\n        this.#systemReference.iRender._registerRenderInit(method);\n    }\n\n    /**\n     * Register render method for class.\n     * @param {string} objectClassName - object name registered to DrawObjectFactory\n     * @param {function(renderObject, gl, pageData, program, vars):Promise<any[]>} objectRenderMethod - should be promise based returns vertices number and draw program\n     * @param {string} objectWebGlDrawProgram - a webgl program name previously registered with iExtension.registerAndCompileWebGlProgram()\n     */\n    registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram) {\n        this.#systemReference.iRender._registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram);\n    }\n}","import { CONST, ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { Logger } from \"./Logger.js\";\nimport { SystemEvent } from \"./Events/SystemEvent.js\";\n//import { Socket } from \"socket.io-client\";\n\n/**\n * Represents Socket connection\n * \n * From 1.4.4 disabled by default,\n * to enable, set settings.network.enabled to true\n */\nexport class INetwork extends EventTarget {\n    /**\n     * @type {Object}\n     */\n    #systemSettings;\n    /**\n     * @type {Socket}\n     */\n    #socket;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(systemSettings) {\n        super();\n        if (!systemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\n        }\n        this.#systemSettings = systemSettings;\n    }\n\n    init() {\n        import(\"socket.io-client\").then((module) => {\n            this.#socket = module.io(this.#systemSettings.network.address, {withCredentials: true});\n            \n            this.#registerSocketListeners();\n        });\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get isServerConnected () {\n        if (this.#socket && this.#socket.connected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    get playerId() {\n        return this.#socket.id;\n    }\n\n    sendGatherRoomsInfo() {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.ROOMS_INFO_REQUEST);\n    }\n\n    sendCreateOrJoinRoom(roomName, map) {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CREATE_OR_JOIN, roomName , map);\n    }\n\n    sendMessage(message) {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CLIENT_MESSAGE, message);\n    }\n\n    #onConnect = () => {\n        Logger.debug(\"connected, socket id: \" + this.#socket.id);\n        this.dispatchEvent(new Event(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onDisconnect = (reason) => {\n        Logger.debug(\"server disconnected, reason: \" + reason);\n        this.dispatchEvent(new Event(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onData = (event) => {\n        console.warn(\"server data: \", event);\n    };\n\n    #onMessage = (message) => {\n        Logger.debug(\"received new message from server: \" + message);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.SERVER_MESSAGE, message));\n    };\n\n    #onRoomsInfo = (rooms) => {\n        Logger.debug(\"received roomsInfo \" + rooms);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.ROOMS_INFO, rooms));\n    };\n\n    #onCreateNewRoom = (room, map) => {\n        Logger.debug(\"CLIENT SOCKET: Created room  \" + room);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CREATED, {room, map}));\n    };\n\n    #onRoomIsFull = (room) => {\n        Logger.debug(\"CLIENT SOCKET: Room is full, can't join: \" + room);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.FULL, {room}));\n    };\n\n    #onJoinedToRoom = (room, map) => {\n        Logger.debug(\"CLIENT SOCKET: Joined to room: \" + room, \", map: \", map);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.JOINED, {room, map}));\n    };\n\n    #onUnjoinedFromRoom = (playerId) => {\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.DISCONNECTED, {playerId}));\n    };\n\n    #registerSocketListeners() {\n        this.#socket.on(\"connect\", this.#onConnect);\n        this.#socket.on(\"disconnect\", this.#onDisconnect);\n        this.#socket.on(\"data\", this.#onData);\n\n        this.#socket.on(\"roomsInfo\", this.#onRoomsInfo);\n    \n        this.#socket.on(\"created\", this.#onCreateNewRoom);\n    \n        this.#socket.on(\"full\", this.#onRoomIsFull);\n    \n        this.#socket.on(\"joined\", this.#onJoinedToRoom);\n    \n        this.#socket.on(\"log\", function(array) {\n            console.log.apply(console, array);\n        });\n    \n        this.#socket.on(\"message\", this.#onMessage);\n    \n        this.#socket.on(\"removed\", function(message) {\n            console.log(\"removed message\");\n            console.log(message);\n        });\n\n        this.#socket.on(\"disconnected\", this.#onUnjoinedFromRoom);\n\n        addEventListener(\"beforeunload\", this.#disconnect);\n    }\n\n    #disconnect = () => {\n        this.#socket.disconnect();\n    };\n}","import { Exception, Warning } from \"./Exception.js\";\r\nimport { ERROR_CODES, WARNING_CODES } from \"../constants.js\";\r\nimport { WebGlEngine } from \"./WebGl/WebGlEngine.js\";\r\nimport { SystemSettings } from \"../configs.js\";\r\nimport { GameStageData } from \"./GameStageData.js\";\r\nimport AssetsManager from \"../../modules/assetsm/src/AssetsManager.js\";\r\n//import { calculateBufferData } from \"../wa/release.js\";\r\nimport { CONST } from \"../constants.js\";\r\nimport { imgVertexShader, imgFragmentShader, imgUniforms, imgAttributes } from \"./WebGl/ImagesDrawProgram.js\";\r\nimport { primitivesVertexShader, primitivesFragmentShader, primitivesUniforms, primitivesAttributes } from \"./WebGl/PrimitivesDrawProgram.js\";\r\nimport { imgMVertexShader, imgMFragmentShader, imgMUniforms, imgMAttributes } from \"./WebGl/ImagesDrawProgramM.js\";\r\nimport { RenderLoop } from \"./RenderLoop.js\";\r\n\r\n/**\r\n * IRender class controls the render(start/stop/speed) \r\n * And drawObjects(animations, removing, and rendering)\r\n * @see {@link GameStage} a part of GameStage\r\n * @hideconstructor\r\n */\r\nexport class IRender {\r\n    /**\r\n     * @type {HTMLCanvasElement}\r\n     */\r\n    #canvas;\r\n    /**\r\n     * @type {WebGLRenderingContext | null}\r\n     */\r\n    #drawContext;\r\n    /**\r\n     * @type {WebGlEngine}\r\n     */\r\n    #webGlEngine;\r\n    /**\r\n     * @type {GameStageData | null}\r\n     */\r\n    #currentGameStageData;\r\n\r\n    /**\r\n     * ISystem.systemSettings\r\n     * @type {SystemSettings}\r\n     */\r\n    #systemSettingsReference;\r\n    /**\r\n     * A reference to the systemInterface.iLoader\r\n     * @type {AssetsManager}\r\n     */\r\n    #loaderReference;\r\n    \r\n\r\n    #renderLoopInstance;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isCollisionShapesPrecalculations = false;\r\n\r\n    /**\r\n     * @type {Array<function():Promise<void>>}\r\n     */\r\n    #initPromises = [];\r\n    /**\r\n     * @type {EventTarget}\r\n     */\r\n    #emitter = new EventTarget();\r\n    constructor(systemSettings, iLoader, canvasContainer) {\r\n        const preserveDrawingBuffer = systemSettings.gameOptions.debug.preserveDrawingBuffer;\r\n        let contextOpt = { stencil: true };\r\n        if (preserveDrawingBuffer === true) {\r\n            contextOpt.preserveDrawingBuffer = true;\r\n        }\r\n        this.#canvas = document.createElement(\"canvas\");\r\n        canvasContainer.appendChild(this.#canvas);\r\n        \r\n        this.#drawContext = this.#canvas.getContext(\"webgl\", contextOpt);\r\n\r\n        this.#systemSettingsReference = systemSettings;\r\n        this.#loaderReference = iLoader;\r\n\r\n        this.#isCollisionShapesPrecalculations = this.systemSettings.gameOptions.render.collisionShapes.wholeWorldPrecalculations;\r\n\r\n        this.#webGlEngine = new WebGlEngine(this.#drawContext, this.#systemSettingsReference.gameOptions, this.iLoader);\r\n        \r\n        this._registerRenderInit(this.#webGlEngine._initiateJsRender);\r\n        if (this.systemSettings.gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT ||\r\n            this.systemSettings.gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT) {\r\n            this._registerRenderInit(this.#webGlEngine._initiateWasm);\r\n        }\r\n\r\n        this._registerRenderInit(this.fixCanvasSize);\r\n        this._registerRenderInit(\r\n            () => this._registerAndCompileWebGlProgram(CONST.WEBGL.DRAW_PROGRAMS.IMAGES, imgVertexShader, imgFragmentShader, imgUniforms, imgAttributes)\r\n        );\r\n        this._registerRenderInit(\r\n            () => this._registerAndCompileWebGlProgram(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES, primitivesVertexShader, primitivesFragmentShader, primitivesUniforms, primitivesAttributes)\r\n        );\r\n        this._registerRenderInit(\r\n            () => this._registerAndCompileWebGlProgram(CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M, imgMVertexShader, imgMFragmentShader, imgMUniforms, imgMAttributes)\r\n        );\r\n        this._registerRenderInit(this.#webGlEngine._initWebGlAttributes);\r\n    }\r\n\r\n    _webGlEngine() {\r\n        return this.#webGlEngine;\r\n    }\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    addEventListener = (eventName, listener, options) => {\r\n        this.#emitter.addEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    removeEventListener = (eventName, listener, options) => {\r\n        this.#emitter.removeEventListener(eventName, listener, options);\r\n    };\r\n\r\n    get stageData() {\r\n        return this.#currentGameStageData;\r\n    }\r\n\r\n    get systemSettings() {\r\n        return this.#systemSettingsReference;\r\n    }\r\n\r\n    get iLoader() {\r\n        return this.#loaderReference;\r\n    }\r\n\r\n    get canvas() {\r\n        return this.#canvas;\r\n    }\r\n\r\n    get drawContext() {\r\n        return this.#drawContext;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName\r\n     * @param  {...any} eventParams\r\n     */\r\n    emit = (eventName, ...eventParams) => {\r\n        const event = new Event(eventName);\r\n        event.data = [...eventParams];\r\n        this.#emitter.dispatchEvent(event);\r\n    };\r\n\r\n    /**\r\n     * Determines if all added files was loaded or not\r\n     * @returns {boolean}\r\n     */\r\n    isAllFilesLoaded = () => {\r\n        return this.iLoader.filesWaitingForUpload === 0;\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @returns {boolean}\r\n     */\r\n    _isRenderActive() {\r\n        return this.#renderLoopInstance ? this.#renderLoopInstance._isActive : false;\r\n    }\r\n\r\n    initiateContext = (stageData) => {\r\n        return Promise.all(this.#initPromises.map(method => method(stageData)));\r\n    };\r\n\r\n\r\n    /****************************\r\n     *  Extend functionality\r\n     ****************************/\r\n    /**\r\n     * @ignore\r\n     * @param {string} programName\r\n     * @param {string} vertexShader - raw vertex shader program\r\n     * @param {string} fragmentShader - raw fragment shader program \r\n     * @param {Array<string>} uVars - program uniform variables names\r\n     * @param {Array<string>} aVars - program attribute variables names\r\n     * @returns {Promise<void>}\r\n     */\r\n    _registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {\r\n        this.#webGlEngine._registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars);\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {function(GameStageData):Promise<void>} method \r\n     * @returns {void}\r\n     */\r\n    _registerRenderInit(method) {\r\n        this.#initPromises.push(method);\r\n        //} else {\r\n        //    Exception(ERROR_CODES.UNEXPECTED_METHOD_TYPE, \"registerRenderInit() accept only Promise based methods!\");\r\n        //}\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {string} objectClassName - object name registered to DrawObjectFactory\r\n     * @param {function(renderObject, gl, pageData, program, vars):Promise<any[]>} objectRenderMethod - should be promise based returns vertices number and draw program\r\n     * @param {string=} objectWebGlDrawProgram \r\n     */\r\n    _registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram) {\r\n        this.#webGlEngine._registerObjectRender(objectClassName, objectRenderMethod, objectWebGlDrawProgram);\r\n    }\r\n\r\n    /****************************\r\n     *  End of Extend functionality\r\n     ****************************/\r\n\r\n    setCanvasSize(width, height) {\r\n        this.#canvas.width = width;\r\n        this.#canvas.height = height;\r\n        if (this.#webGlEngine) {\r\n            this.#webGlEngine._fixCanvasSize(width, height);\r\n        }\r\n    }\r\n\r\n    fixCanvasSize = () => {\r\n        const settings = this.systemSettings, \r\n            canvasWidth = settings.canvasMaxSize.width && (settings.canvasMaxSize.width < window.innerWidth) ? settings.canvasMaxSize.width : window.innerWidth,\r\n            canvasHeight = settings.canvasMaxSize.height && (settings.canvasMaxSize.height < window.innerHeight) ? settings.canvasMaxSize.height : window.innerHeight;\r\n        this.setCanvasSize(canvasWidth, canvasHeight);\r\n        return Promise.resolve();\r\n    };\r\n\r\n    _createCollisionShapesPrecalculations() {\r\n        //const promises = [];\r\n        //for (const layer of this.#renderLayers) {\r\n        //    promises.push(this.#layerCollisionShapesPrecalculation(layer).catch((err) => {\r\n        //        Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);\r\n        //    }));\r\n        //}\r\n        //return promises;\r\n    }\r\n\r\n    //#clearTileMapPromises() {\r\n    //    this.#bindTileMapPromises = [];\r\n    //}\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {GameStageData} stageData \r\n     */\r\n    _startRender = async (/*time*/stageData) => {\r\n        this.fixCanvasSize();\r\n        this.#currentGameStageData = stageData;\r\n        switch (this.systemSettings.gameOptions.library) {\r\n        case CONST.LIBRARY.WEBGL:\r\n            await this.#prepareViews();\r\n            this.#renderLoopInstance = new RenderLoop(this.systemSettings, stageData, this._webGlEngine());\r\n            // delegate render loop events\r\n            this.#renderLoopInstance.addEventListener(CONST.EVENTS.SYSTEM.RENDER.START, () => this.emit(CONST.EVENTS.SYSTEM.RENDER.START));\r\n            this.#renderLoopInstance.addEventListener(CONST.EVENTS.SYSTEM.RENDER.END, () => this.emit(CONST.EVENTS.SYSTEM.RENDER.END));\r\n\r\n            this.#renderLoopInstance._start();\r\n            break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    _stopRender = () => {\r\n        this.#renderLoopInstance.removeEventListener(CONST.EVENTS.SYSTEM.RENDER.START, this.emit(CONST.EVENTS.SYSTEM.RENDER.START));\r\n        this.#renderLoopInstance.removeEventListener(CONST.EVENTS.SYSTEM.RENDER.END, this.emit(CONST.EVENTS.SYSTEM.RENDER.END));\r\n\r\n        this.#renderLoopInstance._stop();\r\n        this.#renderLoopInstance = undefined;\r\n\r\n    };\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    #prepareViews() {\r\n        return new Promise((resolve, reject) => {\r\n            let viewPromises = [];\r\n            const isCollisionShapesPrecalculations = this.#isCollisionShapesPrecalculations;\r\n            viewPromises.push(this.initiateContext(this.#currentGameStageData));\r\n            if (isCollisionShapesPrecalculations) {\r\n                console.warn(\"isCollisionShapesPrecalculations() is turned off\");\r\n                //for (const view of this.#views.values()) {\r\n                //viewPromises.push(this.#iRender._createCollisionShapesPrecalculations());\r\n                //}\r\n            }\r\n            Promise.allSettled(viewPromises).then((drawingResults) => {\r\n                drawingResults.forEach((result) => {\r\n                    if (result.status === \"rejected\") {\r\n                        const error = result.reason;\r\n                        Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, error);\r\n                        reject(error);\r\n                    }\r\n                });\r\n                resolve();\r\n            });\r\n        });\r\n    }\r\n}","import { CONST, ERROR_CODES, WARNING_CODES } from \"../constants.js\";\r\nimport { Exception, Warning } from \"./Exception.js\";\r\nimport { INetwork } from \"./INetwork.js\";\r\nimport { ISystemAudio } from \"./ISystemAudio.js\";\r\nimport { SystemSettings } from \"../configs.js\";\r\nimport AssetsManager from \"../../modules/assetsm/src/AssetsManager.js\";\r\nimport { DrawObjectFactory } from \"./DrawObjectFactory.js\";\r\nimport { GameStage } from \"./GameStage.js\";\r\nimport { IRender } from \"./IRender.js\";\r\nimport { IExtension } from \"./IExtension.js\";\r\n\r\n/**\r\n * Public interface for a System<br>\r\n * Can be used to start/stop GameStage render, <br>\r\n * And provides access to SystemSettings, INetwork and ISystemAudio <br>\r\n * IRender, DrawObjectFactory, AssetsManager and external modules\r\n * accessible via GameStage.iSystem and System.system\r\n * @see {@link System} a part of System class instance\r\n * @see {@link GameStage} a part of GameStage class instance\r\n */\r\nexport class ISystem {\r\n    /**\r\n     * @type {Object}\r\n     */\r\n    #systemSettings;\r\n    /**\r\n     * @type {IExtension}\r\n     */\r\n    #iExtension;\r\n    /**\r\n     * @type {INetwork | null}\r\n     */\r\n    #systemServerConnection;\r\n    /**\r\n     * @type {ISystemAudio}\r\n     */\r\n    #systemAudioInterface;\r\n    /**\r\n     * @type {AssetsManager}\r\n     */\r\n    #iLoader = new AssetsManager();\r\n    /**\r\n     * @type {IRender}\r\n     */\r\n    #iRender;\r\n    /**\r\n     * @type {DrawObjectFactory}\r\n     */\r\n    #drawObjectFactory = new DrawObjectFactory(this.#iLoader);\r\n    \r\n    #modules = new Map();\r\n    /**\r\n     * @type {Map<string, Object>}\r\n     */\r\n    #registeredStagesReference;\r\n    /**\r\n     * @type {EventTarget}\r\n     */\r\n    #emitter = new EventTarget();\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(systemSettings, registeredStages, canvasContainer) {\r\n        if (!systemSettings) {\r\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\r\n        }\r\n        this.#systemSettings = systemSettings;\r\n        \r\n        this.#systemAudioInterface = new ISystemAudio(this.iLoader);\r\n        this.#systemServerConnection = systemSettings.network.enabled ? new INetwork(systemSettings) : null;\r\n        this.#iRender = new IRender(this.systemSettings, this.iLoader, canvasContainer);\r\n        this.#iExtension = new IExtension(this);\r\n        this.#registeredStagesReference = registeredStages;\r\n        // broadcast render events\r\n        this.#iRender.addEventListener(CONST.EVENTS.SYSTEM.RENDER.START, () => this.emit(CONST.EVENTS.SYSTEM.RENDER.START));\r\n        this.#iRender.addEventListener(CONST.EVENTS.SYSTEM.RENDER.END, () => this.emit(CONST.EVENTS.SYSTEM.RENDER.END));\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName\r\n     * @param  {...any} eventParams\r\n     */\r\n    emit = (eventName, ...eventParams) => {\r\n        const event = new Event(eventName);\r\n        event.data = [...eventParams];\r\n        this.#emitter.dispatchEvent(event);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    addEventListener = (eventName, listener, options) => {\r\n        this.#emitter.addEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    removeEventListener = (eventName, listener, options) => {\r\n        this.#emitter.removeEventListener(eventName, listener, options);\r\n    };\r\n    \r\n    /**\r\n     * @returns { INetwork | null }\r\n     */\r\n    get iNetwork () {\r\n        return this.#systemServerConnection;\r\n    }\r\n\r\n    /**\r\n     * @returns { SystemSettings }\r\n     */\r\n    get systemSettings() {\r\n        return this.#systemSettings;\r\n    }\r\n\r\n    /**\r\n     * @returns { ISystemAudio }\r\n     */\r\n    get audio() {\r\n        return this.#systemAudioInterface;\r\n    }\r\n\r\n    /**\r\n     * @returns {AssetsManager}\r\n     */\r\n    get iLoader() {\r\n        return this.#iLoader;\r\n    }\r\n\r\n    /**\r\n     * @returns {IRender}\r\n     */\r\n    get iRender() {\r\n        return this.#iRender;\r\n    }\r\n\r\n    /**\r\n     * @returns {DrawObjectFactory}\r\n     */\r\n    get drawObjectFactory() {\r\n        return this.#drawObjectFactory;\r\n    }\r\n\r\n    /**\r\n     * @returns {IExtension}\r\n     */\r\n    get iExtension() {\r\n        return this.#iExtension;\r\n    }\r\n    /**\r\n     * @returns {Map<string, Object>}\r\n     */\r\n    get modules() {\r\n        return this.#modules;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} moduleKey \r\n     * @param {Object} moduleClass \r\n     * @param  {...any} args \r\n     * @returns {Object}\r\n     */\r\n    installModule = (moduleKey, moduleClass, ...args) => {\r\n        const moduleInstance = new moduleClass(this, ...args);\r\n        if (this.#modules.has(moduleKey)) {\r\n            Warning(WARNING_CODES.MODULE_ALREADY_INSTALLED, \"module \" + moduleKey + \" is already installed\");\r\n            return this.#modules.get(moduleKey);\r\n        } else {\r\n            this.#modules.set(moduleKey, moduleInstance);\r\n        }\r\n        return moduleInstance;\r\n    };\r\n\r\n    /**\r\n     * @method\r\n     * @param {string} gameStageName\r\n     * @param {Object} [options] - options\r\n     */\r\n    startGameStage = (gameStageName, options) => {\r\n        if (this.#registeredStagesReference.has(gameStageName)) {\r\n            if (this.#iRender._isRenderActive() === true) {\r\n                this.#iRender._stopRender();\r\n                Exception(ERROR_CODES.ANOTHER_STAGE_ACTIVE, \" Can't start the stage \" + gameStageName + \" while, another stage is active\");\r\n            } else {\r\n                const stage = this.#registeredStagesReference.get(gameStageName),\r\n                    pageData = stage.stageData;\r\n                this.#drawObjectFactory._attachPageData(pageData);\r\n                if (stage.isInitiated === false) {\r\n                    stage._init();\r\n                }\r\n                //stage._attachCanvasToContainer(this.#canvasContainer);\r\n                stage._start(options);\r\n                pageData._processPendingRenderObjects();\r\n                this.emit(CONST.EVENTS.SYSTEM.START_PAGE);\r\n                this.#iRender._startRender(pageData);\r\n            }\r\n            \r\n        } else {\r\n            Exception(ERROR_CODES.VIEW_NOT_EXIST, \"Stage \" + gameStageName + \" is not registered!\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @method\r\n     * @param {string} gameStageName\r\n     */\r\n    stopGameStage = (gameStageName) => {\r\n        if (this.#registeredStagesReference.has(gameStageName)) {\r\n            this.emit(CONST.EVENTS.SYSTEM.STOP_PAGE);\r\n            this.drawObjectFactory._detachPageData();\r\n            this.#iRender._stopRender();\r\n            this.#registeredStagesReference.get(gameStageName)._stop();\r\n        } else {\r\n            Exception(ERROR_CODES.STAGE_NOT_EXIST, \"GameStage \" + gameStageName + \" is not registered!\");\r\n        }\r\n    };\r\n}","import AssetsManager from  \"../../modules/assetsm/src/AssetsManager.js\";\nimport { WARNING_CODES } from \"../constants.js\";\nimport { Warning } from \"./Exception.js\";\n\n/**\n * An audio interface, <br>\n * controls all application audio,<br>\n * holds and retrieves audio, changes volume<br> \n * accessible via GameStage.audio\n * @see {@link GameStage} a part of GameStage\n * @hideconstructor\n */\nexport class ISystemAudio {\n    #volume = 0.5;\n    #audio = new Map();\n    /**\n     * @type {AssetsManager}\n     */\n    #loaderReference;\n\n    constructor(iLoader) {\n        this.#loaderReference = iLoader;\n    }\n\n    /**\n     * Original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudio = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            Warning(WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            return audio;\n        } else {\n            Warning(WARNING_CODES.AUDIO_NOT_REGISTERED, \"\");\n            return null;\n        }\n    };\n\n    /**\n     * Clone of original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudioCloned = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            Warning(WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            const audioCloned = audio.cloneNode();\n            audioCloned.volume = this.#volume;\n            return audioCloned;\n        } else {\n            Warning(WARNING_CODES.AUDIO_NOT_REGISTERED);\n            return null;\n        }\n    };\n\n    set volume(value) {\n        this.#volume = value;\n        this.#updateTracksVolumes(value);\n    }\n    /**\n     * Used to set or get audio volume, \n     * value should be from 0 to 1\n     * @returns {number}\n     */\n    get volume() {\n        return this.#volume;\n    }\n\n    #updateTracksVolumes(value) {\n        for (const track of this.#audio.values()) {\n            if (track) {\n                track.volume = value;\n            }\n        }\n    }\n\n    /**\n     * Register audio in the iSystem\n     * @param {string} name\n     */\n    registerAudio(name) {\n        let mediaElement = this.#loaderReference.getAudio(name);\n        this.#audio.set(name, mediaElement);\n    }\n}","import { SystemSettings } from \"../configs.js\";\nimport { CONST } from \"../constants.js\";\n\nexport class Logger {\n    static debug(...args) {\n        if (SystemSettings.mode === CONST.MODE.DEBUG)\n            args.forEach(message => console.log(message));\n    }\n}","import { SystemSettings } from \"../configs.js\";\r\nimport { GameStageData } from \"./GameStageData.js\";\r\nimport { CONST } from \"../constants.js\";\r\nimport { Warning } from \"./Exception.js\";\r\nimport { WARNING_CODES } from \"../constants.js\";\r\n\r\nimport { DrawTiledLayer } from \"./2d/DrawTiledLayer.js\";\r\nimport { DrawImageObject } from \"./2d/DrawImageObject.js\";\r\nimport { DrawCircleObject } from \"./2d/DrawCircleObject.js\";\r\nimport { DrawConusObject } from \"./2d/DrawConusObject.js\";\r\nimport { DrawLineObject } from \"./2d/DrawLineObject.js\";\r\nimport { DrawPolygonObject } from \"./2d/DrawPolygonObject.js\";\r\nimport { DrawRectObject } from \"./2d/DrawRectObject.js\";\r\nimport { DrawTextObject } from \"./2d/DrawTextObject.js\";\r\nimport { WebGlEngine } from \"./WebGl/WebGlEngine.js\";\r\nimport { RenderLoopDebug } from \"./RenderLoopDebug.js\";\r\n\r\nimport { utils } from \"../index.js\";\r\n/**\r\n * Class represents the render loop,\r\n * on each time stage start, a new RenderLoop class instance created,\r\n * after stage stop, RenderLoop stops and its instance removed\r\n * @see {@link IRender} a part of iRender\r\n * @hideconstructor\r\n */\r\nexport class RenderLoop {\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isActive;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #isCleared;\r\n    /**\r\n     * @type {RenderLoopDebug}\r\n     */\r\n    #renderLoopDebug;\r\n    #fpsAverageCountTimer;\r\n    /**\r\n     * \r\n     * @type {GameStageData} \r\n     */\r\n    #stageData;\r\n    /**\r\n     * @type { WebGlEngine }\r\n     */\r\n    #webGlEngine;\r\n    /**\r\n     * \r\n     * @type {SystemSettings}\r\n     */\r\n    #systemSettings;\r\n    /**\r\n     * @type {EventTarget}\r\n     */\r\n    #emitter = new EventTarget();\r\n    constructor(systemSettings, stageData, WebGlEngine) {\r\n        this.#systemSettings = systemSettings;\r\n        this.#stageData = stageData;\r\n        this.#renderLoopDebug = new RenderLoopDebug(this.#systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime);\r\n        this.#webGlEngine = WebGlEngine;\r\n\r\n        this.#webGlEngine._initDrawCallsDebug(this.renderLoopDebug);\r\n        \r\n        if (this.#systemSettings.gameOptions.render.cyclesTimeCalc.check === CONST.OPTIMIZATION.CYCLE_TIME_CALC.AVERAGES) {\r\n            this.#fpsAverageCountTimer = setInterval(() => this.#countFPSaverage(), this.#systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns { GameStageData }\r\n     */\r\n    get stageData() {\r\n        return this.#stageData;\r\n    }\r\n\r\n    /**\r\n     * @returns { RenderLoopDebug }\r\n     */\r\n    get renderLoopDebug() {\r\n        return this.#renderLoopDebug;\r\n    }\r\n    \r\n    /**\r\n     * @ignore\r\n     */\r\n    set _isCleared(value) {\r\n        this.#isCleared = value;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     */\r\n    get _isCleared() {\r\n        return this.#isCleared;\r\n    }\r\n\r\n    _start() {\r\n        this.#isActive = true;\r\n        requestAnimationFrame(this.#runRenderLoop);\r\n    }\r\n\r\n    _stop() {\r\n        this.#isActive = false;\r\n        this.#stageData = null;\r\n        this.renderLoopDebug.cleanupTempVars();\r\n        clearInterval(this.#fpsAverageCountTimer);\r\n        //this.#fpsAverageCountTimer = null;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Number} drawTimestamp - end time of previous frame's rendering \r\n     */\r\n    #runRenderLoop = (drawTimestamp) => {\r\n        if (!this.#isActive) {\r\n            return;\r\n        }\r\n        \r\n        const currentDrawTime = this.renderLoopDebug.currentDrawTime(drawTimestamp);\r\n        this.renderLoopDebug.prevDrawTime = drawTimestamp;\r\n        \r\n        const timeStart = performance.now(),\r\n            isCyclesTimeCalcCheckCurrent = this.#systemSettings.gameOptions.render.cyclesTimeCalc.check === CONST.OPTIMIZATION.CYCLE_TIME_CALC.CURRENT;\r\n            \r\n        this.emit(CONST.EVENTS.SYSTEM.RENDER.START);\r\n        this.#stageData._clearCollisionShapes();\r\n        this.#clearContext();\r\n        \r\n        this.render().then(() => {\r\n            const currentRenderTime = performance.now() - timeStart,\r\n                //r_time_less = minCycleTime - currentRenderTime,\r\n                wait_time = 0, //       ?\r\n                cycleTime = currentRenderTime + wait_time;\r\n                \r\n            if (isCyclesTimeCalcCheckCurrent) {\r\n                console.log(\"current draw take: \", (currentDrawTime), \" ms\");\r\n                console.log(\"current render() time: \", currentRenderTime);\r\n                console.log(\"draw calls: \", this.renderLoopDebug.drawCalls);\r\n                console.log(\"vertices draw: \", this.renderLoopDebug.verticesDraw);\r\n            } else {\r\n                this.renderLoopDebug.tempRCircleT = currentDrawTime;\r\n                this.renderLoopDebug.incrementTempRCircleTPointer();\r\n            }\r\n\r\n            this.emit(CONST.EVENTS.SYSTEM.RENDER.END);\r\n\r\n            if (this.#isActive) {\r\n                setTimeout(() => requestAnimationFrame(this.#runRenderLoop), wait_time);\r\n            }\r\n        }).catch((errors) => {\r\n            if (errors.forEach) {\r\n                errors.forEach((err) => {\r\n                    Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, err);\r\n                });\r\n            } else {\r\n                Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, errors.message);\r\n            }\r\n            this._stop();\r\n        });\r\n    };\r\n\r\n    /**\r\n     * @returns {Promise<void>}\r\n     */\r\n    async render() {\r\n        const renderObjects = this.#stageData.renderObjects;\r\n            \r\n        let errors = [],\r\n            isErrors = false,\r\n            len = renderObjects.length,\r\n            renderObjectsPromises = new Array(len);\r\n\r\n        if (len !== 0) {\r\n            //this.#checkCollisions(view.renderObjects);\r\n            for (let i = 0; i < len; i++) {\r\n                const object = renderObjects[i];\r\n                if (object.isRemoved) {\r\n                    renderObjects.splice(i, 1);\r\n                    i--;\r\n                    len--;\r\n                    continue;\r\n                }\r\n                if (\"hasAnimations\" in object && object.hasAnimations) {\r\n                    object._processActiveAnimations();\r\n                }\r\n                const promise = await this.#drawRenderObject(object)\r\n                    .catch((err) => Promise.reject(err));\r\n                renderObjectsPromises[i] = promise;\r\n            }\r\n            if (this.#systemSettings.gameOptions.debug.collisionShapes.drawLayerCollisionShapes) {\r\n                renderObjectsPromises.push(this.#drawCollisionShapesWebGl()\r\n                    .catch((err) => Promise.reject(err))); \r\n            }\r\n        }\r\n        const bindResults = await Promise.allSettled(renderObjectsPromises);\r\n        bindResults.forEach((result) => {\r\n            if (result.status === \"rejected\") {\r\n                Promise.reject(result.reason);\r\n                isErrors = true;\r\n                errors.push(result.reason);\r\n            }\r\n        });\r\n            \r\n        this._isCleared = false;\r\n        if (isErrors === false) {\r\n            this.#stageData._processPendingRenderObjects();\r\n            return Promise.resolve();\r\n        } else {\r\n            return Promise.reject(errors);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    addEventListener = (eventName, listener, options) => {\r\n        this.#emitter.addEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName \r\n     * @param {*} listener \r\n     * @param {*=} options \r\n     */\r\n    removeEventListener = (eventName, listener, options) => {\r\n        this.#emitter.removeEventListener(eventName, listener, options);\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} eventName\r\n     * @param  {...any} eventParams\r\n     */\r\n    emit = (eventName, ...eventParams) => {\r\n        const event = new Event(eventName);\r\n        event.data = [...eventParams];\r\n        this.#emitter.dispatchEvent(event);\r\n    };\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject | DrawTiledLayer} renderObject \r\n     * @returns {Promise<void>}\r\n     */\r\n    #drawRenderObject(renderObject) {\r\n        return this.#webGlEngine._preRender()\r\n            .then(() => this.#isActive ? this.#webGlEngine._drawRenderObject(renderObject, this.stageData) : Promise.resolve())\r\n            .then((args) => this.#webGlEngine._postRender(args));\r\n    }\r\n\r\n    #clearContext() {\r\n        this.#webGlEngine._clearView();\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    #drawCollisionShapesWebGl() {\r\n        return new Promise((resolve) => {\r\n            const b = this.stageData.getRawCollisionShapes(),\r\n                eB = this.stageData.getEllipseCollisionShapes(),\r\n                pB = this.stageData.getPointCollisionShapes(),\r\n                bDebug = this.stageData.getDebugObjectCollisionShapes(),\r\n                len = this.stageData.collisionShapesLen,\r\n                eLen = this.stageData.ellipseBLen,\r\n                pLen = this.stageData.pointBLen,\r\n                bDebugLen = this.#systemSettings.gameOptions.debug.collisionShapes.drawObjectCollisionShapes ? bDebug.length : 0;\r\n        \r\n            if (len)\r\n                this.#webGlEngine._drawLines(b, this.#systemSettings.gameOptions.debug.collisionShapes.color, this.#systemSettings.gameOptions.debug.collisionShapes.width);\r\n            this.renderLoopDebug.incrementDrawCallsCounter();\r\n            if (eLen) {\r\n                //draw ellipse collision shapes\r\n                for (let i = 0; i < eLen; i+=4) {\r\n                    const x = eB[i],\r\n                        y = eB[i+1],\r\n                        radX = eB[i+2],\r\n                        radY = eB[i+3],\r\n                        vertices = utils.calculateEllipseVertices(x, y, radX, radY);\r\n                    this.#webGlEngine._drawPolygon({x: 0, y: 0, vertices, isOffsetTurnedOff: true}, this.stageData);\r\n                    this.renderLoopDebug.incrementDrawCallsCounter();\r\n                    //this.#webGlEngine._drawLines(vertices, this.systemSettings.gameOptions.debug.collisionShapes.color, this.systemSettings.gameOptions.debug.collisionShapes.width);\r\n                }\r\n            }\r\n            if (pLen) {\r\n                //draw point collisionShapes\r\n                for (let i = 0; i < pLen; i+=2) {\r\n                    const x = pB[i],\r\n                        y = pB[i+1],\r\n                        vertices = [x,y, x+1,y+1];\r\n\r\n                    this.#webGlEngine._drawLines(vertices, this.#systemSettings.gameOptions.debug.collisionShapes.color, this.#systemSettings.gameOptions.debug.collisionShapes.width);\r\n                    this.renderLoopDebug.incrementDrawCallsCounter();\r\n                }\r\n            }\r\n            if (bDebugLen > 0) {\r\n                this.#webGlEngine._drawLines(bDebug, this.#systemSettings.gameOptions.debug.collisionShapes.color, this.#systemSettings.gameOptions.debug.collisionShapes.width);\r\n            }\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    \r\n    /**\r\n     * \r\n     * @param {DrawTiledLayer} renderLayer \r\n     * @returns {Promise<void>}\r\n     */\r\n    #layerCollisionShapesPrecalculation(renderLayer) {\r\n        return new Promise((resolve, reject) => {\r\n\r\n        });\r\n    }\r\n\r\n    #countFPSaverage() {\r\n        const timeLeft = this.#systemSettings.gameOptions.render.cyclesTimeCalc.averageFPStime,\r\n            steps = this.renderLoopDebug.tempRCircleTPointer;\r\n        let fullTime = 0;\r\n        for (let i = 0; i < steps; i++) {\r\n            const timeStep = this.renderLoopDebug.tempRCircleT[i];\r\n            fullTime += timeStep;\r\n        }\r\n        console.log(\"FPS average for\", timeLeft/1000, \"sec, is \", (1000 / (fullTime / steps)).toFixed(2));\r\n        console.log(\"Last loop info:\");\r\n        console.log(\"Webgl draw calls: \", this.renderLoopDebug.drawCalls);\r\n        console.log(\"Vertices draw: \", this.renderLoopDebug.verticesDraw);\r\n        // cleanup\r\n        this.renderLoopDebug.cleanupTempVars();\r\n    }\r\n}","/**\n * Debug info fro RenderLoop\n * @see {@link RenderLoop} a part of RenderLoop\n * @hideconstructor\n */\nexport class RenderLoopDebug {\n    /**\n     * @type {number}\n     */\n    #verticesNum = 0;\n    /**\n     * @type {number}\n     */\n    #drawCalls = 0;\n    /**\n     * @type {number}\n     */\n    #prevDrawTime = 0;\n    /**\n     * @type {Float32Array}\n     */\n    #tempRCircleT;\n    /**\n     * @type {number}\n     */\n    #tempRCircleTPointer = 0;\n    /**\n     * @type {NodeJS.Timeout | null}\n     */\n    constructor(averageFPStime) {\n        this.#tempRCircleT = new Float32Array(averageFPStime);\n    }\n\n    get drawCalls() {\n        return this.#drawCalls;\n    }\n\n    get verticesDraw() {\n        return this.#verticesNum;\n    }\n\n    /**\n     * @returns {Float32Array}\n     */\n    get tempRCircleT() {\n        return this.#tempRCircleT;\n    }\n\n    get tempRCircleTPointer() {\n        return this.#tempRCircleTPointer;\n    }\n\n    /**\n     * @param {number} time\n     */\n    set tempRCircleT(time) {\n        this.#tempRCircleT[this.#tempRCircleTPointer] = time;\n    }\n\n    set prevDrawTime(drawTime) {\n        this.#prevDrawTime = drawTime;\n    }\n\n    currentDrawTime(drawTimestamp) {\n        return drawTimestamp - this.#prevDrawTime;\n    }\n\n    incrementTempRCircleTPointer() {\n        this.#tempRCircleTPointer++;\n    }\n\n    incrementDrawCallsCounter() {\n        this.#drawCalls+=1;\n    }\n\n    set verticesDraw(vertices) {\n        this.#verticesNum += vertices;\n    }\n\n    cleanupDebugInfo() {\n        this.#verticesNum = 0;\n        this.#drawCalls = 0;\n    }\n\n    cleanupDrawCallsCounter() {\n        this.#drawCalls = 0;\n    }\n\n    cleanupTempVars() {\n        this.#tempRCircleT.fill(0);\n        this.#tempRCircleTPointer = 0;\n    }\n}","import { ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { ISystem } from \"./ISystem.js\";\nimport { SystemSettings } from \"../configs.js\";\n\nimport { LoadingStage } from \"../design/LoadingStage.js\";\n\nconst loadingPageName = \"loadingPage\";\n/**\n * A main app class, <br>\n * Holder class for GameStage,<br>\n * can register new GameStages,<br>\n * init and preload data for them,<br>\n */\nexport class System {\n    /**\n     * @type {Map<string, Object>}\n     */\n    #registeredStages;\n    /**\n     * @type {ISystem}\n     */\n    #iSystem;\n    /**\n     * @param {SystemSettings} iSystemSettings - holds iSystem settings\n     * @param {HTMLElement | null} [canvasContainer = null] - If it is not passed, iSystem will create div element and attach it to body\n     */\n    constructor(iSystemSettings, canvasContainer) {\n        if (!iSystemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"iSystemSettings should be passed to class instance\");\n        }\n        this.#registeredStages = new Map();\n\n        if (!canvasContainer) {\n            canvasContainer = document.createElement(\"div\");\n            document.body.appendChild(canvasContainer);\n        }\n\n        this.#iSystem = new ISystem(iSystemSettings, this.#registeredStages, canvasContainer);\n\n        this.#addPreloadStage();\n    }\n\n    /**\n     * @returns {ISystem}\n     */\n    get iSystem() {\n        return this.#iSystem;\n    }\n    \n    /**\n     * A main factory method for create GameStage instances, <br>\n     * register them in a System and call GameStage.register() stage\n     * @param {string} screenPageName\n     * @param {Object} extendedGameStage - extended GameStage class(not an instance!)\n     */\n    registerStage(screenPageName, extendedGameStage) {\n        if (screenPageName && typeof screenPageName === \"string\" && screenPageName.trim().length > 0) {\n            const stageInstance = new extendedGameStage();\n            stageInstance._register(screenPageName, this.iSystem);\n            this.#registeredStages.set(screenPageName, stageInstance);\n        } else {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"valid class name should be provided\");\n        }\n    }\n\n    /**\n     * Preloads assets for all registered pages\n     * @return {Promise<void>}\n     */\n    preloadAllData() {\n        return this.#iSystem.iLoader.preload();\n    }\n\n    #addPreloadStage() {\n        this.registerStage(loadingPageName, LoadingStage);\n\n        this.#iSystem.iLoader.addEventListener(\"loadstart\", this.#loadStart);\n        this.#iSystem.iLoader.addEventListener(\"progress\", this.#loadProgress);\n        this.#iSystem.iLoader.addEventListener(\"load\", this.#loadComplete);\n    }\n\n    #loadStart = (event) => {\n        this.#iSystem.startGameStage(loadingPageName, { total: event.total });\n    };\n\n    #loadProgress = (event) => {\n        const uploaded = event.loaded,\n            left = event.total,\n            loadingPage = this.#registeredStages.get(loadingPageName);\n            \n        loadingPage._progress(uploaded, left);\n    };\n\n    #loadComplete = () => {\n        this.#iSystem.stopGameStage(loadingPageName);\n    };\n}","/**\n * storing current WebGLTexture\n */\nexport class ImageTempStorage {\n    /**\n     * @type {Number}\n     */\n    #textureIndex;\n    /**\n     * @type {WebGLTexture}\n     */\n    #texture;\n    /**\n     * @type {boolean}\n     */\n    #isTextureRecalculated = true;\n    constructor(texture, textureIndex = 0) {\n        this.#texture = texture;\n        this.#textureIndex = textureIndex;\n    }\n\n    get _isTextureRecalculated() {\n        return this.#isTextureRecalculated;\n    }\n\n    set _isTextureRecalculated(value) {\n        this.#isTextureRecalculated = value;\n    }\n\n    get _texture() {\n        return this.#texture;\n    }\n\n    set _texture(value) {\n        this.#texture = value;\n    }\n\n    get _textureIndex() {\n        return this.#textureIndex;\n    }\n}","/**\r\n * storing vectors and textures for DrawTiledLayer\r\n */\r\nexport class TiledLayerTempStorage {\r\n    /**\r\n     * @type {Array}\r\n     */\r\n    #vectors;\r\n    /**\r\n     * @type {Array}\r\n     */\r\n    #textures;\r\n    /**\r\n     * @type {Int32Array}\r\n     */\r\n    #collisionShapesTempIndexes;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #bufferSize = 0;\r\n    /**\r\n     * @param {number} cells \r\n     **/\r\n    #cells = 0;\r\n    /**\r\n     * @param {number} nonEmptyCells \r\n     */\r\n    #nonEmptyCells = 0;\r\n    constructor(cells, nonEmptyCells) {\r\n        this._initiateStorageData(cells, nonEmptyCells);\r\n    }\r\n\r\n    get cells() {\r\n        return this.#cells;\r\n    }\r\n\r\n    get vectors() {\r\n        return this.#vectors;\r\n    }\r\n\r\n    get textures() {\r\n        return this.#textures;\r\n    }\r\n\r\n    get _cTempIndexes() {\r\n        return this.#collisionShapesTempIndexes;\r\n    }\r\n\r\n    get bufferSize() {\r\n        return this.#bufferSize;\r\n    }\r\n\r\n    _initiateStorageData(cellsSize, emptyCells) {\r\n        this.#cells = cellsSize;\r\n        this.#nonEmptyCells = emptyCells ? emptyCells : cellsSize;\r\n        if (this.#nonEmptyCells > cellsSize) {\r\n            this.#nonEmptyCells  = cellsSize;\r\n        }\r\n        this.#bufferSize = this.#nonEmptyCells * 12;\r\n\r\n        this.#vectors = new Array(this.#bufferSize);\r\n        this.#textures = new Array(this.#bufferSize);\r\n        this.#collisionShapesTempIndexes = new Int32Array(this.#cells * 4);\r\n    }\r\n}","const imgVertexShader =  `\r\n    attribute vec2 a_texCoord;\r\n\r\n    attribute vec2 a_position;\r\n\r\n    uniform vec2 u_translation;\r\n    uniform float u_rotation;\r\n    uniform vec2 u_scale;\r\n\r\n    uniform vec2 u_resolution;\r\n\r\n    varying vec2 v_texCoord;\r\n\r\n    void main(void) {\r\n        float c = cos(u_rotation);\r\n        float s = sin(u_rotation);\r\n\r\n        mat3 translationMatrix1 = mat3(\r\n            1, 0, 0,\r\n            0, 1, 0,\r\n            u_translation.x, u_translation.y, 1\r\n        );\r\n\r\n        mat3 translationMatrix2 = mat3(\r\n            1, 0, 0,\r\n            0, 1, 0,\r\n            -u_translation.x, -u_translation.y, 1\r\n        );\r\n        \r\n        mat3 rotationMatrix = mat3(\r\n            c, s, 0,\r\n            -s, c, 0,\r\n            0, 0, 1\r\n        );\r\n\r\n        mat3 scalingMatrix = mat3(\r\n            u_scale.x, 0, 0,\r\n            0, u_scale.y, 0,\r\n            0, 0, 1\r\n        );\r\n\r\n        mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\r\n    \r\n        vec2 position = (matrix * vec3(a_position, 1)).xy;\r\n\r\n        vec2 clipSpace = position / u_resolution * 2.0 - 1.0;\r\n\r\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n        \r\n        v_texCoord = a_texCoord;\r\n    }`;\r\nconst imgFragmentShader = `\r\n    precision mediump float;\r\n\r\n    uniform sampler2D u_image;\r\n\r\n    //texCoords passed in from the vertex shader\r\n    varying vec2 v_texCoord;\r\n    void main() {\r\n        vec4 color = texture2D(u_image, v_texCoord);\r\n        gl_FragColor = color;\r\n    }`;\r\nconst imgUniforms = [\"u_translation\", \"u_rotation\", \"u_scale\", \"u_resolution\",\"u_image\"];\r\nconst imgAttributes = [\"a_position\", \"a_texCoord\"];\r\n\r\nexport {imgVertexShader, imgFragmentShader, imgUniforms, imgAttributes};","const imgMVertexShader =  `\r\n    attribute vec2 a_texCoord;\r\n\r\n    attribute vec2 a_position;\r\n\r\n    uniform vec2 u_resolution;\r\n\r\n    varying vec2 v_texCoord;\r\n\r\n    void main(void) {\r\n        vec2 clipSpace = a_position / u_resolution * 2.0 - 1.0;\r\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n        v_texCoord = a_texCoord;\r\n    }`;\r\n\r\nconst imgMFragmentShader = `\r\n    precision mediump float;\r\n\r\n    uniform sampler2D u_image;\r\n\r\n    //texCoords passed in from the vertex shader\r\n    varying vec2 v_texCoord;\r\n    void main() {\r\n        vec4 color = texture2D(u_image, v_texCoord);\r\n        gl_FragColor = color;\r\n    }`;\r\nconst imgMUniforms = [\"u_resolution\", \"u_image\"];\r\nconst imgMAttributes = [\"a_position\", \"a_texCoord\"];\r\n\r\nexport { imgMVertexShader, imgMFragmentShader, imgMUniforms, imgMAttributes };","const primitivesVertexShader =  `\r\n    precision mediump float;\r\n\r\n    attribute vec2 a_position;\r\n\r\n    uniform vec2 u_translation;\r\n    uniform float u_rotation;\r\n    uniform vec2 u_scale;\r\n\r\n    uniform vec2 u_resolution;\r\n\r\n    void main(void) {\r\n        float c = cos(u_rotation);\r\n        float s = sin(u_rotation);\r\n\r\n        mat3 translationMatrix1 = mat3(\r\n            1, 0, 0,\r\n            0, 1, 0,\r\n            u_translation.x, u_translation.y, 1\r\n        );\r\n        \r\n        mat3 rotationMatrix = mat3(\r\n            c, s, 0,\r\n            -s, c, 0,\r\n            0, 0, 1\r\n        );\r\n\r\n        mat3 scalingMatrix = mat3(\r\n            u_scale.x, 0, 0,\r\n            0, u_scale.y, 0,\r\n            0, 0, 1\r\n        );\r\n        \r\n        mat3 matrix = translationMatrix1 * rotationMatrix * scalingMatrix;\r\n\r\n        vec2 position = (matrix * vec3(a_position, 1)).xy;\r\n\r\n        vec2 clipSpace = position / u_resolution * 2.0 - 1.0;\r\n\r\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\r\n    }\r\n`;\r\nconst primitivesFragmentShader = `\r\n    precision mediump float;\r\n\r\n    uniform vec4 u_color;\r\n    uniform float u_fade_min; \r\n    uniform float u_fade_max;\r\n    uniform vec2 u_resolution;\r\n    uniform vec2 u_translation;\r\n\r\n    void main(void) {\r\n        vec4 p = u_color;\r\n        if (u_fade_min > 0.0) {\r\n            vec2 fix_tr = vec2(u_translation.x, u_resolution.y - u_translation.y); \r\n            float distance = distance(fix_tr.xy, gl_FragCoord.xy);\r\n            if (u_fade_min <= distance && distance <= u_fade_max) {\r\n                float percent = ((distance - u_fade_max) / (u_fade_min - u_fade_max)) * 100.0;\r\n                p.a = u_color.a * (percent / 100.0);\r\n            }\r\n        }\r\n\r\n        gl_FragColor = p;\r\n    }\r\n`;\r\nconst primitivesUniforms = [\"u_translation\", \"u_rotation\", \"u_scale\", \"u_resolution\", \"u_fade_min\", \"u_fade_max\", \"u_color\"];\r\nconst primitivesAttributes = [\"a_position\"];\r\n\r\nexport { primitivesVertexShader, primitivesFragmentShader, primitivesUniforms, primitivesAttributes };","import { ERROR_CODES, CONST, DRAW_TYPE, WARNING_CODES } from \"../../constants.js\";\r\nimport { crossProduct } from \"../../utils.js\";\r\nimport { Exception, Warning } from \"../Exception.js\";\r\nimport { GameStageData } from \"../GameStageData.js\";\r\nimport { ImageTempStorage } from \"../Temp/ImageTempStorage.js\";\r\n\r\nimport { DrawTiledLayer } from \"../2d/DrawTiledLayer.js\";\r\nimport { DrawCircleObject } from \"../2d/DrawCircleObject.js\";\r\nimport { DrawConusObject } from \"../2d/DrawConusObject.js\";\r\nimport { DrawLineObject } from \"../2d/DrawLineObject.js\";\r\nimport { DrawPolygonObject } from \"../2d/DrawPolygonObject.js\";\r\nimport { DrawRectObject } from \"../2d/DrawRectObject.js\";\r\nimport { DrawTextObject } from \"../2d/DrawTextObject.js\";\r\n\r\nimport AssetsManager from \"../../../modules/assetsm/src/AssetsManager.js\";\r\nimport { utils } from \"../../index.js\";\r\n\r\nexport class WebGlEngine {\r\n    /**\r\n     * @type {WebGLRenderingContext}\r\n     */\r\n    #gl;\r\n    /**\r\n     * @type {number}\r\n     */\r\n    #MAX_TEXTURES;\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #debug;\r\n    /**\r\n     * @type {Object}\r\n     */\r\n    #gameOptions;\r\n    /**\r\n     * @type {AssetsManager}\r\n     */\r\n    #loaderReference;\r\n    /**\r\n     * @type {WebGLBuffer | null}\r\n     */\r\n    #positionBuffer;\r\n    /**\r\n     * @type {WebGLBuffer | null}\r\n     */\r\n    #texCoordBuffer;\r\n    /**\r\n     * @type {Array<number> | null}\r\n     */\r\n    #currentVertices = null;\r\n    /**\r\n     * @type {Array<number> | null}\r\n     */\r\n    #currentTextures = null;\r\n    /**\r\n     * @type {Map<string, WebGLProgram>}\r\n     */\r\n    #registeredWebGlPrograms = new Map();\r\n    /**\r\n     * @type {Map<string, Object<string, WebGLUniformLocation | number>>}\r\n     */\r\n    #webGlProgramsVarsLocations = new Map();\r\n    /**\r\n     * @type {Map<string, {method: Function, webglProgramName: string}>}\r\n     */\r\n    #registeredRenderObjects = new Map();\r\n\r\n    /**\r\n     * @type {boolean}\r\n     */\r\n    #loopDebug;\r\n\r\n    constructor(context, gameOptions, iLoader) {\r\n        if (!context || !(context instanceof WebGLRenderingContext)) {\r\n            Exception(ERROR_CODES.UNEXPECTED_INPUT_PARAMS, \" context parameter should be specified and equal to WebGLRenderingContext\");\r\n        }\r\n        \r\n        this.#gl = context;\r\n        this.#gameOptions = gameOptions;\r\n        this.#loaderReference = iLoader;\r\n        this.#debug = gameOptions.debug.checkWebGlErrors;\r\n        this.#MAX_TEXTURES = context.getParameter(context.MAX_TEXTURE_IMAGE_UNITS);\r\n        this.#positionBuffer = context.createBuffer();\r\n        this.#texCoordBuffer = context.createBuffer();\r\n\r\n        this._registerObjectRender(DrawTextObject.name, this._bindText, CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M);\r\n        this._registerObjectRender(DrawRectObject.name, this._bindPrimitives, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        this._registerObjectRender(DrawPolygonObject.name, this._bindPrimitives, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        this._registerObjectRender(DrawCircleObject.name, this._bindConus, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        this._registerObjectRender(DrawConusObject.name, this._bindConus, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        this._registerObjectRender(DrawTiledLayer.name, this._bindTileImages, CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M);\r\n        this._registerObjectRender(DrawLineObject.name, this._bindLine, CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        this._registerObjectRender(DRAW_TYPE.IMAGE, this._bindImage, CONST.WEBGL.DRAW_PROGRAMS.IMAGES_M);\r\n    }\r\n\r\n    getProgram(name) {\r\n        return this.#registeredWebGlPrograms.get(name);\r\n    }\r\n\r\n    getProgramVarLocations(name) {\r\n        return this.#webGlProgramsVarsLocations.get(name);\r\n    }\r\n\r\n    _fixCanvasSize(width, height) {\r\n        this.#gl.viewport(0, 0, width, height);\r\n    }\r\n    _initiateJsRender = (stageData) => {\r\n        return new Promise((resolve, reject) => {\r\n            const tileLayers = stageData.getObjectsByInstance(DrawTiledLayer),\r\n                [ settingsWorldWidth, settingsWorldHeight ] = stageData.worldDimensions;\r\n\r\n            // count max possible collisionShapes sizes\r\n            let maxBSize = 0,\r\n                maxESize = 0,\r\n                maxPSize = 0,\r\n                maxWorldW = 0,\r\n                maxWorldH = 0;\r\n\r\n            tileLayers.forEach(tiledLayer => {\r\n                const setCollisionShapes = tiledLayer.setCollisionShapes,\r\n                    layerData = tiledLayer.layerData,\r\n                    tilemap = tiledLayer.tilemap,\r\n                    tilesets = tiledLayer.tilesets,\r\n                    { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                    tilewidth = dtwidth,\r\n                    tileheight = dtheight;\r\n\r\n                for (let i = 0; i < tilesets.length; i++) {\r\n                    const layerCols = layerData.width,\r\n                        layerRows = layerData.height,\r\n                        worldW = tilewidth * layerCols,\r\n                        worldH = tileheight * layerRows;\r\n                        \r\n                    const polygonBondMax = layerData.polygonCollisionShapesLen,\r\n                        ellipseBondMax = layerData.ellipseCollisionShapesLen,\r\n                        pointBondMax = layerData.pointCollisionShapesLen; \r\n    \r\n                    if (maxWorldW < worldW) {\r\n                        maxWorldW = worldW;\r\n                    }\r\n                    if (maxWorldH < worldH) {\r\n                        maxWorldH = worldH;\r\n                    }\r\n                    \r\n                    if (setCollisionShapes) {\r\n                        maxBSize += polygonBondMax;\r\n                        maxESize += ellipseBondMax;\r\n                        maxPSize += pointBondMax;\r\n    \r\n                        // collisionShapes cleanups every draw cycles, we need to set world collisionShapes again\r\n                        \r\n                    }\r\n                }\r\n            });\r\n\r\n            if (maxWorldW !== 0 && maxWorldH !== 0 && (maxWorldW !== settingsWorldWidth || maxWorldH !== settingsWorldHeight)) {\r\n                Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\r\n                stageData._setWorldDimensions(maxWorldW, maxWorldH);\r\n            }\r\n\r\n            if (this.#gameOptions.render.collisionShapes.mapCollisionShapesEnabled) {\r\n                maxBSize+=16; //4 sides * 4 cords x1,y1,x2,y,2\r\n            }\r\n            stageData._setMaxCollisionShapesSize(maxBSize, maxESize, maxPSize);\r\n            stageData._initiateCollisionShapesData();\r\n\r\n            resolve(true);\r\n        });\r\n\r\n    };\r\n    _initWebGlAttributes = () => {\r\n        const gl = this.#gl;\r\n        gl.enable(gl.BLEND);\r\n        gl.enable(gl.STENCIL_TEST);\r\n        gl.stencilFunc(gl.ALWAYS, 1, 0xFF);\r\n        //if stencil test and depth test pass we replace the initial value\r\n        gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n        return Promise.resolve();\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    _initiateWasm = (stageData) => {\r\n        const url = this.#gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT ? this.#gameOptions.optimizationWASMUrl : this.#gameOptions.optimizationAssemblyUrl;\r\n        return new Promise((resolve, reject) => {\r\n            this.layerData = new WebAssembly.Memory({\r\n                initial:1000 // 6.4MiB x 10 = 64MiB(~67,1Mb)\r\n            });\r\n            this.layerDataFloat32 = new Float32Array(this.layerData.buffer);\r\n            const importObject = {\r\n                env: {\r\n                    memory: this.layerData,\r\n                    logi: console.log,\r\n                    logf: console.log\r\n                }\r\n            };\r\n\r\n            fetch(url)\r\n                .then((response) => response.arrayBuffer())\r\n                .then((module) => WebAssembly.instantiate(module, importObject))\r\n                .then((obj) => {\r\n                    this.calculateBufferData = obj.instance.exports.calculateBufferData;\r\n                    resolve();\r\n                });\r\n        });\r\n    };\r\n\r\n    _initDrawCallsDebug(debugObjReference) {\r\n        this.#loopDebug = debugObjReference;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {void}\r\n     */\r\n    _clearView() {\r\n        const gl = this.#gl;\r\n        this.#loopDebug.cleanupDebugInfo();\r\n        //cleanup buffer, is it required?\r\n        //gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        gl.clearColor(0, 0, 0, 0);// shouldn't be gl.clearColor(0, 0, 0, 1); ?\r\n        // Clear the color buffer with specified clear color\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * @returns {Promise<any>}\r\n     */\r\n    _render(verticesNumber, primitiveType, offset = 0) {\r\n        this.#gl.drawArrays(primitiveType, offset, verticesNumber);\r\n        // set blend to default\r\n        return Promise.resolve(verticesNumber);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    _preRender() {\r\n        return new Promise((resolve, reject) => {\r\n            const gl = this.#gl,\r\n                err = this.#debug ? gl.getError() : 0;\r\n            if (err !== 0) {\r\n                console.error(err);\r\n                throw new Error(\"Error num: \" + err);\r\n            } else {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns {Promise<void>}\r\n     */\r\n    _postRender(inputData) {\r\n        let verticesNumber = inputData;\r\n\r\n        // A workaround for backward capability in 1.5.n\r\n        if (Array.isArray(verticesNumber)) {\r\n            const [vertices, primitiveType] = inputData;\r\n            \r\n            this.#gl.drawArrays(primitiveType, 0, vertices);\r\n            verticesNumber = vertices;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            const gl = this.#gl;\r\n\r\n            if (verticesNumber !== 0) {\r\n                this.#loopDebug.incrementDrawCallsCounter();\r\n                this.#loopDebug.verticesDraw = verticesNumber;\r\n            }\r\n\r\n            gl.stencilFunc(gl.ALWAYS, 1, 0xFF);\r\n\r\n            if (this.#gameOptions.debug.delayBetweenObjectRender) {\r\n                setTimeout(() => {\r\n                    resolve();\r\n                }, 1000);\r\n            } else {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /*************************************\r\n     * Register and compile programs\r\n     ************************************/\r\n\r\n    /**\r\n     * \r\n     * @param {string} programName\r\n     * @param {string} vertexShader - raw vertex shader program\r\n     * @param {string} fragmentShader - raw fragment shader program \r\n     * @param {Array<string>} uVars - program uniform variables names\r\n     * @param {Array<string>} aVars - program attribute variables names\r\n     * @returns {Promise<void>}\r\n     */\r\n    _registerAndCompileWebGlProgram(programName, vertexShader, fragmentShader, uVars, aVars) {\r\n        const program = this.#compileWebGlProgram(vertexShader, fragmentShader),\r\n            varsLocations = this.#getProgramVarsLocations(program, uVars, aVars);\r\n        this.#registeredWebGlPrograms.set(programName, program);\r\n        this.#webGlProgramsVarsLocations.set(programName, varsLocations);\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * @returns {WebGLProgram}\r\n     */\r\n    #compileWebGlProgram (vertexShader, fragmentShader) {\r\n        const gl = this.#gl,\r\n            program = gl.createProgram();\r\n\r\n        if (program) {\r\n            const compVertexShader = this.#compileShader(gl, vertexShader, gl.VERTEX_SHADER);\r\n            if (compVertexShader) {\r\n                gl.attachShader(program, compVertexShader);\r\n            } else {\r\n                Exception(ERROR_CODES.WEBGL_ERROR, \"#compileShader(vertexShaderSource) is null\");\r\n            }\r\n\r\n            const compFragmentShader = this.#compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);\r\n            if (compFragmentShader) {\r\n                gl.attachShader(program, compFragmentShader);\r\n            } else {\r\n                Exception(ERROR_CODES.WEBGL_ERROR, \"#compileShader(fragmentShaderSource) is null\");\r\n            }\r\n\r\n            gl.linkProgram(program);\r\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n                const info = gl.getProgramInfoLog(program);\r\n                Exception(ERROR_CODES.WEBGL_ERROR, `Could not compile WebGL program. \\n\\n${info}`);\r\n            }\r\n        } else {\r\n            Exception(ERROR_CODES.WEBGL_ERROR, \"gl.createProgram() is null\");\r\n        }\r\n        return program;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {WebGLProgram} program\r\n     * @param {Array<string>} uVars - uniform variables\r\n     * @param {Array<string>} aVars - attributes variables\r\n     * @returns {Object<string, WebGLUniformLocation | number>} - uniform or attribute\r\n     */\r\n    #getProgramVarsLocations(program, uVars, aVars) {\r\n        const gl = this.#gl;\r\n        let locations = {};\r\n        uVars.forEach(elementName => {\r\n            locations[elementName] = gl.getUniformLocation(program, elementName);\r\n        });\r\n        aVars.forEach(elementName => {\r\n            locations[elementName] = gl.getAttribLocation(program, elementName);\r\n        });\r\n        return locations;\r\n    }\r\n\r\n    #compileShader(gl, shaderSource, shaderType) {\r\n        const shader = gl.createShader(shaderType);\r\n        if (shader) {\r\n            gl.shaderSource(shader, shaderSource);\r\n            gl.compileShader(shader);\r\n\r\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n                const info = gl.getShaderInfoLog(shader);\r\n                Exception(ERROR_CODES.WEBGL_ERROR, \"Couldn't compile webGl program. \\n\\n\" + info);\r\n            }\r\n        } else {\r\n            Exception(ERROR_CODES.WEBGL_ERROR, `gl.createShader(${shaderType}) is null`);\r\n        }\r\n        return shader;\r\n    }\r\n    /*------------------------------------\r\n     * End of Register and compile programs\r\n     -------------------------------------*/\r\n\r\n    /**********************************\r\n     * Predefined Drawing programs\r\n     **********************************/\r\n    _bindPrimitives = (renderObject, gl, pageData, program, vars) => {\r\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\r\n            x = renderObject.x - xOffset,\r\n            y = renderObject.y - yOffset,\r\n            scale = [1, 1],\r\n            rotation = renderObject.rotation,\r\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],\r\n            { \r\n                u_translation: translationLocation,\r\n                u_rotation: rotationRotation,\r\n                u_scale: scaleLocation,\r\n                u_resolution: resolutionUniformLocation,\r\n                u_color: colorUniformLocation,\r\n                a_position: positionAttributeLocation,\r\n                u_fade_min: fadeMinLocation\r\n            } = vars;\r\n            \r\n        let verticesNumber = 0;\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, x, y);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n        \r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        switch (renderObject.type) {\r\n        case DRAW_TYPE.RECTANGLE:\r\n            this.#setSingleRectangle(renderObject.width, renderObject.height);\r\n            verticesNumber += 6;\r\n            break;\r\n        case DRAW_TYPE.TEXT:\r\n            break;\r\n        case DRAW_TYPE.CIRCLE: {\r\n            const coords = renderObject.vertices;\r\n            gl.bufferData(gl.ARRAY_BUFFER, \r\n                new Float32Array(coords), gl.STATIC_DRAW);\r\n            verticesNumber += coords.length / 2;\r\n            break;\r\n        }\r\n        case DRAW_TYPE.POLYGON: {\r\n            const triangles = this.#triangulatePolygon(renderObject.vertices);\r\n            this.#bindPolygon(triangles);\r\n            const len = triangles.length;\r\n            if (len % 3 !== 0) {\r\n                Warning(WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, `polygons ${renderObject.id}, vertices are not correct, skip drawing`);\r\n                return Promise.reject();\r\n            }\r\n            verticesNumber += len / 2;\r\n            break;\r\n        }\r\n        }\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(renderObject.bgColor);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        if (blend) {\r\n            gl.blendFunc(blend[0], blend[1]);\r\n        }\r\n        \r\n        if (renderObject.isMaskAttached) {\r\n            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);\r\n        } else if (renderObject._isMask) {\r\n            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);\r\n        }\r\n        return this._render(verticesNumber, gl.TRIANGLES);\r\n    };\r\n    _bindConus = (renderObject, gl, pageData, program, vars) => {\r\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\r\n            x = renderObject.x - xOffset,\r\n            y = renderObject.y - yOffset,\r\n            scale = [1, 1],\r\n            rotation = renderObject.rotation,\r\n            { \r\n                u_translation: translationLocation,\r\n                u_rotation: rotationRotation,\r\n                u_scale: scaleLocation,\r\n                u_resolution: resolutionUniformLocation,\r\n                u_color: colorUniformLocation,\r\n                a_position: positionAttributeLocation,\r\n                u_fade_max: fadeMaxLocation,\r\n                u_fade_min: fadeMinLocation\r\n            } = vars,\r\n            coords = renderObject.vertices,\r\n            fillStyle = renderObject.bgColor,\r\n            fade_min = renderObject.fade_min,\r\n            fadeLen = renderObject.radius,\r\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA];\r\n        let verticesNumber = 0;\r\n\r\n        gl.useProgram(program);\r\n        \r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, x, y);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, fade_min);\r\n        gl.uniform1f(fadeMaxLocation, fadeLen);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, \r\n            new Float32Array(coords), gl.STATIC_DRAW);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        verticesNumber += coords.length / 2;\r\n\r\n        if (blend) {\r\n            gl.blendFunc(blend[0], blend[1]);\r\n        }\r\n\r\n        const colorArray = this.#rgbaToArray(fillStyle);\r\n\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        if (renderObject.isMaskAttached) {\r\n            gl.stencilFunc(gl.EQUAL, renderObject._maskId, 0xFF);\r\n        } else if (renderObject._isMask) {\r\n            gl.stencilFunc(gl.ALWAYS, renderObject.id, 0xFF);\r\n        }\r\n        \r\n        return this._render(verticesNumber, gl.TRIANGLE_FAN);\r\n    };\r\n\r\n    _bindText = (renderObject, gl, pageData, program, vars) => {\r\n        const { u_translation: translationLocation,\r\n            u_rotation: rotationRotation,\r\n            u_scale: scaleLocation,\r\n            u_resolution: resolutionUniformLocation,\r\n            a_position: positionAttributeLocation,\r\n            a_texCoord: texCoordLocation,\r\n            u_image: u_imageLocation } = vars;\r\n\r\n        const {width:boxWidth, height:boxHeight} = renderObject.collisionShapes,\r\n            image_name = renderObject.text,\r\n            [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\r\n            x = renderObject.x - xOffset,\r\n            y = renderObject.y - yOffset - boxHeight,\r\n            blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];\r\n\r\n        const rotation = renderObject.rotation || 0,\r\n            scale = [1, 1];\r\n        const vecX1 = x,\r\n            vecY1 = y,\r\n            vecX2 = vecX1 + boxWidth,\r\n            vecY2 = vecY1 + boxHeight;\r\n\r\n        const verticesBufferData = [\r\n            vecX1, vecY1,\r\n            vecX2, vecY1,\r\n            vecX1, vecY2,\r\n            vecX1, vecY2,\r\n            vecX2, vecY1,\r\n            vecX2, vecY2\r\n        ],\r\n        texturesBufferData = [\r\n            0, 0,\r\n            1, 0,\r\n            0, 1,\r\n            0, 1,\r\n            1, 0,\r\n            1, 1\r\n        ];\r\n        let verticesNumber = 0;\r\n\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform2f(translationLocation, x, y);\r\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        \r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBufferData), gl.STATIC_DRAW);\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        //textures buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texturesBufferData), gl.STATIC_DRAW);\r\n\r\n        gl.enableVertexAttribArray(texCoordLocation);\r\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n        \r\n        verticesNumber += 6;\r\n        // remove box\r\n        // fix text edges\r\n        gl.blendFunc(blend[0], blend[1]);\r\n        //\r\n        //var currentTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);\r\n        \r\n        let textureStorage = renderObject._textureStorage;\r\n        if (!textureStorage) {\r\n            //const activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);\r\n            textureStorage = new ImageTempStorage(gl.createTexture());\r\n            renderObject._textureStorage = textureStorage;\r\n        }\r\n        if (textureStorage._isTextureRecalculated === true) {\r\n            this.#updateTextWebGlTexture(gl, textureStorage._texture, renderObject._textureCanvas);\r\n            textureStorage._isTextureRecalculated = false;\r\n        } else {\r\n            this.#bindTexture(gl, textureStorage._texture);\r\n        }\r\n        gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\r\n        gl.depthMask(false);\r\n        return this._render(verticesNumber, gl.TRIANGLES);\r\n        \r\n    };\r\n\r\n    _bindImage = (renderObject, gl, pageData, program, vars) => {\r\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\r\n            x = renderObject.x - xOffset,\r\n            y = renderObject.y - yOffset;\r\n\r\n        if (renderObject.vertices && this.#gameOptions.debug.collisionShapes.drawObjectCollisionShapes) {\r\n            pageData._enableDebugObjectCollisionShapes();\r\n            pageData._addImageDebugCollisionShapes(utils.calculateLinesVertices(x, y, renderObject.rotation, renderObject.vertices));\r\n        }\r\n        \r\n        const {\r\n            u_resolution: resolutionUniformLocation,\r\n            a_position: positionAttributeLocation,\r\n            a_texCoord: texCoordLocation,\r\n            u_image: u_imageLocation } = vars;\r\n\r\n        if (!renderObject.image) {\r\n            const image = this.#loaderReference.getImage(renderObject.key);\r\n            if (!image) {\r\n                Exception(ERROR_CODES.CANT_GET_THE_IMAGE, \"iLoader can't get the image with key: \" + renderObject.key);\r\n            } else {\r\n                renderObject.image = image;\r\n            }\r\n        }\r\n        const atlasImage = renderObject.image,\r\n              animationIndex = renderObject.imageIndex,\r\n              shapeMaskId = renderObject._maskId,\r\n              spacing = renderObject.spacing,\r\n              margin = renderObject.margin,\r\n              blend = renderObject.blendFunc ? renderObject.blendFunc : [gl.ONE, gl.ONE_MINUS_SRC_ALPHA],\r\n              scale = [1, 1];\r\n        \r\n        let imageX = margin,\r\n            imageY = margin,\r\n            colNum = 0,\r\n            rowNum = 0;\r\n\r\n        if (animationIndex !== 0) {\r\n            const imageColsNumber = (atlasImage.width + spacing - (2*margin)) / (renderObject.width + spacing);\r\n            colNum = animationIndex % imageColsNumber;\r\n            rowNum = Math.floor(animationIndex / imageColsNumber);\r\n            imageX = colNum * renderObject.width + (colNum * spacing) + margin,\r\n            imageY = rowNum * renderObject.height + (rowNum * spacing) + margin;\r\n        }\r\n\r\n        // transform, scale and rotate should be done in js side\r\n        //gl.uniform2f(translationLocation, x, y);\r\n        //gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n        //gl.uniform1f(rotationRotation, renderObject.rotation);\r\n        // multiple matrices:\r\n        const c = Math.cos(renderObject.rotation),\r\n              s = Math.sin(renderObject.rotation),\r\n              translationMatrix = [\r\n                  1, 0, x,\r\n                  0, 1, y,\r\n                  0, 0, 1],\r\n              rotationMatrix = [\r\n                  c, -s, 0,\r\n                  s, c, 0,\r\n                  0, 0, 1\r\n              ],\r\n              scaleMatrix = [\r\n                  scale[0], 0, 0,\r\n                  0, scale[1], 0,\r\n                  0, 0, 1\r\n              ];\r\n        const matMultiply = utils.mat3Multiply(utils.mat3Multiply(translationMatrix, rotationMatrix), scaleMatrix);\r\n\r\n        const posX = 0 - renderObject.width / 2,\r\n              posY = 0 - renderObject.height / 2;\r\n\r\n        const vecX1 = posX,\r\n              vecY1 = posY,\r\n              vecX2 = vecX1 + renderObject.width,\r\n              vecY2 = vecY1 + renderObject.height,\r\n              texX1 = 1 / atlasImage.width * imageX,\r\n              texY1 = 1 / atlasImage.height * imageY,\r\n              texX2 = texX1 + (1 / atlasImage.width * renderObject.width),\r\n              texY2 = texY1 + (1 / atlasImage.height * renderObject.height);\r\n        //console.log(\"mat1: \", matMult1);\r\n        //console.log(\"mat2: \", matMult2);\r\n        //console.log(\"x1y1: \", x1y1);\r\n        const vectorsD =  [\r\n            vecX1, vecY1,\r\n            vecX2, vecY1,\r\n            vecX1, vecY2,\r\n            vecX1, vecY2,\r\n            vecX2, vecY1,\r\n            vecX2, vecY2\r\n        ];\r\n        const vectors = utils.mat3MultiplyPosCoords(matMultiply, vectorsD),\r\n        textures = [\r\n            texX1, texY1,\r\n            texX2, texY1,\r\n            texX1, texY2,\r\n            texX1, texY2,\r\n            texX2, texY1,\r\n            texX2, texY2\r\n        ];\r\n        \r\n        //vec2 position = (u_transformMat * vec3(a_position, 1)).xy;\r\n        //console.log(\"translation x: \", x, \" y: \", y);\r\n        //console.log(\"scale x: \", scale[0], \" y: \", scale[1]);\r\n        //console.log(\"rotation: \", renderObject.rotation);\r\n        // Determine could we merge next drawObject or not\r\n        // 1. Find next object\r\n        const nextObject = this.getNextRenderObject(renderObject, pageData);\r\n        // 2. Is it have same texture and draw program?\r\n        if (nextObject && this._canImageObjectsMerge(renderObject, nextObject)) {\r\n            //\r\n            if (this.#currentVertices === null) {\r\n                this.#currentVertices = vectors;\r\n                this.#currentTextures = textures;\r\n                return Promise.resolve(0);\r\n            } else {\r\n                this.#currentVertices.push(...vectors);\r\n                this.#currentTextures.push(...textures);\r\n                return Promise.resolve(0);\r\n            }\r\n        } else {\r\n            \r\n            gl.useProgram(program);\r\n            // set the resolution\r\n            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n            // bind data and call draw\r\n            if (this.#currentVertices === null) {\r\n                this.#currentVertices = vectors;\r\n                this.#currentTextures = textures;\r\n            } else {\r\n                this.#currentVertices.push(...vectors);\r\n                this.#currentTextures.push(...textures);\r\n            }\r\n            \r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentVertices), gl.STATIC_DRAW);\r\n\r\n            const verticesNumber = this.#currentVertices.length / 2;\r\n            gl.enableVertexAttribArray(positionAttributeLocation);\r\n            //Tell the attribute how to get data out of positionBuffer\r\n            const size = 2,\r\n                type = gl.FLOAT, // data is 32bit floats\r\n                normalize = false,\r\n                stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n                offset = 0; // start of beginning of the buffer\r\n            gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n            //textures buffer\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentTextures), gl.STATIC_DRAW);\r\n\r\n            gl.enableVertexAttribArray(texCoordLocation);\r\n            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\r\n\r\n            let textureStorage = renderObject._textureStorage;\r\n            if (!textureStorage) {\r\n                textureStorage = new ImageTempStorage(gl.createTexture());\r\n                renderObject._textureStorage = textureStorage;\r\n            } \r\n            if (textureStorage._isTextureRecalculated === true) {\r\n                this.#updateWebGlTexture(gl, textureStorage._texture, renderObject.image);\r\n                textureStorage._isTextureRecalculated = false;\r\n            } else {\r\n                this.#bindTexture(gl, textureStorage._texture);\r\n            }    \r\n\r\n            gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\r\n            // make image transparent parts transparent\r\n            gl.blendFunc(blend[0], blend[1]);\r\n            if (shapeMaskId) {\r\n                gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);\r\n                //gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);\r\n            }\r\n            this.#currentVertices = null;\r\n            this.#currentTextures = null;\r\n            return this._render(verticesNumber, gl.TRIANGLES);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {*} obj1 \r\n     * @param {*} obj2\r\n     * @returns {boolean} \r\n     */\r\n    _canImageObjectsMerge = (obj1, obj2) => {\r\n        const registeredO1 = this.#registeredRenderObjects.get(obj1.constructor.name) || this.#registeredRenderObjects.get(obj1.type),\r\n            registeredO2 = this.#registeredRenderObjects.get(obj2.constructor.name) || this.#registeredRenderObjects.get(obj2.type);\r\n        if ((registeredO1.webglProgramName === registeredO2.webglProgramName)\r\n            && (obj1.type === obj2.type)\r\n            && (obj1.image === obj2.image)\r\n            && (obj2.isRemoved === false)) {\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} obj1 \r\n     * @param {*} obj2 \r\n     * @returns {boolean}\r\n     */\r\n    _canMergeNextTileObject = (obj1, obj2) => {\r\n        if ((obj2 instanceof DrawTiledLayer) \r\n            && (obj1.tilesetImages.length === 1) \r\n            && (obj2.tilesetImages.length === 1) \r\n            && (obj1.tilesetImages[0] === obj2.tilesetImages[0])\r\n            && (obj2.isRemoved === false)) {\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    _canTextBeMerged = (obj1, obj2) => {\r\n        const registeredO1 = this.#registeredRenderObjects.get(obj1.constructor.name) || this.#registeredRenderObjects.get(obj1.type),\r\n            registeredO2 = this.#registeredRenderObjects.get(obj2.constructor.name) || this.#registeredRenderObjects.get(obj2.type);\r\n        if ((registeredO1.webglProgramName === registeredO2.webglProgramName) \r\n            && (obj1.type === obj2.type)\r\n            && (obj2.isRemoved === false)) {\r\n                return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    _bindTileImages = async(renderLayer, gl, pageData, program, vars) => {\r\n        const { u_translation: translationLocation,\r\n            u_rotation: rotationRotation,\r\n            u_scale: scaleLocation,\r\n            u_resolution: resolutionUniformLocation,\r\n            a_position: positionAttributeLocation,\r\n            a_texCoord: texCoordLocation,\r\n            u_image: u_imageLocation } = vars;\r\n\r\n        gl.useProgram(program);\r\n        /**\r\n         * @type {Array<any> | null}\r\n         */\r\n        let renderLayerData = null;\r\n        switch (this.#gameOptions.optimization) {\r\n            case CONST.OPTIMIZATION.NATIVE_JS.NOT_OPTIMIZED:\r\n                renderLayerData = await this.#prepareRenderLayerOld(renderLayer, pageData);\r\n                break;\r\n            case CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT:\r\n            case CONST.OPTIMIZATION.WEB_ASSEMBLY.NATIVE_WAT:\r\n                renderLayerData = await this.#prepareRenderLayerWM(renderLayer, pageData);\r\n                break;\r\n            case CONST.OPTIMIZATION.NATIVE_JS.OPTIMIZED:\r\n            default:\r\n                renderLayerData = await this.#prepareRenderLayer(renderLayer, pageData);\r\n        }\r\n        \r\n        const translation = [0, 0],\r\n              scale = [1, 1],\r\n              rotation = renderLayer.rotation || 0,\r\n              drawMask = [\"ONE\", \"ONE_MINUS_SRC_ALPHA\"],\r\n              shapeMaskId = renderLayer._maskId;\r\n\r\n        /*\r\n        const c = Math.cos(renderLayer.rotation || 0),\r\n              s = Math.sin(renderLayer.rotation || 0),\r\n              translationMatrix = [\r\n                  1, 0, translation[0],\r\n                  0, 1, translation[1],\r\n                  0, 0, 1],\r\n              rotationMatrix = [\r\n                  c, -s, 0,\r\n                  s, c, 0,\r\n                  0, 0, 1\r\n              ],\r\n              scaleMatrix = [\r\n                  scale[0], 0, 0,\r\n                  0, scale[1], 0,\r\n                  0, 0, 1\r\n              ];\r\n        const matMultiply = utils.mat3Multiply(utils.mat3Multiply(translationMatrix, rotationMatrix), scaleMatrix);\r\n        for (let i = 0; i < renderLayerData.length; i++) {\r\n            renderLayerData[i][0] = utils.mat3MultiplyPosCoords(matMultiply, renderLayerData[i][0]);\r\n        }*/\r\n        //console.log(\"mat1: \", matMult1);\r\n        //console.log(\"mat2: \", matMult2);\r\n        /*\r\n        const x1y1 = utils.mat3MultiplyVector(matMultiply, [vecX1, vecY1, 1]),\r\n              x2y1 = utils.mat3MultiplyVector(matMultiply, [vecX2, vecY1, 1]),\r\n              x1y2 = utils.mat3MultiplyVector(matMultiply, [vecX1, vecY2, 1]),\r\n              x2y2 = utils.mat3MultiplyVector(matMultiply, [vecX2, vecY2, 1]);\r\n        */\r\n        const nextObject = this.getNextRenderObject(renderLayer, pageData);\r\n              \r\n        if (this._canMergeNextTileObject(renderLayer, nextObject)) {\r\n            if (this.#currentVertices === null) {\r\n                this.#currentVertices = renderLayerData[0][0];\r\n                this.#currentTextures = renderLayerData[0][1];\r\n                return Promise.resolve(0);\r\n            } else {\r\n                this.#currentVertices.push(...renderLayerData[0][0]);\r\n                this.#currentTextures.push(...renderLayerData[0][1]);\r\n                return Promise.resolve(0);\r\n            }\r\n        } else {\r\n            let verticesNumber = 0,\r\n                isTextureBind = false,\r\n                renderLayerDataLen = renderLayerData.length;\r\n            gl.enableVertexAttribArray(positionAttributeLocation);\r\n            gl.enableVertexAttribArray(texCoordLocation);\r\n\r\n            // set the resolution\r\n            gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n            //gl.uniform2f(translationLocation,translation[0], translation[1]);\r\n            //gl.uniform2f(scaleLocation, scale[0], scale[1]);\r\n            //gl.uniform1f(rotationRotation, rotation);\r\n\r\n            // MULTIPLE_IMAGE_TILESET drawing, no merging possible\r\n            if (renderLayerDataLen > 1) {\r\n                for (let i = 0; i < renderLayerDataLen; i++) {\r\n                    const data = renderLayerData[i],\r\n                        vectors = data[0],\r\n                        textures = data[1],\r\n                        image_name = data[2],\r\n                        image = data[3];\r\n                    // if layer use multiple tilesets\r\n                    // the issue is: when we add some layer data to the temp arrays, and then\r\n                    // process empty layer, it actually skips the draw with this check\r\n                    if (vectors.length > 0 && textures.length > 0) {\r\n                        // need to have additional draw call for each new texture added\r\n                        // probably it could be combined in one draw call if multiple textures \r\n                        // could be used in one draw call\r\n                        if (isTextureBind) {\r\n                            await this._render(verticesNumber, gl.TRIANGLES);\r\n                        }\r\n                        \r\n                        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vectors), gl.STATIC_DRAW);\r\n    \r\n                        //Tell the attribute how to get data out of positionBuffer\r\n                        const size = 2,\r\n                            type = gl.FLOAT, // data is 32bit floats\r\n                            normalize = false,\r\n                            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n                            offset = 0;  // verticesNumber * 4; // start of beginning of the buffer\r\n                        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n    \r\n                        //textures buffer\r\n                        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n                        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures), gl.STATIC_DRAW);\r\n    \r\n                        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);\r\n    \r\n                        let textureStorage = renderLayer._textureStorages[i];\r\n                        \r\n                        if (!textureStorage) {\r\n                            textureStorage = new ImageTempStorage(gl.createTexture(), i);\r\n                            renderLayer._setTextureStorage(i, textureStorage);\r\n                        }\r\n                        if (textureStorage._isTextureRecalculated === true) {\r\n                            this.#updateWebGlTexture(gl, textureStorage._texture, image, textureStorage._textureIndex);\r\n                            textureStorage._isTextureRecalculated = false;\r\n                        } else {\r\n                            //console.log(\"bind texture\");\r\n                            this.#bindTexture(gl, textureStorage._texture, textureStorage._textureIndex);\r\n                        }\r\n                        gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\r\n                        gl.blendFunc(gl[drawMask[0]], gl[drawMask[1]]);\r\n                        \r\n                        verticesNumber = vectors.length / 2;\r\n                        if (shapeMaskId) {\r\n                            gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);\r\n                        }\r\n                        isTextureBind = true;\r\n                    }\r\n                }\r\n            // Single image tileset draw, with merging\r\n            } else {\r\n                const data = renderLayerData[0],\r\n                    vectors = data[0],\r\n                    textures = data[1],\r\n                    image_name = data[2],\r\n                    image = data[3];\r\n                // if layer use multiple tilesets\r\n                // the issue is: when we add some layer data to the temp arrays, and then\r\n                // process empty layer, it actually skips the draw with this check\r\n                if (this.#currentVertices === null) {\r\n                    this.#currentVertices = vectors;\r\n                    this.#currentTextures = textures;\r\n                } else {\r\n                    this.#currentVertices.push(...vectors);\r\n                    this.#currentTextures.push(...textures);\r\n                }\r\n                \r\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentVertices), gl.STATIC_DRAW);\r\n\r\n                //Tell the attribute how to get data out of positionBuffer\r\n                const size = 2,\r\n                    type = gl.FLOAT, // data is 32bit floats\r\n                    normalize = false,\r\n                    stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n                    offset = 0;  // verticesNumber * 4; // start of beginning of the buffer\r\n                gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n                //textures buffer\r\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\r\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.#currentTextures), gl.STATIC_DRAW);\r\n\r\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);\r\n\r\n                let textureStorage = renderLayer._textureStorages[0];\r\n                \r\n                if (!textureStorage) {\r\n                    textureStorage = new ImageTempStorage(gl.createTexture(), 0);\r\n                    renderLayer._setTextureStorage(0, textureStorage);\r\n                }\r\n                if (textureStorage._isTextureRecalculated === true) {\r\n                    this.#updateWebGlTexture(gl, textureStorage._texture, image, textureStorage._textureIndex);\r\n                    textureStorage._isTextureRecalculated = false;\r\n                } else {\r\n                    //console.log(\"bind texture\");\r\n                    this.#bindTexture(gl, textureStorage._texture, textureStorage._textureIndex);\r\n                }\r\n                gl.uniform1i(u_imageLocation, textureStorage._textureIndex);\r\n                gl.blendFunc(gl[drawMask[0]], gl[drawMask[1]]);\r\n                \r\n                verticesNumber = this.#currentVertices.length / 2;\r\n                if (shapeMaskId) {\r\n                    gl.stencilFunc(gl.EQUAL, shapeMaskId, 0xFF);\r\n                }\r\n                this.#currentVertices = null;\r\n                this.#currentTextures = null;\r\n            }\r\n            \r\n            renderLayerData = null;\r\n            return this._render(verticesNumber, gl.TRIANGLES);\r\n        }\r\n    };\r\n\r\n    _drawPolygon(renderObject, pageData) {\r\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\r\n            x = renderObject.x - xOffset,\r\n            y = renderObject.y - yOffset,\r\n            rotation = renderObject.rotation || 0,\r\n            vertices = renderObject.vertices,\r\n            color =  this.#gameOptions.debug.collisionShapes.color;\r\n        const program = this.getProgram(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        const { u_translation: translationLocation,\r\n                u_rotation: rotationRotation,\r\n                u_scale: scaleLocation,\r\n                u_resolution: resolutionUniformLocation,\r\n                u_color: colorUniformLocation,\r\n                a_position: positionAttributeLocation,\r\n                u_fade_max: fadeMaxLocation,\r\n                u_fade_min: fadeMinLocation\r\n            } = this.getProgramVarLocations(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES),\r\n            gl = this.#gl;\r\n\r\n        let verticesNumber = 0;\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n        gl.uniform2f(translationLocation, x, y);\r\n        gl.uniform2f(scaleLocation, 1, 1);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        const triangles = this.#triangulatePolygon(vertices);\r\n\r\n        const polygonVerticesNum = triangles.length;\r\n        if (polygonVerticesNum % 3 !== 0) {\r\n            Warning(WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, \"polygon collision shapes vertices are not correct, skip drawing\");\r\n            return;\r\n        }\r\n        this.#bindPolygon(triangles);\r\n        verticesNumber += polygonVerticesNum / 2;\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(color);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n\r\n        this._render(verticesNumber, gl.TRIANGLES);\r\n    }\r\n\r\n    _bindLine = (renderObject, gl, pageData, program, vars) => {\r\n        const [ xOffset, yOffset ] = renderObject.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset,\r\n            x = renderObject.x - xOffset,\r\n            y = renderObject.y - yOffset,\r\n            scale = [1, 1],\r\n            rotation = renderObject.rotation,\r\n            { \r\n                u_translation: translationLocation,\r\n                u_rotation: rotationRotation,\r\n                u_scale: scaleLocation,\r\n                u_resolution: resolutionUniformLocation,\r\n                u_color: colorUniformLocation,\r\n                a_position: positionAttributeLocation,\r\n                u_fade_max: fadeMaxLocation,\r\n                u_fade_min: fadeMinLocation\r\n            } = vars,\r\n            coords = renderObject.vertices,\r\n            fillStyle = renderObject.bgColor,\r\n            fade_min = renderObject.fade_min,\r\n            fadeLen = renderObject.radius,\r\n            lineWidth = this.#gameOptions.debug.collisionShapes.width;\r\n        let verticesNumber = 0;\r\n\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n        gl.uniform2f(translationLocation, x, y);\r\n        gl.uniform2f(scaleLocation, 1, 1);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        gl.bufferData(\r\n            gl.ARRAY_BUFFER, \r\n            new Float32Array(coords),\r\n            gl.STATIC_DRAW);\r\n\r\n        verticesNumber += coords.length / 2;\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(fillStyle);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        gl.lineWidth(lineWidth);\r\n\r\n        return this._render(0, gl.LINES);\r\n    };\r\n    \r\n    _drawLines(linesArray, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {\r\n        const program = this.getProgram(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES);\r\n        const { u_translation: translationLocation,\r\n                u_rotation: rotationRotation,\r\n                u_scale: scaleLocation,\r\n                u_resolution: resolutionUniformLocation,\r\n                u_color: colorUniformLocation,\r\n                a_position: positionAttributeLocation,\r\n                u_fade_max: fadeMaxLocation,\r\n                u_fade_min: fadeMinLocation\r\n            } = this.getProgramVarLocations(CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES),\r\n            gl = this.#gl;\r\n\r\n        let verticesNumber = 0;\r\n        gl.useProgram(program);\r\n        // set the resolution\r\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\r\n        gl.uniform2f(scaleLocation, 1, 1);\r\n        gl.uniform1f(rotationRotation, rotation);\r\n        gl.uniform1f(fadeMinLocation, 0);\r\n\r\n        gl.enableVertexAttribArray(positionAttributeLocation);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\r\n\r\n        gl.bufferData(\r\n            gl.ARRAY_BUFFER, \r\n            (linesArray instanceof Float32Array ? linesArray : new Float32Array(linesArray)),\r\n            gl.STATIC_DRAW);\r\n\r\n        verticesNumber += linesArray.length / 2;\r\n        //Tell the attribute how to get data out of positionBuffer\r\n        const size = 2,\r\n            type = gl.FLOAT, // data is 32bit floats\r\n            normalize = false,\r\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\r\n            offset = 0; // start of beginning of the buffer\r\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const colorArray = this.#rgbaToArray(color);\r\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\r\n        \r\n        gl.lineWidth(lineWidth);\r\n        \r\n        this._render(verticesNumber, gl.LINES);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * @param {string} objectType - object name registered to DrawObjectFactory | object type registered to DrawObjectFactory\r\n     * @param {function(renderObject, gl, pageData, program, vars):Promise<any>} objectRenderMethod - should be promise based returns vertices number and draw program\r\n     * @param {string=} objectWebGlDrawProgram \r\n     */\r\n    _registerObjectRender(objectType, objectRenderMethod, objectWebGlDrawProgram) {\r\n        this.#registeredRenderObjects.set(objectType, {method: objectRenderMethod, webglProgramName: objectWebGlDrawProgram});\r\n    }\r\n\r\n    _drawRenderObject(renderObject, pageData) {\r\n        const name = renderObject.constructor.name,\r\n            registeredRenderObject = this.#registeredRenderObjects.get(name) || this.#registeredRenderObjects.get(renderObject.type);\r\n        if (registeredRenderObject) {\r\n            const name = registeredRenderObject.webglProgramName,\r\n                program = name ? this.getProgram(name) : null,\r\n                vars = name ? this.getProgramVarLocations(name) : null;\r\n\r\n            return registeredRenderObject.method(renderObject, this.#gl, pageData, program, vars);\r\n        } else {\r\n            console.warn(\"no registered draw object method for \" + name + \" skip draw\");\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n    /**\r\n     * \r\n     * @param {DrawTiledLayer} renderLayer \r\n     * @param {GameStageData} pageData\r\n     * @returns {Promise<Array<Array>>}\r\n     */\r\n    #prepareRenderLayer(renderLayer, pageData) {\r\n        const INDEX_TOP_LINE = 0,\r\n            INDEX_RIGHT_LINE = 1,\r\n            INDEX_BOTTOM_LINE = 2,\r\n            INDEX_LEFT_LINE = 3;\r\n\r\n        const INDEX_X1 = 0,\r\n            INDEX_Y1 = 1,\r\n            INDEX_X2 = 2,\r\n            INDEX_Y2 = 3;\r\n        return new Promise((resolve, reject) => {\r\n            const tilemap = renderLayer.tilemap,\r\n                tilesets = renderLayer.tilesets,\r\n                tilesetImages = renderLayer.tilesetImages,\r\n                layerData = renderLayer.layerData,\r\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                tilewidth = dtwidth,\r\n                tileheight = dtheight,\r\n                [ canvasW, canvasH ] = pageData.canvasDimensions,\r\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0, 0] : pageData.worldOffset,\r\n                collisionShapesCalculations = this.#gameOptions.render.collisionShapes.realtimeCalculations,\r\n                setCollisionShapes = renderLayer.setCollisionShapes,\r\n                tileImagesData = [];\r\n\r\n            if (!layerData) {\r\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\r\n                reject();\r\n            }\r\n\r\n            if (this.#gameOptions.render.collisionShapes.mapCollisionShapesEnabled) {\r\n                pageData._setMapCollisionShapes();\r\n            }\r\n            \r\n            for (let i = 0; i < tilesets.length; i++) {\r\n                \r\n                const tilesetData = tilesets[i],\r\n                    firstgid = tilesets[i].firstgid,\r\n                    nextTileset = tilesets[i + 1],\r\n                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions\r\n                    tilesetwidth = tilesetData.tilewidth,\r\n                    tilesetheight = tilesetData.tileheight,\r\n                    tileoffsetX = tilesetData.tileoffset ? tilesetData.tileoffset.x : 0,\r\n                    tileoffsetY = tilesetData.tileoffset ? tilesetData.tileoffset.y : 0,\r\n                    atlasImage = tilesetImages[i],\r\n                    //atlasWidth = atlasImage.width,\r\n                    //atlasHeight = atlasImage.height,\r\n                    atlasWidth = tilesetData.imagewidth,\r\n                    atlasHeight = tilesetData.imageheight,\r\n                    //atlasRows = atlasHeight / tileheight,\r\n                    atlasColumns = tilesetData.columns,\r\n                    layerCols = layerData.width,\r\n                    layerRows = layerData.height,\r\n                    worldW = tilewidth * layerCols,\r\n                    worldH = tileheight * layerRows,\r\n                    moduloTop = yOffset % tileheight,\r\n                    moduleLeft = xOffset % tilewidth,\r\n                    skipRowsTop = yOffset !== 0 ? Math.floor(yOffset / tileheight) : 0,\r\n                    skipColsLeft = xOffset !== 0 ? Math.floor(xOffset / tilewidth) : 0,\r\n                    // sometimes canvasW/H may be bigger than world itself\r\n                    screenRows = worldH > canvasH ? Math.ceil(canvasH / tileheight) + 1 : layerRows,\r\n                    screenCols = worldW > canvasW ? Math.ceil(canvasW / tilewidth) + 1 : layerCols,\r\n                    screenCells = screenRows * screenCols,\r\n                    skipColsRight = layerCols - screenCols - skipColsLeft,\r\n                    cellSpacing = typeof tilesetData.spacing === \"number\" ? tilesetData.spacing : 0,\r\n                    cellMargin = typeof tilesetData.margin === \"number\" ? tilesetData.margin : 0,\r\n                    hasAnimations = tilesetData._hasAnimations;\r\n                    //console.log(\"non empty: \", layerData.nonEmptyCells);\r\n                    // additional property which is set in DrawTiledLayer\r\n                const hasCollisionShapes = tilesetData._hasCollisionShapes,\r\n                    tilesetCollisionShapes = tilesetData._collisionShapes,\r\n                    layerTilesetData = tilesets[i]._temp;\r\n\r\n                if (layerTilesetData.cells !== screenCells) {\r\n                    layerTilesetData._initiateStorageData(screenCells);\r\n                }\r\n                let v = layerTilesetData.vectors,\r\n                    t = layerTilesetData.textures,\r\n                    filledSize = 0;\r\n                    \r\n                //v.fill(0);\r\n                //t.fill(0);\r\n                v = [];\r\n                t = [];\r\n                let collisionShapesRowsIndexes = layerTilesetData._cTempIndexes;\r\n                const fullRowCellsNum = screenCols * 4;\r\n                \r\n                let mapIndex = skipRowsTop * layerCols;\r\n                for (let row = 0; row < screenRows; row++) {\r\n                    mapIndex += skipColsLeft;\r\n                    for (let col = 0; col < screenCols; col++) {\r\n                        let tile = layerData.data[mapIndex];\r\n\r\n                        if ((tile >= firstgid) && (tile < nextgid)) {\r\n                            const mapPosX = col * dtwidth - moduleLeft + tileoffsetX,\r\n                                // this fix is used to draw items with height different that the actual tilecell height\r\n                                posYFix = tilesetheight - dtheight,\r\n                                mapPosY = row * dtheight - posYFix - moduloTop + tileoffsetY;\r\n\r\n                            // actual tile index\r\n                            tile -= firstgid;\r\n                            // switch if animations are set\r\n                            if (hasAnimations) {\r\n                                const activeTile = tilesetData._animations.get(tile);\r\n                                if (typeof activeTile !== \"undefined\") {\r\n                                    tile = activeTile;\r\n                                }   \r\n                            }\r\n\r\n                            // calculate map position and atlas position\r\n                            const colNum = tile % atlasColumns,\r\n                                rowNum = Math.floor(tile / atlasColumns),\r\n                                atlasPosX = colNum * tilesetwidth + (colNum * cellSpacing) + cellMargin,\r\n                                atlasPosY = rowNum * tilesetheight + (rowNum * cellSpacing) + cellMargin,\r\n                                vecX1 = mapPosX,\r\n                                vecY1 = mapPosY,\r\n                                vecX2 = mapPosX + tilesetwidth,\r\n                                vecY2 = mapPosY + tilesetheight,\r\n                                texX1 = (1 / atlasWidth) * atlasPosX,\r\n                                texY1 = (1 / atlasHeight) * atlasPosY,\r\n                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),\r\n                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);\r\n\r\n                            // 0 vecX1\r\n                            v[filledSize] = vecX1;\r\n                            t[filledSize] = texX1;\r\n\r\n                            // 1 vecY1\r\n                            filledSize++;\r\n                            v[filledSize] = vecY1;\r\n                            t[filledSize] = texY1;\r\n                            \r\n                            // 2 vecX2\r\n                            filledSize++;\r\n                            v[filledSize] = vecX2;\r\n                            t[filledSize] = texX2;\r\n\r\n                            // 3 vecY1\r\n                            filledSize++;\r\n                            v[filledSize] = vecY1;\r\n                            t[filledSize] = texY1;\r\n\r\n                            // 4 vecX1\r\n                            filledSize++;\r\n                            v[filledSize] = vecX1;\r\n                            t[filledSize] = texX1;\r\n\r\n                            // 5 vecY2\r\n                            filledSize++;\r\n                            v[filledSize] = vecY2;\r\n                            t[filledSize] = texY2;\r\n\r\n                            // 6 vecX1\r\n                            filledSize++;\r\n                            v[filledSize] = vecX1;\r\n                            t[filledSize] = texX1;\r\n\r\n                            // 7 vecY2\r\n                            filledSize++;\r\n                            v[filledSize] = vecY2;\r\n                            t[filledSize] = texY2;\r\n\r\n                            // 8 vecX2\r\n                            filledSize++;\r\n                            v[filledSize] = vecX2;\r\n                            t[filledSize] = texX2;\r\n\r\n                            // 9 vecY1\r\n                            filledSize++;\r\n                            v[filledSize] = vecY1;\r\n                            t[filledSize] = texY1;\r\n\r\n                            // 10 vecX2, \r\n                            filledSize++;\r\n                            v[filledSize] = vecX2;\r\n                            t[filledSize] = texX2;\r\n\r\n                            // 11 vecY2\r\n                            filledSize++;\r\n                            v[filledSize] = vecY2;\r\n                            t[filledSize] = texY2;\r\n\r\n                            filledSize++;\r\n                        \r\n                            if (setCollisionShapes) {\r\n                                // if collision shape is set in tilesetData\r\n                                let isCollisionShapesPreset = false;\r\n                                if (hasCollisionShapes && tilesetCollisionShapes.size > 0) {\r\n                                    const tilesetCollisionShape = tilesetCollisionShapes.get(tile);\r\n                                    if (tilesetCollisionShape) {\r\n                                        isCollisionShapesPreset = true;\r\n                                        const objectGroup = tilesetCollisionShape,\r\n                                            objects = objectGroup.objects;\r\n                                            \r\n                                        objects.forEach((object) => {\r\n                                            const baseX = mapPosX + object.x, \r\n                                                baseY = mapPosY + object.y,\r\n                                                rotation = object.rotation;\r\n                                            if (rotation !== 0) {\r\n                                                Warning(\"tilesetData.tiles.rotation property is not supported yet\");\r\n                                            }\r\n                                            if (object.polygon) {\r\n                                                object.polygon.forEach(\r\n                                                    (point, idx) => {\r\n                                                        const next = object.polygon[idx + 1];\r\n                                                        if (next) {\r\n                                                            pageData._addCollisionShapeLine(point.x + baseX, point.y + baseY, next.x + baseX, next.y + baseY);\r\n                                                        } else {\r\n                                                            // last point -> link to the first\r\n                                                            const first = object.polygon[0];\r\n                                                            pageData._addCollisionShapeLine(point.x + baseX, point.y + baseY, first.x + baseX, first.y + baseY);\r\n                                                        }\r\n                                                    });\r\n                                            } else if (object.point) {\r\n                                                // x/y coordinate\r\n                                                pageData._addPointCollisionShape(baseX, baseY);\r\n                                            } else if (object.ellipse) {\r\n                                                const radX = object.width / 2,\r\n                                                    radY = object.height / 2;\r\n                                                    \r\n                                                pageData._addEllipseCollisionShape(baseX + radX, baseY + radY, radX, radY);\r\n                                            } else {\r\n                                                // object is rect\r\n                                                const width = object.width,\r\n                                                    height = object.height,\r\n                                                    x2 = width + baseX,\r\n                                                    y2 = height + baseY;\r\n\r\n                                                //collisionShapes.push([baseX, baseY, x2, baseY]);\r\n                                                pageData._addCollisionShapeLine(baseX, baseY, x2, baseY);\r\n\r\n                                                //collisionShapes.push([x2, baseY, x2, y2]);\r\n                                                pageData._addCollisionShapeLine(x2, baseY, x2, y2);\r\n\r\n                                                //collisionShapes.push([x2, y2, baseX, y2]);\r\n                                                pageData._addCollisionShapeLine(x2, y2, baseX, y2);\r\n\r\n                                                //collisionShapes.push([baseX, y2, baseX, baseY]);\r\n                                                pageData._addCollisionShapeLine(baseX, y2, baseX, baseY);\r\n                                            }\r\n                                        });\r\n                                    }\r\n\r\n                                // extract rect collsiion shape for the whole tile\r\n                                }\r\n                                if (isCollisionShapesPreset === false) {\r\n                                    const collisionShapes = pageData.getRawCollisionShapes();\r\n\r\n                                    let rightLine = [ mapPosX + tilesetwidth, mapPosY, mapPosX + tilesetwidth, mapPosY + tilesetheight ],\r\n                                        bottomLine = [ mapPosX + tilesetwidth, mapPosY + tilesetheight, mapPosX, mapPosY + tilesetheight ],\r\n                                        topLine = [ mapPosX, mapPosY, mapPosX + tilesetwidth, mapPosY],\r\n                                        leftLine = [ mapPosX, mapPosY + tilesetheight, mapPosX, mapPosY ];\r\n                                    \r\n                                    // top cell7\r\n                                    if (row !== 0) {\r\n                                        const topCellFirstIndex =  (row - 1) * fullRowCellsNum + (col * 4),\r\n                                            bottomTopLeftFirstIndex = collisionShapesRowsIndexes[topCellFirstIndex + INDEX_BOTTOM_LINE];\r\n                                        if (bottomTopLeftFirstIndex) {\r\n                                            //remove double lines from top\r\n                                            const bottomTopCellX1 = collisionShapes[bottomTopLeftFirstIndex];\r\n                                            if (bottomTopCellX1) {\r\n                                                const bottomTopCellY1 = collisionShapes[bottomTopLeftFirstIndex + INDEX_Y1],\r\n                                                    bottomTopCellX2 = collisionShapes[bottomTopLeftFirstIndex + INDEX_X2],\r\n                                                    bottomTopCellY2 = collisionShapes[bottomTopLeftFirstIndex + INDEX_Y2],\r\n                                                    topX1 = topLine[INDEX_X1],\r\n                                                    topY1 = topLine[INDEX_Y1],\r\n                                                    topX2 = topLine[INDEX_X2],\r\n                                                    topY2 = topLine[INDEX_Y2];\r\n                                                \r\n                                                if (topX1 === bottomTopCellX2 && topY1 === bottomTopCellY2 &&\r\n                                                    topX2 === bottomTopCellX1 && topY2 === bottomTopCellY1) {\r\n                                                    pageData._removeCollisionShapeLine(bottomTopLeftFirstIndex);\r\n                                                    topLine = undefined;\r\n                                                }\r\n                                            }\r\n\r\n                                            // merge line from top right\r\n                                            const rightTopRightFirstIndex = collisionShapesRowsIndexes[ topCellFirstIndex + INDEX_RIGHT_LINE],\r\n                                                rightTopCellX1 = collisionShapes[rightTopRightFirstIndex];\r\n                                            if (rightTopCellX1) {\r\n                                                const rightTopCellY1 = collisionShapes[rightTopRightFirstIndex + INDEX_Y1],\r\n                                                    rightTopCellX2 = collisionShapes[rightTopRightFirstIndex + INDEX_X2],\r\n                                                    rightX1 = collisionShapes[rightTopRightFirstIndex + INDEX_X1],\r\n                                                    rightX2 = collisionShapes[rightTopRightFirstIndex + INDEX_X2];\r\n                                                if (rightTopCellX1 === rightX2 && rightTopCellX2 === rightX1) {\r\n                                                    pageData._removeCollisionShapeLine(rightTopRightFirstIndex);\r\n                                                    rightLine[INDEX_X1] = rightTopCellX1;\r\n                                                    rightLine[INDEX_Y1] = rightTopCellY1;\r\n                                                }\r\n                                            }\r\n                                            // merge line from top left\r\n                                            const leftTopRightFirstIndex =  collisionShapesRowsIndexes[topCellFirstIndex + INDEX_LEFT_LINE],\r\n                                                leftTopCellX1 = collisionShapes[leftTopRightFirstIndex];\r\n                                            if (leftTopCellX1) {\r\n                                                const leftTopCellX2 = collisionShapes[leftTopRightFirstIndex + INDEX_X2],\r\n                                                    leftTopCellY2 = collisionShapes[leftTopRightFirstIndex + INDEX_Y2],\r\n                                                    leftX1 = leftLine[INDEX_X1],\r\n                                                    leftX2 = leftLine[INDEX_X2];\r\n                                                if (leftTopCellX1 === leftX2 && leftTopCellX2 === leftX1) {\r\n                                                    pageData._removeCollisionShapeLine(leftTopRightFirstIndex);\r\n                                                    leftLine[INDEX_X2] = leftTopCellX2;\r\n                                                    leftLine[INDEX_Y2] = leftTopCellY2;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    // leftCell\r\n                                    if (col !== 0) {\r\n                                        \r\n                                        const leftCell = row * fullRowCellsNum + ((col - 1) * 4),\r\n                                            topLeftFirstCellIndex = collisionShapesRowsIndexes[leftCell];\r\n                                        if (topLeftFirstCellIndex) {\r\n\r\n                                            //remove double lines from left\r\n                                            const rightLeftCellIndex = collisionShapesRowsIndexes[leftCell + INDEX_RIGHT_LINE],\r\n                                                rightLeftX1 = collisionShapes[rightLeftCellIndex],\r\n                                                rightLeftCellX1 = rightLeftX1,\r\n                                                rightLeftCellY1 = collisionShapes[rightLeftCellIndex + INDEX_Y1],\r\n                                                rightLeftCellX2 = collisionShapes[rightLeftCellIndex + INDEX_X2],\r\n                                                rightLeftCellY2 = collisionShapes[rightLeftCellIndex + INDEX_Y2],\r\n                                                leftX1 = leftLine[INDEX_X1],\r\n                                                leftY1 = leftLine[INDEX_Y1],\r\n                                                leftX2 = leftLine[INDEX_X2],\r\n                                                leftY2 = leftLine[INDEX_Y2];\r\n\r\n                                            if (leftX1 === rightLeftCellX2 && leftY1 === rightLeftCellY2 &&\r\n                                                leftX2 === rightLeftCellX1 && leftY2 === rightLeftCellY1) {\r\n                                                pageData._removeCollisionShapeLine(rightLeftCellIndex);\r\n                                                leftLine = undefined;\r\n                                            }\r\n\r\n                                            //merge long lines from left top\r\n                                            const topLeftCellX1 = collisionShapes[topLeftFirstCellIndex];\r\n                                            if (topLeftCellX1 && topLine) {\r\n                                                const topLeftCellY1 = collisionShapes[topLeftFirstCellIndex + INDEX_Y1],\r\n                                                    topLeftCellY2 = collisionShapes[topLeftFirstCellIndex + INDEX_Y2],\r\n                                                    topY1 = topLine[INDEX_Y1],\r\n                                                    topY2 = topLine[INDEX_Y2];\r\n                                                if (topLeftCellY1 === topY2 && topLeftCellY2 === topY1 ) {\r\n                                                    pageData._removeCollisionShapeLine(topLeftFirstCellIndex);\r\n                                                    topLine[INDEX_X1] = topLeftCellX1;\r\n                                                    topLine[INDEX_Y1] = topLeftCellY1;\r\n                                                }\r\n                                            }\r\n\r\n                                            // merge long lines from left bottom\r\n                                            const bottomLeftFirstCellIndex = collisionShapesRowsIndexes[leftCell + INDEX_BOTTOM_LINE],\r\n                                                bottomLeftCellX1 = collisionShapes[bottomLeftFirstCellIndex];\r\n                                            if (bottomLeftCellX1) {\r\n                                                const bottomLeftCellY1 = collisionShapes[bottomLeftFirstCellIndex + INDEX_Y1],\r\n                                                    bottomLeftCellX2 = collisionShapes[bottomLeftFirstCellIndex + INDEX_X2],\r\n                                                    bottomLeftCellY2 = collisionShapes[bottomLeftFirstCellIndex + INDEX_Y2],\r\n                                                    bottomY1 = bottomLine[INDEX_Y1],\r\n                                                    bottomY2 = bottomLine[INDEX_Y2];\r\n                                                if (bottomLeftCellY1 === bottomY2 && bottomLeftCellY2 === bottomY1 ) {\r\n                                                    pageData._removeCollisionShapeLine(bottomLeftFirstCellIndex);\r\n                                                    //opposite direction\r\n                                                    bottomLine[INDEX_X2] = bottomLeftCellX2;\r\n                                                    bottomLine[INDEX_Y2] = bottomLeftCellY2;\r\n                                                }\r\n                                            }\r\n\r\n                                        }\r\n                                    }\r\n                                    const currentCellIndex = row * fullRowCellsNum + (col * 4);\r\n                                    if (topLine) {\r\n                                        pageData._addCollisionShapeLine(topLine[0], topLine[1], topLine[2], topLine[3]);\r\n                                        collisionShapesRowsIndexes[currentCellIndex + INDEX_TOP_LINE] = pageData.collisionShapesLen - 4;\r\n                                    }\r\n                                    pageData._addCollisionShapeLine(rightLine[0], rightLine[1], rightLine[2], rightLine[3]);\r\n                                    collisionShapesRowsIndexes[currentCellIndex + INDEX_RIGHT_LINE] = pageData.collisionShapesLen - 4;\r\n                                    pageData._addCollisionShapeLine(bottomLine[0], bottomLine[1], bottomLine[2], bottomLine[3]);\r\n                                    collisionShapesRowsIndexes[currentCellIndex + INDEX_BOTTOM_LINE] = pageData.collisionShapesLen - 4;\r\n                                    if (leftLine) {\r\n                                        pageData._addCollisionShapeLine(leftLine[0], leftLine[1], leftLine[2], leftLine[3]);\r\n                                        collisionShapesRowsIndexes[currentCellIndex + INDEX_LEFT_LINE] = pageData.collisionShapesLen - 4;\r\n                                    }\r\n                                    \r\n                                }\r\n                            }\r\n                        }\r\n                        mapIndex++;\r\n                    }\r\n                    mapIndex += skipColsRight;\r\n                }\r\n                //console.log(collisionShapesRowsIndexes);\r\n                //this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tilesetData.name, renderLayer._maskId);\r\n                tileImagesData.push([v, t, tilesetData.name, atlasImage]);\r\n                //cleanup\r\n                collisionShapesRowsIndexes.fill(0);\r\n            }\r\n            \r\n            resolve(tileImagesData);\r\n        });\r\n    }\r\n\r\n    #prepareRenderLayerOld(renderLayer, pageData) {\r\n        return new Promise((resolve, reject) => {\r\n            const tilemap = renderLayer.tilemap,\r\n                tilesets = renderLayer.tilesets,\r\n                tilesetImages = renderLayer.tilesetImages,\r\n                layerData = renderLayer.layerData,\r\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset;\r\n            \r\n            let tileImagesData = [];\r\n            if (!layerData) {\r\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\r\n                reject();\r\n            }\r\n\r\n            if (this.#gameOptions.render.collisionShapes.mapCollisionShapesEnabled) {\r\n                pageData._setMapCollisionShapes();\r\n            }\r\n\r\n            for (let i = 0; i <= tilesets.length - 1; i++) {\r\n                const tilesetData = tilesets[i],\r\n                    firstgid = tilesets[i].firstgid,\r\n                    nextTileset = tilesets[i + 1],\r\n                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions\r\n                    //tilesetImages = this.iLoader.getTilesetImageArray(tilesetData.name),\r\n                    tilesetwidth = tilesetData.tilewidth,\r\n                    tilesetheight = tilesetData.tileheight,\r\n                    //atlasRows = tilesetData.imageheight / tileheight,\r\n                    //atlasColumns = tilesetData.imagewidth / tilewidth,\r\n                    atlasColumns = tilesetData.columns,\r\n                    layerCols = layerData.width,\r\n                    layerRows = layerData.height,\r\n                    atlasImage = tilesetImages[i],\r\n                    atlasWidth = tilesetData.imagewidth,\r\n                    atlasHeight = tilesetData.imageheight,\r\n                    cellSpacing = typeof tilesetData.spacing === \"number\" ? tilesetData.spacing : 0,\r\n                    cellMargin = typeof tilesetData.margin === \"number\" ? tilesetData.margin : 0,\r\n                    layerTilesetData = tilesets[i]._temp;\r\n                \r\n                let mapIndex = 0,\r\n                    v = layerTilesetData.vectors,\r\n                    t = layerTilesetData.textures,\r\n                    filledSize = 0;\r\n                \r\n                //v.fill(0);\r\n                //t.fill(0);\r\n                v = [];\r\n                t = [];\r\n                for (let row = 0; row < layerRows; row++) {\r\n                    for (let col = 0; col < layerCols; col++) {\r\n                        let tile = layerData.data[mapIndex];\r\n                        \r\n                        if (tile >= firstgid && (tile < nextgid)) {\r\n\r\n                            tile -= firstgid;\r\n                            const colNum = tile % atlasColumns,\r\n                                rowNum = Math.floor(tile / atlasColumns),\r\n                                atlasPosX = colNum * tilesetwidth + (colNum * cellSpacing) + cellMargin,\r\n                                atlasPosY = rowNum * tilesetheight + (rowNum * cellSpacing) + cellMargin,\r\n                                vecX1 = col * dtwidth - xOffset,\r\n                                vecY1 = row * dtheight - yOffset,\r\n                                vecX2 = vecX1 + tilesetwidth,\r\n                                vecY2 = vecY1 + tilesetheight,\r\n                                texX1 = 1 / atlasWidth * atlasPosX,\r\n                                texY1 = 1 / atlasHeight * atlasPosY,\r\n                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),\r\n                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);\r\n                             \r\n                            // 0 vecX1\r\n                            v[filledSize] = vecX1;\r\n                            t[filledSize] = texX1;\r\n\r\n                            // 1 vecY1\r\n                            filledSize++;\r\n                            v[filledSize] = vecY1;\r\n                            t[filledSize] = texY1;\r\n                            \r\n                            // 2 vecX2\r\n                            filledSize++;\r\n                            v[filledSize] = vecX2;\r\n                            t[filledSize] = texX2;\r\n\r\n                            // 3 vecY1\r\n                            filledSize++;\r\n                            v[filledSize] = vecY1;\r\n                            t[filledSize] = texY1;\r\n\r\n                            // 4 vecX1\r\n                            filledSize++;\r\n                            v[filledSize] = vecX1;\r\n                            t[filledSize] = texX1;\r\n\r\n                            // 5 vecY2\r\n                            filledSize++;\r\n                            v[filledSize] = vecY2;\r\n                            t[filledSize] = texY2;\r\n\r\n                            // 6 vecX1\r\n                            filledSize++;\r\n                            v[filledSize] = vecX1;\r\n                            t[filledSize] = texX1;\r\n\r\n                            // 7 vecY2\r\n                            filledSize++;\r\n                            v[filledSize] = vecY2;\r\n                            t[filledSize] = texY2;\r\n\r\n                            // 8 vecX2\r\n                            filledSize++;\r\n                            v[filledSize] = vecX2;\r\n                            t[filledSize] = texX2;\r\n\r\n                            // 9 vecY1\r\n                            filledSize++;\r\n                            v[filledSize] = vecY1;\r\n                            t[filledSize] = texY1;\r\n\r\n                            // 10 vecX2, \r\n                            filledSize++;\r\n                            v[filledSize] = vecX2;\r\n                            t[filledSize] = texX2;\r\n\r\n                            // 11 vecY2\r\n                            filledSize++;\r\n                            v[filledSize] = vecY2;\r\n                            t[filledSize] = texY2;\r\n\r\n                            filledSize++;\r\n                            \r\n                        }\r\n                        mapIndex++;\r\n                    }\r\n                }\r\n                tileImagesData.push([v, t, tilesetData.name, atlasImage]);\r\n            }\r\n            resolve(tileImagesData);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {DrawTiledLayer} renderLayer \r\n     * @param {GameStageData} pageData\r\n     * @returns {Promise<Array<any>}\r\n     */\r\n    #prepareRenderLayerWM = (renderLayer, pageData) => {\r\n        return new Promise((resolve, reject) => {\r\n            const tilemap = renderLayer.tilemap,\r\n                tilesets = renderLayer.tilesets,\r\n                tilesetImages = renderLayer.tilesetImages,\r\n                layerData = renderLayer.layerData,\r\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\r\n                tilewidth = dtwidth,\r\n                tileheight = dtheight,\r\n                offsetDataItemsFullNum = layerData.data.length,\r\n                offsetDataItemsFilteredNum = layerData.data.filter((item) => item !== 0).length,\r\n                setCollisionShapes = false, //renderLayer.setCollisionShapes,\r\n                [ settingsWorldWidth, settingsWorldHeight ] = pageData.worldDimensions,\r\n                //[ canvasW, canvasH ] = this.stageData.drawDimensions,\r\n                [ xOffset, yOffset ] = renderLayer.isOffsetTurnedOff === true ? [0,0] : pageData.worldOffset;\r\n            const tileImagesData = [];\r\n            // clear data\r\n            // this.layerDataFloat32.fill(0);\r\n            // set data for webgl processing\r\n            this.layerDataFloat32.set(layerData.data);\r\n            if (!layerData) {\r\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\r\n                reject();\r\n            }\r\n\r\n            if (this.#gameOptions.render.collisionShapes.mapCollisionShapesEnabled) {\r\n                pageData._setMapCollisionShapes();\r\n            }\r\n            \r\n            for (let i = 0; i < tilesets.length; i++) {\r\n                const tilesetData = tilesets[i],\r\n                    firstgid = tilesets[i].firstgid,\r\n                    nextTileset = tilesets[i + 1],\r\n                    nextgid = nextTileset ? nextTileset.firstgid : 1_000_000_000, // a workaround to avoid multiple conditions\r\n                    //tilesetImages = this.iLoader.getTilesetImageArray(tilesetData.name),\r\n                    tilesetwidth = tilesetData.tilewidth,\r\n                    tilesetheight = tilesetData.tileheight,\r\n                    //atlasRows = tilesetData.imageheight / tileheight,\r\n                    atlasColumns = tilesetData.columns,\r\n                    layerCols = layerData.width,\r\n                    layerRows = layerData.height,\r\n                    //visibleCols = Math.ceil(canvasW / tilewidth),\r\n                    //visibleRows = Math.ceil(canvasH / tileheight),\r\n                    //offsetCols = layerCols - visibleCols,\r\n                    //offsetRows = layerRows - visibleRows,\r\n                    worldW = tilewidth * layerCols,\r\n                    worldH = tileheight * layerRows,\r\n                    atlasImage = tilesetImages[i],\r\n                    atlasWidth = tilesetData.imagewidth,\r\n                    atlasHeight = tilesetData.imageheight,\r\n                    items = layerRows * layerCols,\r\n                    dataCellSizeBytes = 4,\r\n                    vectorCoordsItemsNum = 12,\r\n                    texturesCoordsItemsNum = 12,\r\n                    vectorDataItemsNum = offsetDataItemsFilteredNum * vectorCoordsItemsNum,\r\n                    texturesDataItemsNum = offsetDataItemsFilteredNum * texturesCoordsItemsNum,\r\n                    cellSpacing = typeof tilesetData.spacing === \"number\" ? tilesetData.spacing : 0,\r\n                    cellMargin = typeof tilesetData.margin === \"number\" ? tilesetData.margin : 0;\r\n                \r\n                const itemsProcessed = this.calculateBufferData(dataCellSizeBytes, offsetDataItemsFullNum, vectorDataItemsNum, layerRows, layerCols, dtwidth, dtheight, tilesetwidth, tilesetheight, atlasColumns, atlasWidth, atlasHeight, xOffset, yOffset, firstgid, nextgid, cellSpacing, setCollisionShapes);\r\n                \r\n                const verticesBufferData = itemsProcessed > 0 ? this.layerDataFloat32.slice(offsetDataItemsFullNum, vectorDataItemsNum + offsetDataItemsFullNum) : [],\r\n                    texturesBufferData = itemsProcessed > 0 ? this.layerDataFloat32.slice(vectorDataItemsNum + offsetDataItemsFullNum, vectorDataItemsNum + texturesDataItemsNum + offsetDataItemsFullNum) : [];\r\n                    \r\n                tileImagesData.push([Array.from(verticesBufferData), Array.from(texturesBufferData), tilesetData.name, atlasImage]);\r\n            }\r\n            resolve(tileImagesData);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * \r\n     * @param {string} rgbaColor \r\n     * @returns {number[]}\r\n     */\r\n    #rgbaToArray (rgbaColor) {\r\n        return rgbaColor.replace(\"rgba(\", \"\").replace(\")\", \"\").split(\",\").map((/** @param {string} */item) => Number(item.trim()));\r\n    }\r\n\r\n    #triangulatePolygon(vertices) {\r\n        const triangulatedPolygon = new Float32Array(vertices.length * vertices.length),\r\n            pointer = 0;\r\n            \r\n        const [triangulated, len] = this.#triangulate(vertices, triangulatedPolygon, pointer);\r\n        \r\n        const sliced = triangulated.slice(0, len);\r\n        \r\n        return sliced;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Array<Array<number>>} polygonVertices \r\n     * @param {Float32Array} triangulatedPolygon \r\n     * @returns {Array}\r\n     */\r\n    #triangulate (polygonVertices, triangulatedPolygon, pointer) {\r\n        const len = polygonVertices.length,\r\n            vectorsCS = (a, b, c) => crossProduct({x:c[0] - a[0], y: c[1] - a[1]}, {x:b[0] - a[0], y: b[1] - a[1]});\r\n\r\n        if (len <= 3) {\r\n            polygonVertices.forEach(vertex => {\r\n                triangulatedPolygon[pointer] = vertex[0];\r\n                pointer++;\r\n                triangulatedPolygon[pointer] = vertex[1];\r\n                pointer++;\r\n            });\r\n            return [triangulatedPolygon, pointer];\r\n        }\r\n        const verticesSortedByY = [...polygonVertices].sort((curr, next) => next[1] - curr[1]);\r\n        const topVertexIndex = polygonVertices.indexOf(verticesSortedByY[0]),\r\n            startVertexIndex = topVertexIndex !== len - 1 ? topVertexIndex + 1 : 0;\r\n        \r\n        let processedVertices = polygonVertices,\r\n            processedVerticesLen = processedVertices.length,\r\n            skipCount = 0,\r\n            i = startVertexIndex;\r\n        \r\n        while(processedVertices.length > 2) {\r\n            // if overflowed, start from beginning\r\n            const currLen = processedVertices.length;\r\n            if (i >= currLen) {\r\n                i -= currLen;\r\n            }\r\n    \r\n            const prevVertex = i === 0 ? processedVertices[currLen - 1] : processedVertices[i - 1],\r\n                currentVertex = processedVertices[i],\r\n                nextVertex = currLen === i + 1 ? processedVertices[0] : processedVertices[i + 1];\r\n    \r\n            \r\n            const cs = vectorsCS(prevVertex, currentVertex, nextVertex);\r\n    \r\n            if (cs < 0) {\r\n                triangulatedPolygon[pointer] = prevVertex[0];\r\n                pointer++;\r\n                triangulatedPolygon[pointer] = prevVertex[1];\r\n                pointer++;\r\n                triangulatedPolygon[pointer] = currentVertex[0];\r\n                pointer++;\r\n                triangulatedPolygon[pointer] = currentVertex[1];\r\n                pointer++;\r\n                triangulatedPolygon[pointer] = nextVertex[0];\r\n                pointer++;\r\n                triangulatedPolygon[pointer] = nextVertex[1];\r\n                pointer++;\r\n                processedVertices = processedVertices.filter((val, index) => index !== i);\r\n            } else {\r\n                skipCount += 1;\r\n                if (skipCount > processedVerticesLen) {\r\n                    // sometimes fails\r\n                    Warning(WARNING_CODES.TRIANGULATE_ISSUE, \"Can't extract all triangles vertices.\");\r\n                    return [triangulatedPolygon, pointer];\r\n                }\r\n                i++;\r\n            }\r\n            // if (cs < 0): it's jumping over next vertex, maybe not a good solution? Moving up\r\n            // i++;\r\n        }\r\n        \r\n        return [triangulatedPolygon, pointer];\r\n    }\r\n\r\n    #bindPolygon(vertices) {\r\n        this.#gl.bufferData(\r\n            this.#gl.ARRAY_BUFFER, \r\n            new Float32Array(vertices),\r\n            this.#gl.STATIC_DRAW);\r\n    }\r\n\r\n    #setSingleRectangle(width, height) {\r\n        const x1 = 0,\r\n            x2 = 0 + width,\r\n            y1 = 0,\r\n            y2 = 0 + height;\r\n        this.#gl.bufferData(this.#gl.ARRAY_BUFFER, \r\n            new Float32Array([\r\n                x1, y1,\r\n                x2, y1,\r\n                x1, y2,\r\n                x1, y2,\r\n                x2, y1,\r\n                x2, y2]), this.#gl.STATIC_DRAW);\r\n    }\r\n    /*------------------------------------\r\n     * End of Predefined Drawing programs\r\n     -------------------------------------*/\r\n\r\n    /**-----------------------------------\r\n     * Textures\r\n     ------------------------------------*/\r\n    #updateWebGlTexture(gl, texture, textureImage, textureNum = 0, useMipMaps = false) {\r\n        this.#bindTexture(gl, texture, textureNum);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\r\n        // LINEAR filtering is better for images and tiles, but for texts it produces a small blur\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        // for textures not power of 2 (texts for example)\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useMipMaps ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);\r\n    }\r\n\r\n    #updateTextWebGlTexture(gl, texture, textureImage, textureNum = 0) {\r\n        this.#bindTexture(gl, texture, textureNum);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImage);\r\n        // LINEAR filtering is better for images and tiles, but for texts it produces a small blur\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        // for textures not power of 2 (texts for example)\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n    }\r\n\r\n    #bindTexture(gl, texture, textureNum = 0) {\r\n        gl.activeTexture(gl.TEXTURE0 + textureNum);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n    }\r\n\r\n    #removeTexture(gl, texture) {\r\n        gl.deleteTexture(texture);\r\n    }\r\n    /*------------------------------------\r\n     * End Textures\r\n    --------------------------------------*/\r\n\r\n    isPowerOfTwo(value) {\r\n        return (value & (value - 1)) === 0;\r\n    }\r\n\r\n    nextHighestPowerOfTwo(x) {\r\n        --x;\r\n        for (var i = 1; i < 32; i <<= 1) {\r\n            x = x | x >> i;\r\n        }\r\n        return x + 1;\r\n    }\r\n\r\n    getNextRenderObject = (renderObject, pageData) => {\r\n        const objectIndex = pageData.renderObjects.indexOf(renderObject),\r\n            nextObject = pageData.renderObjects[objectIndex + 1];\r\n        return nextObject;\r\n    }\r\n\r\n    #glTextureIndex = (activeTexture) => {\r\n        return activeTexture - 33984;\r\n    }\r\n}","import { CONST } from \"./constants.js\";\r\n/**\r\n * Settings object, should be passed as a parameter to System.constructor().\r\n */\r\nexport class SystemSettings {\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(){}\r\n    /**\r\n     * DEBUG/PRODUCTION, for debug mode system Logger will show debug information in the console\r\n     */\r\n    static mode = CONST.MODE.DEBUG;\r\n\r\n    static gameOptions = {\r\n        // no other variants only WEBGL for now\r\n        library: CONST.LIBRARY.WEBGL,\r\n        optimization: CONST.OPTIMIZATION.NATIVE_JS.OPTIMIZED,\r\n        optimizationWASMUrl: \"./src/wa/calculateBufferDataWat.wasm\",\r\n        optimizationAssemblyUrl: \"/src/wa/calculateBufferDataAssembly.wasm\",\r\n        loadingScreen: {\r\n            backgroundColor:  \"rgba(128, 128, 128, 0.6)\",\r\n            loadingBarBg: \"rgba(128, 128, 128, 1)\",\r\n            loadingBarProgress: \"rgba(128, 128, 128, 0.2)\",\r\n        },\r\n        render: {\r\n            minCycleTime: 16.666, // is turned off from 1.5.3\r\n            cyclesTimeCalc: {\r\n                check: CONST.OPTIMIZATION.CYCLE_TIME_CALC.AVERAGES,\r\n                averageFPStime: 10000\r\n            },\r\n            boundaries: { // depricated from 1.5.9\r\n                mapBoundariesEnabled: true,\r\n                realtimeCalculations: true,\r\n                wholeWorldPrecalculations: false\r\n            },\r\n            collisionShapes: {\r\n                mapCollisionShapesEnabled: true,\r\n                realtimeCalculations: true,\r\n                wholeWorldPrecalculations: false\r\n            },\r\n        },\r\n        debug: {\r\n            preserveDrawingBuffer: false, // testing\r\n            checkWebGlErrors: false,\r\n            debugMobileTouch: false,\r\n            boundaries: { // depricated from 1.5.9\r\n                drawLayerBoundaries: false,\r\n                drawObjectBoundaries: false,\r\n                boundariesColor: \"rgba(224, 12, 21, 0.6)\",\r\n                boundariesWidth: 2\r\n            },\r\n            collisionShapes: {\r\n                drawLayerCollisionShapes: false,\r\n                drawObjectCollisionShapes: false,\r\n                color: \"rgba(224, 12, 21, 0.6)\",\r\n                width: 2\r\n            },\r\n            delayBetweenObjectRender: false, // 1 sec delay for debug proposes\r\n        }\r\n    };\r\n    \r\n\r\n    static network = {\r\n        // disable INetwork by default\r\n        enabled: false,\r\n        address: \"https://gameserver.reslc.ru:9009\",\r\n        gatherRoomsInfoInterval: 5000\r\n    };\r\n\r\n    static canvasMaxSize = {\r\n        width: 1800,\r\n        height: 1800\r\n    };\r\n\r\n    static worldSize = {\r\n        width: 960,\r\n        height: 960\r\n    };\r\n\r\n    static defaultCanvasKey = \"default\";\r\n\r\n    static customSettings = {};\r\n}","export const CONST = {\r\n    MODE: {\r\n        DEBUG: \"DEBUG\",\r\n        PRODUCTION: \"PRODUCTION\"\r\n    },\r\n    SCREENS: {},\r\n    AUDIO: {},\r\n    CONNECTION_STATUS: {\r\n        DISCONNECTED: \"disconnected\",\r\n        CONNECTED: \"connected\",\r\n        CONNECTION_LOST: \"connection lost\"\r\n    },\r\n    EVENTS: {\r\n        SYSTEM: {\r\n            START_PAGE:\"START_PAGE\",\r\n            STOP_PAGE: \"STOP_PAGE\",\r\n            RENDER: {\r\n                START: \"start\",\r\n                END: \"end\"\r\n            }\r\n        },\r\n        GAME: {\r\n            BOUNDARIES_COLLISION: \"BOUNDARIES_COLLISION\",\r\n            OBJECTS_COLLISION: \"OBJECTS_COLLISION\"\r\n        },\r\n        WEBSOCKET: {\r\n            SERVER_CLIENT: {\r\n                CONNECTION_STATUS_CHANGED: \"CONNECTION_STATUS_CHANGED\",\r\n                ROOMS_INFO: \"roomsInfo\",\r\n                CREATED: \"created\",\r\n                JOINED: \"joined\",\r\n                FULL: \"full\",\r\n                DISCONNECTED: \"disconnected\",\r\n                SERVER_MESSAGE: \"message\",\r\n                RESTARTED: \"restarted\",\r\n            },\r\n            CLIENT_SERVER: {\r\n                ROOMS_INFO_REQUEST: \"gatherRoomsInfo\",\r\n                CREATE_OR_JOIN: \"create or join\",\r\n                RESTART_REQUEST: \"restart\",\r\n                CLIENT_MESSAGE: \"message\"\r\n            }\r\n        }\r\n    },\r\n    WEBGL: {\r\n        DRAW_PROGRAMS: {\r\n            PRIMITIVES: \"drawPrimitives\",\r\n            IMAGES: \"drawImages\",\r\n            IMAGES_M: \"drawImagesMerge\"\r\n        }\r\n    },\r\n    LAYERS: {\r\n        DEFAULT: \"default-view-layer\",\r\n        BOUNDARIES: \"boundaries-view-layer\"\r\n    },\r\n    GAME_OPTIONS: {},\r\n    LIBRARY: {\r\n        WEBGL: \"webgl\"\r\n    },\r\n    OPTIMIZATION: {\r\n        CYCLE_TIME_CALC: {\r\n            AVERAGES: \"AVERAGES\",\r\n            CURRENT: \"CURRENT\"\r\n        },\r\n        NATIVE_JS: {\r\n            NOT_OPTIMIZED: \"NOT_OPTIMIZED\",\r\n            OPTIMIZED: \"OPTIMIZED\"\r\n        },\r\n        WEB_ASSEMBLY: {\r\n            ASSEMBLY_SCRIPT: \"ASSEMBLY_SCRIPT\",\r\n            NATIVE_WAT: \"WASM\"\r\n        }\r\n    }\r\n};\r\n/** @enum {string} */\r\nexport const DRAW_TYPE = {\r\n    RECTANGLE: \"rect\",\r\n    CONUS: \"conus\",\r\n    CIRCLE: \"circle\",\r\n    POLYGON: \"polygon\",\r\n    LINE: \"line\",\r\n    TEXT: \"text\",\r\n    IMAGE: \"image\"\r\n};\r\n\r\nexport const ERROR_CODES = {\r\n    CREATE_INSTANCE_ERROR: \"CREATE_INSTANCE_ERROR\",\r\n    STAGE_NOT_EXIST: \"STAGE_NOT_EXIST\",\r\n    ELEMENT_NOT_EXIST: \"ELEMENT_NOT_EXIST\",\r\n    FILE_NOT_EXIST: \"FILE_NOT_EXIST\",\r\n    CANT_GET_THE_IMAGE: \"CANT_GET_THE_IMAGE\",\r\n    UNEXPECTED_INPUT_PARAMS: \"UNEXPECTED_INPUT_PARAMS\",\r\n    UNHANDLED_EXCEPTION: \"UNHANDLED_EXCEPTION\",\r\n    CANVAS_KEY_NOT_SPECIFIED: \"CANVAS_KEY_NOT_SPECIFIED\",\r\n    CANVAS_WITH_KEY_NOT_EXIST: \"CANVAS_WITH_KEY_NOT_EXIST\",\r\n    WRONG_TYPE_ERROR: \"WRONG_TYPE_ERROR\",\r\n    UNEXPECTED_WS_MESSAGE: \"UNEXPECTED_WS_MESSAGE\",\r\n    UNEXPECTED_PLAYER_ID: \"UNEXPECTED_PLAYER_ID\",\r\n    UNEXPECTED_BULLET_ID: \"UNEXPECTED_BULLET_ID\",\r\n    UNEXPECTED_EVENT_NAME: \"UNEXPECTED_EVENT_NAME\",\r\n    WEBGL_ERROR: \"WEBGL_ERROR\",\r\n    DRAW_PREPARE_ERROR: \"DRAW_PREPARE_ERROR\",\r\n    ANOTHER_STAGE_ACTIVE: \"ANOTHER_STAGE_ACTIVE\",\r\n    UNEXPECTED_TILE_ID: \"UNEXPECTED_TILE_ID\",\r\n    UNEXPECTED_TOUCH_AREA: \"UNEXPECTED TOUCH AREA\",\r\n    UNEXPECTED_METHOD_TYPE: \"UNEXPECTED METHOD TYPE\"\r\n};\r\n\r\nexport const WARNING_CODES =  {\r\n    MULTIPLE_IMAGE_TILESET: \"MULTIPLE_IMAGE_TILESET\",\r\n    FILE_LOADING_ISSUE: \"FILE_LOADING_ISSUE\",\r\n    ASSETS_NOT_READY: \"ASSETS_NOT_READY\",\r\n    NOT_FOUND: \"NOT_FOUND\",\r\n    NOT_TESTED: \"NOT_TESTED\",\r\n    WORLD_DIMENSIONS_NOT_SET: \"WORLD_DIMENSIONS_NOT_SET\",\r\n    INCORRECT_RENDER_TYPE: \"INCORRECT_RENDER_TYPE\",\r\n    UNHANDLED_DRAW_ISSUE: \"UNHANDLED_DRAW_ISSUE\",\r\n    UNEXPECTED_WORLD_SIZE: \"UNEXPECTED_WORLD_SIZE\",\r\n    AUDIO_ALREADY_REGISTERED: \"AUDIO_ALREADY_REGISTERED\",\r\n    AUDIO_NOT_REGISTERED: \"AUDIO_NOT_REGISTERED\",\r\n    AUDIO_NOT_LOADED: \"AUDIO_NOT_LOADED\",\r\n    UNKNOWN_DRAW_OBJECT: \"UNKNOWN_DRAW_OBJECT\",\r\n    METHOD_NOT_IMPLEMENTED: \"METHOD_NOT_IMPLEMENTED\",\r\n    POLYGON_VERTICES_NOT_CORRECT: \"POLYGON_VERTICES_NOT_CORRECT\",\r\n    MODULE_ALREADY_INSTALLED: \"MODULE_ALREADY_INSTALLED\",\r\n    DEPRECATED_PARAMETER: \"DEPRECATED_PARAMETER\",\r\n    NEW_BEHAVIOR_INTRODUCED: \"NEW_BEHAVIOR_INTRODUCED\",\r\n    TEXTURE_IMAGE_TEMP_OVERFLOW: \"TEXTURE_IMAGE_TEMP_OVERFLOW\",\r\n    TRIANGULATE_ISSUE: \"TRIANGULATE_ISSUE\"\r\n};","import { GameStage } from \"../base/GameStage.js\";\n\nexport class LoadingStage extends GameStage {\n    #total = 0;\n    #loaded = 0;\n    #barWidth = 0;\n    register() {\n        //this.iLoader.addImage(logoKey, \"./images/icon.png\");\n    }\n\n    init() {\n        const [w, h] = this.stageData.canvasDimensions,\n            barWidth = w/3,\n            barHeight = 20;\n        //this.logo = this.draw.image(w/2, h/2, 300, 200, logoKey);\n        this.background = this.draw.rect(0, 0, w, h, this.systemSettings.gameOptions.loadingScreen.backgroundColor);  \n        this.loadingBarBg = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarBg);\n        this.loadingBarProgress = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarProgress);\n        this.text = this.draw.text(w/2 - 20, h/2 - 2 * barHeight, \"JsGE\", \"24px sans-serif\", \"black\");\n        this.#barWidth = barWidth;\n    }\n\n    _progress = (loaded) => {\n        const widthPart = this.#barWidth / this.#total;\n\n        this.#loaded = loaded;\n        const newWidth = widthPart * this.#loaded;\n        // sometimes additional items are added to queue in load process\n        // to avoid bar width overflow additional check added below:\n        const applyWidth = loaded > this.#total ? this.#barWidth : newWidth;\n\n        this.loadingBarProgress.width = applyWidth;\n    };\n\n    start(options) {\n        this.#total = options.total;\n    }\n\n    // a workaround for checking upload progress before render\n    //get iLoader() {\n    //    return ({filesWaitingForUpload:0});\n    //}\n} ","import { System } from \"./base/System.js\";\nimport { GameStage } from \"./base/GameStage.js\";\nimport { DrawImageObject } from \"./base/2d/DrawImageObject.js\";\nimport { ISystemAudio } from \"./base/ISystemAudio.js\";\nimport * as Primitives from \"./base/2d/Primitives.js\";\nimport { SystemSettings } from \"./configs.js\";\nimport { CONST } from \"./constants.js\";\nimport * as utils from \"./utils.js\";\n\nexport { System, SystemSettings, CONST, GameStage, DrawImageObject, ISystemAudio, Primitives, utils };\n","import { Vector } from \"./base/2d/Primitives.js\";\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent) ;\r\n}\r\n\r\nfunction isSafari() {\r\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\r\n}\r\n\r\nfunction pointToCircleDistance(x, y, circle) {\r\n    const pointToCircleCenterDistance = new Vector(x, y, circle.x, circle.y).length;\r\n    return pointToCircleCenterDistance - circle.r;\r\n}\r\n\r\nfunction countClosestTraversal(line, sight) {\r\n    const x1 = sight.x1,\r\n        y1 = sight.y1,\r\n        x2 = sight.x2,\r\n        y2 = sight.y2;\r\n    const x3 = line.x1,\r\n        y3 = line.y1,\r\n        x4 = line.x2,\r\n        y4 = line.y2;\r\n\r\n    const r_px = x1,\r\n        r_py = y1,\r\n        r_dx = x2-x1,\r\n        r_dy = y2-y1;\r\n\r\n    const s_px = x3,\r\n        s_py = y3,\r\n        s_dx = x4-x3,\r\n        s_dy = y4-y3;\r\n\r\n    const r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy),\r\n        s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);\r\n    if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){\r\n        return null;\r\n    }\r\n\r\n    const T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx),\r\n        T1 = (s_px+s_dx*T2-r_px)/r_dx;\r\n\r\n    if(T1<0 || isNaN(T1)) return null;\r\n    if(T2<0 || T2>1) return null;\r\n\r\n    return {\r\n        x: r_px+r_dx*T1,\r\n        y: r_py+r_dy*T1,\r\n        p: T1\r\n    };\r\n}\r\n\r\n/**\r\n * \r\n * @param {{x1:number, y1:number, x2:number, y2:number}} line1 \r\n * @param {{x1:number, y1:number, x2:number, y2:number}} line2 \r\n * @returns {{x:number, y:number, p:number} | undefined}\r\n * @ignore\r\n */\r\nfunction countClosestTraversal2(line1, line2) {\r\n    const x1 = line2.x1,\r\n        y1 = line2.y1,\r\n        x2 = line2.x2,\r\n        y2 = line2.y2;\r\n    const x3 = line1.x1,\r\n        y3 = line1.y1,\r\n        x4 = line1.x2,\r\n        y4 = line1.y2;\r\n\r\n    const det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n    // lines are parallel, or coincident\r\n    if (det === 0){\r\n        return;\r\n    }\r\n    let x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / det;\r\n    let y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / det;\r\n    const point = {x, y};\r\n    \r\n    if (isPointOnTheLine(point, line1, 0.0000000000001) && isPointOnTheLine(point, line2, 0.0000000000001)) {\r\n        const p = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));\r\n        return {x, y, p};\r\n    } else {\r\n        return;\r\n    }\r\n}\r\n\r\nfunction angle_2points(x1, y1, x2, y2) {\r\n    return Math.atan2(y2 - y1, x2 - x1);\r\n}\r\n\r\nfunction angle_3points(a, b, c) {\r\n    const x1 = a.x - b.x,\r\n        x2 = c.x - b.x,\r\n        y1 = a.y - b.y,\r\n        y2 = c.y - b.y,\r\n        d1 = Math.sqrt(x1 * x1 + y1 * y1),\r\n        d2 = Math.sqrt(x2 * x2 + y2 * y2);\r\n    //console.log(\"angle: \", (Math.acos((x1* x2 + y1 * y2) / (d1 * d2))* 180) / Math.PI);\r\n    return Math.acos((x1* x2 + y1 * y2) / (d1 * d2));\r\n}\r\n\r\nfunction dotProductWithAngle(lenA, lenB, angle) {\r\n    return lenA * lenB * Math.cos(angle);\r\n}\r\n\r\nfunction dotProduct(vec1, vec2) {\r\n    return vec1.x * vec2.x + vec1.y * vec2.y;\r\n}\r\n\r\nfunction crossProduct(a, b) {\r\n    return (a.x * b.y - b.x * a.y);\r\n}\r\n\r\nfunction isPointOnTheLine(point, line, m_error = 0) {\r\n    return  (\r\n        ((point.x >= (line.x1 - m_error)) && (point.x <= (line.x2 + m_error))) || \r\n                ((point.x <= (line.x1 + m_error)) && (point.x >= (line.x2 - m_error)))\r\n    ) && (\r\n        ((point.y >= (line.y1 - m_error)) && (point.y <= (line.y2 + m_error))) || \r\n                ((point.y <= (line.y1 + m_error)) && (point.y >= (line.y2 - m_error)))\r\n    );\r\n}\r\n\r\nfunction countDistance(obj1, obj2) {\r\n    return new Vector(obj1.x, obj1.y, obj2.x, obj2.y).length;\r\n}\r\n\r\nfunction isLineShorter(line1, line2) {\r\n    return (new Vector(line1.x1, line1.y1, line1.x2, line1.y2)).length < (new Vector(line2.x1, line2.y1, line2.x2, line2.y2)).length;\r\n}\r\n\r\nfunction isPointLineIntersect(point, line) {\r\n    const lineL = new Vector(line.x1, line.y1, line.x2, line.y2).length,\r\n        lengthAB = new Vector(line.x1, line.y1, point.x, point.y).length + new Vector(line.x2, line.y2, point.x, point.y).length;\r\n\r\n    if (lengthAB <= lineL + 0.2) {\r\n        //console.log(\"point to line intersect. line len: \" + lineL + \", line AB len: \" + lengthAB);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<Array<number>>} polygon \r\n * @param {{x1:number, y1:number, x2:number, y2:number}} line \r\n * @returns {{x:number, y:number, p:number} | null}\r\n * @ignore\r\n */\r\nfunction isPolygonLineIntersect(polygon, line) {\r\n    const len = polygon.length;\r\n    for (let i = 0; i < len; i+=1) {\r\n        let curr = polygon[i],\r\n            next = polygon[i+1];\r\n        //if next item not exist and current is not first\r\n        if (!next) {\r\n            // if current vertex is not the first one\r\n            if (!(curr[0] === polygon[0][0] && curr[1] === polygon[0][1])) {\r\n                next = polygon[0];\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\r\n        const intersection = countClosestTraversal2(edge, line);\r\n        if (intersection) {\r\n            return intersection;\r\n        }\r\n    }\r\n    if (polygon[len-1][0] !== polygon[0][0] && polygon[len-1][1] !== polygon[0][1]) {\r\n        //check one last item\r\n        const curr = polygon[len - 1],\r\n            next = polygon[0];\r\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\r\n        const intersection = countClosestTraversal2(edge, line);\r\n        if (intersection) {\r\n            return intersection;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isPointPolygonIntersect(x, y, polygon) {\r\n    const len = polygon.length;\r\n    \r\n    for (let i = 0; i < len; i+=1) {\r\n        let vertex1 = polygon[i],\r\n            vertex2 = polygon[i + 1];\r\n\r\n        // if last vertex, set vertex2 as the first\r\n        if (!vertex2) {\r\n            vertex2 = polygon[0];\r\n        }\r\n\r\n        if (isPointLineIntersect({x,y}, {x1: vertex1[0], y1: vertex1[1], x2: vertex2[0], y2: vertex2[1]})) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction isPointInsidePolygon(x, y, polygon) {\r\n    const len = polygon.length;\r\n    let intersections = 0;\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        let vertex1 = polygon[i],\r\n            vertex2 = polygon[i + 1] ? polygon[i + 1] : polygon[0],\r\n            x1 = vertex1[0],\r\n            y1 = vertex1[1],\r\n            x2 = vertex2[0],\r\n            y2 = vertex2[1];\r\n            \r\n        if (y < y1 !== y < y2 && \r\n            x < (x2 - x1) * (y - y1) / (y2 - y1) + x1) {\r\n            intersections++;\r\n        }\r\n    }\r\n    \r\n    if (intersections > 0) {\r\n        if (intersections % 2 === 0) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction isPointRectIntersect(x, y, rect) {\r\n    if (x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.y + rect.height) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {number} x \r\n * @param {number} y \r\n * @param {{x:number, y:number, r:number}} circle \r\n * @returns {boolean}\r\n */\r\nfunction isPointCircleIntersect(x, y, circle) {\r\n    const radius = circle.r,\r\n        lineToCircleCenter = new Vector(x, y, circle.x, circle.y),\r\n        pointCircleLineLength = lineToCircleCenter.length;\r\n        \r\n    if (pointCircleLineLength < radius)\r\n        return true;\r\n    else\r\n        return false;\r\n}\r\n\r\nfunction isCircleLineIntersect(x, y, r, line) {\r\n    const x1 = line.x1,\r\n        y1 = line.y1,\r\n        x2 = line.x2,\r\n        y2 = line.y2,\r\n        vec1 = {x: x1 - x, y: y1-y}, //new Vector(x, y, x1, y1),\r\n        vec2 = {x: x2 - x, y: y2-y}, //new Vector(x, y, x2, y2),\r\n        vec3 = {x: x2 - x1, y: y2-y1}, //new Vector(x1 ,y1, x2, y2),\r\n        vec4 = {x: x1 - x2, y: y1-y2}, //new Vector(x2, y2, x1, y1),\r\n        vec3Len = Math.sqrt(Math.pow(vec3.x, 2) + Math.pow(vec3.y, 2)),//vec3.length,\r\n        dotP1 = dotProduct(vec1, vec4),\r\n        dotP2 = dotProduct(vec2, vec3);\r\n        // checks if the line is inside the circle,\r\n        // max_dist = Math.max(vec1Len, vec2Len);\r\n    let min_dist;\r\n    \r\n    if (dotP1 > 0 && dotP2 > 0) {\r\n        min_dist = crossProduct(vec1,vec2)/vec3Len;\r\n        if (min_dist < 0) {\r\n            min_dist *= -1;\r\n        }\r\n    } else {\r\n        min_dist = Math.min(vec1.length, vec2.length);\r\n    }\r\n    \r\n    if (min_dist <= r) { // && max_dist >= r) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    } \r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<number>} ellipse - x,y,radX,radY\r\n * @param {Array<Array<number>>} line [x1,y1],[x2,y2]\r\n */\r\nfunction isEllipseLineIntersect(ellipse, line) {\r\n    const x = ellipse[0],\r\n        y = ellipse[1],\r\n        radX = ellipse[2],\r\n        radY = ellipse[3],\r\n        x1 = line[0][0],\r\n        y1 = line[0][1],\r\n        x2 = line[1][0],\r\n        y2 = line[1][1],\r\n        lineAToElCenter = { x: x - x1, y: y - y1 }, //new Vector(x, y, x1, y1),\r\n        lineBToElCenter = { x: x - x2, y: y - y2 }, //new Vector(x, y, x2, y2),\r\n        lineAToElCenterLen = Math.sqrt(Math.pow(lineAToElCenter.x, 2) + Math.pow(lineAToElCenter.y, 2)),\r\n        lineBToElCenterLen = Math.sqrt(Math.pow(lineBToElCenter.x, 2) + Math.pow(lineBToElCenter.y, 2)),\r\n        lineToCenterLenMin = Math.min(lineAToElCenterLen, lineBToElCenterLen),\r\n        ellipseMax = Math.max(radX, radY);\r\n        \r\n    if (lineToCenterLenMin > ellipseMax) {\r\n        return false;\r\n    }\r\n    \r\n    const traversalLine = lineToCenterLenMin === lineAToElCenterLen ? lineAToElCenter : lineBToElCenter,\r\n        angleToAxisX = Math.atan2(traversalLine.y, traversalLine.x);\r\n    \r\n    const intersectX = Math.cos(angleToAxisX) * radX,\r\n        intersectY = Math.sin(angleToAxisX) * radY,\r\n        lineToCenter = { x: 0 - intersectX, y: 0 - intersectY },\r\n        intersectLineLen = Math.sqrt(Math.pow(lineToCenter.x, 2) + Math.pow(lineToCenter.y, 2));\r\n    //console.log(\"lenToCheck: \", lenToCheck);\r\n    //console.log(\"x: \", intersectX);\r\n    if (lineToCenterLenMin > intersectLineLen) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<number>} ellipse - x,y,radX,radY\r\n * @param {{x:number, y:number, r:number}} circle\r\n * @returns {{x:number, y:number, p:number} | boolean}\r\n */\r\nfunction isEllipseCircleIntersect(ellipse, circle) {\r\n    const ellipseX = ellipse[0],\r\n        ellipseY = ellipse[1],\r\n        ellipseToCircleLine = { x: ellipseX - circle.x, y: ellipseY - circle.y },\r\n        len = Math.sqrt(Math.pow(ellipseToCircleLine.x, 2) + Math.pow(ellipseToCircleLine.y, 2)),\r\n        maxRad = Math.max(ellipse[2], ellipse[3]);\r\n    // no collisions for sure\r\n    if (len > (maxRad + circle.r)) {\r\n        return false;\r\n    } else {\r\n        // check possible collision\r\n        const angle = angle_2points(ellipseX, ellipseY, circle.x, circle.y),\r\n            traversalX = ellipseX + (ellipse[2] * Math.cos(angle)),\r\n            traversalY =  ellipseY + (ellipse[3] * Math.sin(angle)),\r\n            vecTrX = ellipseX - traversalX,\r\n            vecTrY = ellipseY - traversalY,\r\n            traversalLen = Math.sqrt(Math.pow(vecTrX, 2) + Math.pow(vecTrY, 2)) + circle.r;\r\n        if (len <= traversalLen) {\r\n            return {x: vecTrX, y: vecTrY, p:1};\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<number>} ellipse - x,y,radX,radY\r\n * @param {Array<Array<number>>} polygon - x,y\r\n * @returns {boolean}\r\n */\r\nfunction isEllipsePolygonIntersect(ellipse, polygon) {\r\n    const len = polygon.length;\r\n\r\n    for (let i = 0; i < len; i+=1) {\r\n        let vertex1 = polygon[i],\r\n            vertex2 = polygon[i + 1];\r\n\r\n        // if last vertex, set vertex2 as the first\r\n        if (!vertex2) {\r\n            vertex2 = polygon[0];\r\n        }\r\n\r\n        if (isEllipseLineIntersect(ellipse, [vertex1, vertex2])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction generateUniqId() {\r\n    return Math.round(Math.random() * 1000000); \r\n}\r\n\r\nfunction randomFromArray(array) {\r\n    return array[Math.floor(Math.random()*array.length)];\r\n}\r\n\r\nfunction verticesArrayToArrayNumbers(array) {\r\n    const len = array.length,\r\n        numbers = [];\r\n    for (let i = 0; i < len; i++) {\r\n        const vertex = array[i];\r\n        numbers.push([vertex.x, vertex.y]);\r\n    }\r\n    return numbers;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<Array<number>>} arrayDots\r\n * @returns {Array<Array<number>>} \r\n */\r\nfunction calculateLinesVertices(x = 0, y = 0, r, arrayDots) {\r\n    const len = arrayDots.length;\r\n    let arrayLines = Array(len),\r\n        arrayDotsIterator = 0;\r\n        \r\n    for (let i = 0; i < len; i++) {\r\n        const dot1 = arrayDots[i];\r\n        let dot2 = arrayDots[i+1];\r\n        if (!dot2) {\r\n            dot2 = arrayDots[0];\r\n        }\r\n        const x1 = dot1[0],\r\n            y1 = dot1[1],\r\n            x2 = dot2[0],\r\n            y2 = dot2[1];\r\n\r\n        const x1R = x1 * Math.cos(r) - y1 * Math.sin(r),\r\n            y1R = x1 * Math.sin(r) + y1 * Math.cos(r),\r\n            x2R = x2 * Math.cos(r) - y2 * Math.sin(r),\r\n            y2R = x2 * Math.sin(r) + y2 * Math.cos(r);\r\n        const line = [x1R + x, y1R + y, x2R + x, y2R + y];\r\n        \r\n        arrayLines[arrayDotsIterator] = line;\r\n        arrayDotsIterator++;\r\n    }\r\n    return arrayLines;\r\n}\r\n\r\n/**\r\n * @param {number} x\r\n * @param {number} y\r\n * @param {number} radiusX\r\n * @param {number} radiusY\r\n * @param {number} [angle = 2 * Math.PI]\r\n * @param {number} [step = Math.PI/12] \r\n * @returns {Array<Array<number>>}\r\n */\r\nfunction calculateEllipseVertices(x = 0, y = 0, radiusX, radiusY, angle = 2*Math.PI, step = Math.PI/8) {\r\n    let ellipsePolygonCoords = [];\r\n\r\n    for (let r = 0; r <= angle; r += step) {\r\n        let x2 = Math.cos(r) * radiusX + x,\r\n            y2 = Math.sin(r) * radiusY + y;\r\n\r\n        ellipsePolygonCoords.push([x2, y2]);\r\n    }\r\n\r\n    return ellipsePolygonCoords;\r\n}\r\n\r\n/**\r\n * \r\n * @param { Array<number> } mat1 \r\n * @param { Array<number> } mat2 \r\n * @returns { Array<number> }\r\n */\r\nfunction mat3Multiply(mat1, mat2) {\r\n    let matResult = [];\r\n    for (let resultIdx = 0; resultIdx < 9; resultIdx += 3) {\r\n        let resultIndex = resultIdx;\r\n        \r\n        for (let i = 0; i < 3; i++) {\r\n            let resultVal = 0,\r\n                k = i;\r\n                \r\n            for (let j = 0; j < 3; j++) {\r\n                const mat1Val = mat1[resultIdx + j],\r\n                    mat2Val = mat2[k];\r\n\r\n                resultVal += (mat1Val * mat2Val);\r\n                k+=3;\r\n            }\r\n            matResult[resultIndex] = resultVal;\r\n            resultIndex++;\r\n        }\r\n    }\r\n    return matResult;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<number>} mat3 [a, b, c,\r\n *                              d. e, f,\r\n *                              g, h, i]\r\n * @param {Array<number>} vec3 [x1, y1]\r\n * @returns {Array<number>} [a * x1 + b * y1 + c * 1,  d * x1 + e * y1 + f * 1]\r\n */\r\nfunction mat3MultiplyVector (mat3, vec3) {\r\n    let result = [];\r\n    let resultIndex = 0;\r\n    for (let rowStartIdx = 0; rowStartIdx < 6; rowStartIdx += 3) {\r\n        let resultVal = 0;\r\n        const stopInt = rowStartIdx + 3;\r\n        let vecIdx = 0;\r\n        for (let rowIdx = rowStartIdx; rowIdx < stopInt; rowIdx++) {\r\n            const matVal = mat3[rowIdx],\r\n                vecVal = vec3[vecIdx] || 1; // z1 coord\r\n            resultVal += (matVal * vecVal);\r\n            vecIdx++;\r\n        }\r\n        result[resultIndex] = resultVal;\r\n        resultIndex++;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * \r\n * @param {Array<number>} mat3 [a, b, c,\r\n *                              d. e, f,\r\n *                              g, h, i]\r\n * @param {Array<number>} vec3 [x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2, ...]\r\n * @returns {Array<number>} [a*x1 + b*y1 + c*1, d*y1 + e*y1 + f*1, ...]\r\n */\r\nfunction mat3MultiplyPosCoords (mat3, vec3) {\r\n    const vec3Len = vec3.length;\r\n    let result = [];\r\n    let resultIndex = 0;\r\n    for (let nPair = 0; nPair < vec3Len; nPair += 2) {\r\n        for (let rowStartIdx = 0; rowStartIdx < 6; rowStartIdx += 3) {\r\n            let resultVal = 0;\r\n            const stopInt = rowStartIdx + 3;\r\n            let vecIdx = nPair;\r\n            let iteration = 1;\r\n            for (let rowIdx = rowStartIdx; rowIdx < stopInt; rowIdx++) {\r\n                const matVal = mat3[rowIdx],\r\n                    vecVal = iteration === 3 ? 1 : vec3[vecIdx]; // 3: z1 = 1 coord\r\n                resultVal += (matVal * vecVal);\r\n                vecIdx++;\r\n                iteration++;\r\n            }\r\n            result[resultIndex] = resultVal;\r\n            resultIndex++;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nexport { \r\n    isMobile, \r\n    isSafari, \r\n    pointToCircleDistance, \r\n    countClosestTraversal, \r\n    countClosestTraversal2,\r\n    angle_2points,\r\n    angle_3points,\r\n    dotProductWithAngle,\r\n    dotProduct,\r\n    crossProduct,\r\n    isPointOnTheLine,\r\n    isLineShorter,\r\n    isPointLineIntersect,\r\n    isPointPolygonIntersect,\r\n    isPointRectIntersect,\r\n    isPointCircleIntersect,\r\n    isPolygonLineIntersect,\r\n    isCircleLineIntersect,\r\n    isEllipseLineIntersect,\r\n    isEllipseCircleIntersect,\r\n    isEllipsePolygonIntersect,\r\n    isPointInsidePolygon,\r\n    generateUniqId,\r\n    randomFromArray,\r\n    verticesArrayToArrayNumbers,\r\n    countDistance,\r\n    calculateEllipseVertices,\r\n    calculateLinesVertices,\r\n    mat3Multiply,\r\n    mat3MultiplyVector,\r\n    mat3MultiplyPosCoords\r\n };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.es6.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"jsge:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\t\tscript.type = \"module\";\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (typeof import.meta.url === \"string\") scriptUrl = import.meta.url\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkjsge\"] = self[\"webpackChunkjsge\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.js\");\n",""],"names":[],"sourceRoot":""}