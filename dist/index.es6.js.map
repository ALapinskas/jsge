{"version":3,"file":"index.es6.js","mappings":";;;;;;;;;;;;AAAA,2BAA2B,qGAAqG,aAAa,GAAG,GAAG,WAAW,WAAW,iBAAiB,+BAA+B,oBAAoB,yDAAyD,wFAAwF,+BAA+B,6HAA6H,GAAG,QAAQ,iBAAiB,MAAM,kBAAkB,4BAA4B,oBAAoB,mBAAmB,eAAe,mBAAmB,eAAe,iBAAiB,8FAA8F,iCAAiC,2BAA0C,oBAAoB,mBAAmB,WAAW,KAAK,cAAc,2IAA2I,4BAA4B,QAAQ,2EAA2E,iDAAiD,wCAAwC,sBAAsB,oBAAoB,0GAA0G,UAAU,sCAAsC,qBAAqB,gDAAgD,cAAc,mBAAmB,GAAG,GAAG,KAAK,4IAA4I,sBAAsB,2BAA2B,wHAAwH,8BAA8B,sCAAsC,WAAW,MAAM,oBAAoB,GAAG,2DAA2D,MAAM,eAAe,GAAG,4FAA4F,eAAe,mDAAmD,yBAAyB,IAAI,qCAAqC,uEAAuE,gCAAgC,2MAA2M,WAAW,mCAAmC,+DAA+D,UAAU,4BAA4B,YAAY,WAAW,KAAK,aAAa,qBAAqB,0BAA0B,IAAI,yHAAyH,uCAAuC,qBAAqB,sCAAsC,eAAe,oCAAoC,yCAAyC,gBAAgB,GAAG,GAAG,uCAAuC,kBAAkB,cAAc,+BAA+B,eAAe,GAAG,gBAAgB,yCAAyC,gBAAgB,SAAS,GAAG,MAAM,uIAAuI,MAAM,+HAA+H,eAAe,uBAAuB,kFAAkF,mBAAmB,uBAAuB,gCAAgC,iDAAiD,aAAa,uBAAuB,0BAA0B,iDAAiD,QAAQ,6CAA6C,0EAA0E,KAAK,iCAAiC,uEAAuE,QAAQ,GAAG,KAAK,mEAAmE,KAAK,mCAAmC,iFAAiF,2CAA2C,GAAG,MAAM,mEAAmE,QAAQ,IAAI,sBAAsB,mBAAmB,oBAAoB;;;;;;;;;;;;;;ACA7jJ;AACP;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3D+C;AACK;AACS;AACR;AACN;AACM;AACiB;AACtE,WAAW,sBAAsB;AACO;AACe;AACE;AACF;AACF;AACM;AACN;AACA;;AAErD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sFAAsF,0FAA+C;AACrI;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,kFAAuC;AACjE,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,8DAAc;AACrD;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,kFAAuC;AACjE,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,sDAAO,CAAC,kEAAuB;AAC/C;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,sDAAO,CAAC,8EAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,kBAAkB;AACpD;AACA;;AAEA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,6EAAkC;AAC1D;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,YAAY,wDAAS,CAAC,kFAAuC;AAC7D,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,iDAAiD,gEAAe;AAChE,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sDAAO,CAAC,kEAAuB;AACnD;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sDAAO,CAAC,8EAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,iBAAiB;AACvD,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,6HAA6H;AAC5I,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,gEAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B,+DAAoB;AACjE;AACA,cAAc,+BAA+B,iEAAsB,0BAA0B,gEAAqB;AAClH;AACA,cAAc,+BAA+B,+DAAoB;AACjE;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;AC5vBwC;AACe;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,+BAA+B,gEAAe;AACrD;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,iEAAsB;AACpC;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CwC;AACe;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,8BAA8B,gEAAe;AACpD;AACA,cAAc;AACd;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gEAAqB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5EqE;AAC7B;AACe;AACvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,8BAA8B,gEAAe;AACpD;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,gEAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB,gBAAgB,gBAAgB;AAChC,gBAAgB,UAAU;AAC1B;AACA;AACA,mCAAmC,8EAAsB;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxMwC;AACe;;AAEvD;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,+DAAoB;AAClC;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChCqD;AACA;AACE;AACA;AACF;AACM;AACF;;AAEzD;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACO;;AAEP;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA,mBAAmB,8DAAc;AACjC;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,mBAAmB,8DAAc;AACjC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA,mBAAmB,gEAAe;AAClC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA,mBAAmB,kEAAgB;AACnC;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,OAAO,mBAAmB,IAAI;AAC7C,iBAAiB;AACjB;AACA;AACA,mBAAmB,gEAAe;AAClC;;AAEA;AACA,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,mBAAmB,8DAAc;AACjC;;AAEA;AACA,eAAe,OAAO,mBAAmB,GAAG;AAC5C,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA,mBAAmB,oEAAiB;AACpC;AACA;;;;;;;;;;;;;;;;AChGwC;AACe;;AAEvD;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,gCAAgC,gEAAe;AACtD;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,kEAAuB;AACrC;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/BwC;AACe;;AAEvD;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,oEAAyB;AACvC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1DwC;AACJ;;AAEpC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU,2DAAoB;AAC9B;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,8BAA8B,mBAAmB,GAAG;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,wEAAiC;AACpD,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClMuD;AACX;AACJ;;AAExC;AACA;AACA,SAAS,yBAAyB;AAClC;AACO,6BAA6B,gEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,+DAAoB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,mBAAmB,qDAAS;AAC5B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvHwD;AACZ;;AAErC;AACP;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;;AAEA;AACA,6BAA6B,+EAAoC;AACjE;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpBO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;;;;ACN+C;AACP;;AAEjC;AACP;AACA,YAAY,4DAAmB,KAAK,2DAAgB;AACpD;AACA;AACA;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7EO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDoE;AACf;AACD;AACf;AACiC;AACvB;AACF;AACc;AACF;AACF;AACA;AACF;AACM;AACN;AACA;AACE;AACU;AAClB;AAC2C;AACjD;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,6BAA6B,oEAAiB;AAC9C;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,8DAAc;AACjD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,GAAG;AAClB,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,gCAAgC,sDAAU;AAC1C;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,8EAAmC;AACzD;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,YAAY,wDAAS,CAAC,+EAAoC;AAC1D,UAAU;AACV,YAAY,wDAAS,CAAC,gFAAqC;AAC3D,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB;AACA;AACA;AACA,YAAY,wDAAS,CAAC,+EAAoC;AAC1D,UAAU;AACV,YAAY,wDAAS,CAAC,gFAAqC;AAC3D,UAAU;AACV;AACA,qCAAqC,wDAAW;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,gFAAqC;AAC3D;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yEAA8B;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wEAA6B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC,iBAAiB,oEAAyB;AAC1C,iBAAiB,gEAAqB;AACtC,iBAAiB,gEAAqB;AACtC;AACA;AACA,iBAAiB,iEAAsB;AACvC;AACA;AACA,iBAAiB,+DAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,sBAAsB;AACrC,eAAe,QAAQ;AACvB,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,kEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,4BAA4B,kEAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mDAAM;AACjC,0BAA0B,yDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAoB;AACjC,aAAa,oEAAyB;AACtC,aAAa,gEAAqB;AAClC,aAAa,gEAAqB;AAClC;AACA,aAAa,iEAAsB;AACnC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA,aAAa,+DAAoB;AACjC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA,YAAY,sDAAO,CAAC,kFAAuC;AAC3D;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,eAAe,wBAAwB;AACvC,kBAAkB,8BAA8B,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA,aAAa,+DAAoB;AACjC,aAAa,oEAAyB;AACtC,aAAa,gEAAqB;AAClC,aAAa,gEAAqB;AAClC;AACA,aAAa,iEAAsB;AACnC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA,aAAa,+DAAoB;AACjC,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA,YAAY,sDAAO,CAAC,kFAAuC;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAsB;AAC9C,kCAAkC,iFAAsC;AACxE;AACA,kBAAkB;AAClB,wBAAwB,gEAAoB,GAAG,sCAAsC;AACrF,kCAAkC,iFAAsC;AACxE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,oDAAY;AACpB;AACA;AACA,iBAAiB,8DAAmB;AACpC;AACA;AACA;AACA,kBAAkB;AAClB,oBAAoB,sDAAO,CAAC,yEAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAO,CAAC,6EAAkC;AAClE;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAAgC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAO,CAAC,6EAAkC;AAC9D;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yEAA8B;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sDAAO,CAAC,6EAAkC;AACtE;AACA,0CAA0C,6EAAkC;AAC5E;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAuB;AACvD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4BAA4B,sDAAO,CAAC,6EAAkC;AACtE;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;;;;;;;;;;;;;;;;AClvBgD;AACP;AACzC;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA,6BAA6B,2BAA2B;AACxD,6BAA6B,2BAA2B;AACxD,6BAA6B,2BAA2B;AACxD,6BAA6B,2BAA2B;AACxD;;AAEA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,iFAAsC;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnR8C;AACH;AACE;AACU;AACR;;AAEY;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,gEAAe;AAC1C;AACA,2CAA2C,mEAAa;;AAExD;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,mBAAmB;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxFuE;AACvB;AACP;;AAEzC;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAkB;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,yEAA8B;AAClD;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,sDAAO,CAAC,6EAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,yEAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,sDAAO,CAAC,6EAAkC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC7F8C;AACH;AAC0B;AACJ;AAClB;AACuB;AACtE;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc;AACvB,SAAS,kBAAkB;AAC3B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;AACA;AACA,2BAA2B,4EAAa;AACxC,yCAAyC,0EAAoB;AAC7D,2CAA2C,8EAAsB;AACjE;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,qEAA0B;AAChD;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,qEAA0B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;AC1FqD;AACV;AACN;AACiB;;AAEtD;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAS,CAAC,4EAAiC;AACvD;AACA;AACA;;AAEA;AACA,QAAQ,mOAA0B;AAClC,4EAA4E,sBAAsB;AAClG;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,kGAAuD;AACjF;;AAEA;AACA,0BAA0B,8FAAmD;AAC7E;;AAEA;AACA,0BAA0B,8FAAmD;AAC7E;;AAEA;AACA,QAAQ,oDAAY;AACpB,qCAAqC,yGAA8D;AACnG;;AAEA;AACA,QAAQ,oDAAY;AACpB,qCAAqC,yGAA8D;AACnG;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,8FAAmD;AAC9F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,0FAA+C;AAC1F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,uFAA4C,GAAG,UAAU;AACpG;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,oFAAyC,GAAG,KAAK;AAC5F;;AAEA;AACA,QAAQ,oDAAY;AACpB,+BAA+B,+DAAW,CAAC,sFAA2C,GAAG,UAAU;AACnG;;AAEA;AACA,+BAA+B,+DAAW,CAAC,4FAAiD,GAAG,SAAS;AACxG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrIO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;ACrHoE;AACzB;AACS;AACa;;AAE1D;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,YAAY,wDAAS,CAAC,8EAAmC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2EAAgC;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,+EAAoC;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,2EAAgC;AAChE;AACA;AACA;;AAEA,2BAA2B,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,0EAAoB;AAChE;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,2EAAgC;AAChE;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA,4BAA4B,2EAAgC;AAC5D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,2EAAgC;AAC5D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,+EAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa,oEAAyB;AACtC;AACA;AACA;AACA,aAAa,+DAAoB;AACjC;AACA,aAAa,iEAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAuB;AACpC;AACA;AACA;AACA;AACA,gBAAgB,sDAAO,CAAC,qFAA0C,cAAc,gBAAgB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,+EAAoC;AAChE;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,+EAAoC;AAChE;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,sDAAO,CAAC,qFAA0C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,+EAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;;AAEA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;;AAEA;AACA;AACA;AACA,gBAAgB,wDAAS,CAAC,kEAAuB,0CAA0C,KAAK;AAChG;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB;AAC7C;AACA;AACA;;AAEA;AACA;AACA,eAAe,GAAG;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,wDAAS,CAAC,kEAAuB;AACjD;AACA,UAAU;AACV,YAAY,wDAAS,CAAC,kEAAuB,qBAAqB,WAAW;AAC7E;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA,2FAA2F,QAAQ;AACnG;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC,uDAAY,EAAE,8BAA8B,GAAG,8BAA8B;;AAElH;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,wDAAS,CAAC,yEAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrgCuC;AACvC;AACA;AACA;AACA;AACO;AACP,UAAU,2DAAgB;AAC1B;AACA;AACA,iBAAiB,8DAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;;;;;;;;ACtDO;AACP;AACA;AACA;AACA,KAAK;AACL,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,oBAAoB;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5GmD;AACf;;AAEpC;AACO,4BAA4B,2DAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,2DAAoB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,2DAAoB;AACjD,6BAA6B,2DAAoB;AACjD;AACA,6BAA6B,2DAAoB;AACjD,6BAA6B,2DAAoB;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChD0C;AACQ;AACU;AACU;AACnB;AACL;AACP;AACH;AACpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACR8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,uDAAM;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,6CAA6C;AACzD,YAAY,6CAA6C;AACzD,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAM;AACrB;;AAEA;AACA,gBAAgB,uDAAM,wDAAwD,uDAAM;AACpF;;AAEA;AACA,sBAAsB,uDAAM;AAC5B,uBAAuB,uDAAM,kDAAkD,uDAAM;;AAErF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,6CAA6C;AACzD,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,uDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;;;;;;;;SC5NA;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;SAEA;SACA;;;;;UCzBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,EAAE;UACF;;;;;UCRA;UACA;UACA;UACA;UACA;;;;;UCJA;;;;;UCAA;UACA;UACA;UACA;UACA,uBAAuB,4BAA4B;UACnD;UACA;UACA;UACA,iBAAiB,oBAAoB;UACrC;UACA,mGAAmG,YAAY;UAC/G;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,mEAAmE,iCAAiC;UACpG;UACA;UACA;UACA;;;;;UCxCA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;UCNA;UACA;UACA;UACA;UACA;UACA;UACA;;;;;UCNA;;UAEA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA;UACA,iCAAiC;;UAEjC;UACA;UACA;UACA,KAAK;UACL,eAAe;UACf;UACA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM;UACN;UACA;UACA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,MAAM,qBAAqB;UAC3B;UACA;UACA;UACA;UACA;UACA;;UAEA;;UAEA;UACA;UACA;;;;;SErFA;SACA;SACA;SACA","sources":["webpack://jsge/./modules/assetsm/dist/assetsm.min.js","webpack://jsge/./src/base/AnimationEventImageObj.js","webpack://jsge/./src/base/CanvasView.js","webpack://jsge/./src/base/DrawCircleObject.js","webpack://jsge/./src/base/DrawConusObject.js","webpack://jsge/./src/base/DrawImageObject.js","webpack://jsge/./src/base/DrawLineObject.js","webpack://jsge/./src/base/DrawObjectFactory.js","webpack://jsge/./src/base/DrawPolygonObject.js","webpack://jsge/./src/base/DrawRectObject.js","webpack://jsge/./src/base/DrawShapeObject.js","webpack://jsge/./src/base/DrawTextObject.js","webpack://jsge/./src/base/Events/SystemEvent.js","webpack://jsge/./src/base/Exception.js","webpack://jsge/./src/base/Logger.js","webpack://jsge/./src/base/Primitives.js","webpack://jsge/./src/base/RenderLayer.js","webpack://jsge/./src/base/ScreenPage.js","webpack://jsge/./src/base/ScreenPageData.js","webpack://jsge/./src/base/System.js","webpack://jsge/./src/base/SystemAudioInterface.js","webpack://jsge/./src/base/SystemInterface.js","webpack://jsge/./src/base/SystemSocketConnection.js","webpack://jsge/./src/base/WebGlDrawProgramData.js","webpack://jsge/./src/base/WebGlInterface.js","webpack://jsge/./src/configs.js","webpack://jsge/./src/constants.js","webpack://jsge/./src/design/LoadingScreen.js","webpack://jsge/./src/index.js","webpack://jsge/./src/utils.js","webpack://jsge/webpack/bootstrap","webpack://jsge/webpack/runtime/define property getters","webpack://jsge/webpack/runtime/ensure chunk","webpack://jsge/webpack/runtime/get javascript chunk filename","webpack://jsge/webpack/runtime/hasOwnProperty shorthand","webpack://jsge/webpack/runtime/load script","webpack://jsge/webpack/runtime/make namespace object","webpack://jsge/webpack/runtime/publicPath","webpack://jsge/webpack/runtime/jsonp chunk loading","webpack://jsge/webpack/before-startup","webpack://jsge/webpack/startup","webpack://jsge/webpack/after-startup"],"sourcesContent":["const PROGRESS_EVENT_TYPE={loadstart:\"loadstart\",progress:\"progress\",abort:\"abort\",error:\"error\",load:\"load\",timeout:\"timeout\"};class Loader{#e;#t;#s=new Map;#i=new Map;constructor(e,t){this.#e=e,this.#t=(e,s,...i)=>{const r=t(e,s,...i);if(r instanceof Promise)return r.then((t=>this.#r(t,e)));Exception(\"uploadMethod should be instance of Promise and return upload result value\")}}#r=(e,t)=>new Promise(((s,i)=>{e&&0!==e.length||Warning(\"uploadMethod for \"+this.#e+\" should return Promise with upload value\"),this.#o(t,e),this.#a(t),s()}));#o(e,t){this.#i.set(e,t)}#a(e){this.#s.delete(e)}get filesWaitingForUpload(){return this.#s.size}get loadingQueue(){return this.#s}get uploadMethod(){return this.#t}_addFile=(e,t)=>{this.#s.has(e)&&Warning(\"File \"+this.#e+\" with key \"+e+\" is already added\"),this.#s.set(e,t)};_isFileInQueue=e=>this.#s.has(e);_getFile=e=>this.#i.get(e)}export default class AssetsManager{#n=new EventTarget;#d=new Map;#l=0;constructor(){this.registerLoader(\"Audio\",this._loadAudio),this.registerLoader(\"Image\",this._loadImage),this.registerLoader(\"TileMap\",this._loadTileMap)}get filesWaitingForUpload(){let e=0;return Array.from(this.#d.values()).map((t=>e+=t.filesWaitingForUpload)),e}registerLoader=(e,t=this._defaultUploadMethod)=>{const s=this.#d.get(e)||new Loader(e,t);this[\"add\"+e]=(t,s)=>{this.addFile(e,t,s)},this[\"get\"+e]=t=>this.getFile(e,t),this[\"is\"+e+[\"InQueue\"]]=t=>this.isFileInQueue(e,t),this.#d.set(e,s)};preload(){return this.#h(),new Promise(((e,t)=>{this.#u().then((()=>{this.filesWaitingForUpload?this.#u().then((()=>{this.#c(),e()})):(this.#c(),e())}))}))}#u(){const e=Array.from(this.#d.values()).map((e=>Promise.allSettled(Array.from(e.loadingQueue.entries()).map((t=>e.uploadMethod(t[0],t[1]))))));return Promise.all(e)}addEventListener(e,t,...s){PROGRESS_EVENT_TYPE[e]?this.#n.addEventListener(e,t,...s):Warning(\"Event type should be one of the ProgressEvent.type\")}removeEventListener(e,t,...s){this.#n.removeEventListener(e,t,...s)}#p=(e,t)=>{const{firstgid:s,source:i}=e;return this.#g(i),fetch(t+i).then((e=>e.json())).then((e=>{const{name:i,image:r}=e;return i&&r&&!this.isImageInQueue(i)&&this.addImage(i,t?t+r:r,e),e.gid=s,Promise.resolve(e)})).catch((()=>{const e=new Error(\"Can't load related tileset \",i);return Promise.reject(e)}))};_defaultUploadMethod=(e,t)=>fetch(t);_loadTileMap=(e,t)=>(this.#m(t),fetch(t).then((e=>e.json())).then((e=>{let s,i=t.split(\"/\"),r=i.length;if(i[r-1].includes(\".tmj\")||i[r-1].includes(\".json\")?(i.pop(),s=i.join(\"/\")+\"/\"):(i[r-2].includes(\".tmj\")||i[r-2].includes(\".json\"))&&(i.splice(r-2,2),s=i.join(\"/\")+\"/\"),e.tilesets&&e.tilesets.length>0){const t=[];return e.tilesets.forEach(((e,i)=>{const r=this.#p(e,s).then((e=>(this.#E(),Promise.resolve(e))));t.push(r)})),Promise.all(t).then((t=>{for(let s=0;s<t.length;s++){const i=t[s];e.tilesets[s].data=i}return Promise.resolve(e)}))}})).catch((e=>(e.message.includes(\"JSON.parse:\")&&(e=new Error(\"Can't load tilemap \"+t)),this.#f(e),Promise.reject(e)))));_loadAudio=(e,t)=>new Promise(((e,s)=>{const i=new Audio(t);i.addEventListener(\"loadeddata\",(()=>{this.#E(),e(i)})),i.addEventListener(\"error\",(()=>{const e=new Error(\"Can't load audio \"+t);this.#f(e),s(e)}))}));_loadImage=(e,t)=>new Promise(((e,s)=>{const i=new Image;i.onload=()=>{createImageBitmap(i).then((t=>{this.#E(),e(t)}))},i.onerror=()=>{const e=new Error(\"Can't load image \"+t);this.#f(e),s(e)},i.src=t}));#g(e){e.includes(\".tsj\")||e.includes(\".json\")||Exception(\"Related Tileset file type is not correct, only .tsj or .json files are supported\")}#m(e){e.includes(\".tmj\")||e.includes(\".json\")||Exception(\"Tilemap file type is not correct, only .tmj or .json files are supported\")}addFile(e,t,s){const i=this.#d.get(e);i?(this.#L(t,s),i._addFile(t,s)):Exception(\"Loader for \"+e+\" is not registered!\")}isFileInQueue(e,t){const s=this.#d.get(e);if(s)return s._isFileInQueue(t);Exception(\"Loader for \"+e+\" is not registered!\")}getFile(e,t){const s=this.#d.get(e);if(s)return s._getFile(t);Exception(\"Loader for \"+e+\" is not registered!\")}#L(e,t){const s=\"fileKey and url should be provided\";e&&0!==e.trim().length||Exception(s),t&&0!==t.trim().length||Exception(s)}#h(){let e=this.filesWaitingForUpload;this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart,{total:e}))}#c(){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load))}#E(){const e=this.filesWaitingForUpload;this.#l+=1,this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress,{lengthComputable:!0,loaded:this.#l,total:e}))}#f(e){this.#n.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.error,{error:e}))}}function Exception(e){throw new Error(e)}function Warning(e){console.warn(e)}","export class AnimationEventImageObj {\n    #eventName;\n    /**\n     * @type {Array<number>}\n     */\n    #animationSpriteIndexes;\n    /**\n     * @type {number}\n     */\n    #currentSpriteIndex;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {boolean}\n     */\n    #isRepeated;\n    \n    constructor(eventName, animationSpriteIndexes, isRepeated = false, currentSpriteIndex, isActive = false) {\n        this.#eventName = eventName;\n        this.#animationSpriteIndexes = animationSpriteIndexes;\n        this.#currentSpriteIndex = currentSpriteIndex ? currentSpriteIndex : 0;\n        this.#isActive = isActive;\n        this.#isRepeated = isRepeated;\n    }\n\n    get isActive() {\n        return this.#isActive;\n    }\n\n    get currentSprite() {\n        return this.#animationSpriteIndexes[this.#currentSpriteIndex];\n    }\n\n    get isLastSprite() {\n        return (this.#animationSpriteIndexes.length - 1) === this.#currentSpriteIndex;\n    }\n\n    iterateSprite() {\n        if (!this.isLastSprite) {\n            this.#currentSpriteIndex = this.#currentSpriteIndex + 1;\n        } else {\n            if (!this.#isRepeated) {\n                this.#isActive = false;\n            } else {\n                this.#currentSpriteIndex = 0;\n            }\n        }\n    }\n\n    activateAnimation = () => {\n        this.#isActive = true;\n        this.#currentSpriteIndex = 0;\n    };\n\n    deactivateAnimation = () => {\n        this.#isActive = false;\n    };\n}","import { RenderLayer } from \"./RenderLayer.js\";\nimport { Exception, Warning } from \"./Exception.js\";\nimport { ERROR_CODES, WARNING_CODES } from \"../constants.js\";\nimport { WebGlInterface } from \"./WebGlInterface.js\";\nimport { SystemSettings } from \"../configs.js\";\nimport { ScreenPageData } from \"./ScreenPageData.js\";\nimport AssetsManager from \"../../modules/assetsm/dist/assetsm.min.js\";\n//import { calculateBufferData } from \"../wa/release.js\";\nimport { CONST } from \"../constants.js\";\nimport { DrawImageObject } from \"./DrawImageObject.js\";\nimport { DrawCircleObject } from \"./DrawCircleObject.js\";\nimport { DrawConusObject } from \"./DrawConusObject.js\";\nimport { DrawLineObject } from \"./DrawLineObject.js\";\nimport { DrawPolygonObject } from \"./DrawPolygonObject.js\";\nimport { DrawRectObject } from \"./DrawRectObject.js\";\nimport { DrawTextObject } from \"./DrawTextObject.js\";\n\nconst INDEX_TOP_LINE = 0,\n    INDEX_RIGHT_LINE = 1,\n    INDEX_BOTTOM_LINE = 2,\n    INDEX_LEFT_LINE = 3;\n\nconst INDEX_X1 = 0,\n    INDEX_Y1 = 1,\n    INDEX_X2 = 2,\n    INDEX_Y2 = 3;\n\n/**\n * Canvas view represents each canvas on the page<br> \n * Should be created via ScreenPage.createCanvasView(),<br>\n * Contains draw logic and holds DrawObjects and Tile\n * Can retrieved by ScreenPage.getView()\n * @see {@link ScreenPage} a part of ScreenPage\n * @hideconstructor\n */\nexport class CanvasView {\n    /**\n     * @type {HTMLCanvasElement}\n     */\n    #canvas;\n    /**\n     * @type {boolean}\n     */\n    #isCleared;\n    /**\n     * @type {boolean}\n     */\n    #isOffsetTurnedOff;\n    /**\n     * @type {boolean}\n     */\n    #isWorldBoundariesEnabled;\n\n    #drawContext;\n    #webGlInterface;\n\n    /**\n     * @type {SystemSettings}\n     */\n    #systemSettings;\n    /**\n     * @type {ScreenPageData}\n     */\n    #screenPageData;\n    /**\n     * @type {AssetsManager}\n     */\n    #loader;\n\n    /**\n     * @type {Array<DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject>}\n     */\n    #renderObjects;\n    /**\n     * @type {Array<RenderLayer>}\n     */\n    #renderLayers;\n    \n    /**\n     * @type {Array<Promise>}\n     */\n    #bindTileMapPromises;\n    /**\n     * @type {Array<Promise>}\n     */\n    #bindRenderObjectPromises;\n\n    constructor(name, systemSettings, screenPageData, loader, isOffsetTurnedOff) {\n        this.#canvas = document.createElement(\"canvas\");\n        this.#canvas.id = name;\n        this.#canvas.style.position = \"absolute\";\n        this.#isCleared = false;\n        this.#isOffsetTurnedOff = isOffsetTurnedOff;\n\n        this.#screenPageData = screenPageData;\n        this.#systemSettings = systemSettings;\n        this.#loader = loader;\n        this.#renderObjects = [];\n        this.#renderLayers = [];\n\n        this.#bindTileMapPromises = [];\n        this.#bindRenderObjectPromises = [];\n        this.bindRenderLayerMethod = this.systemSettings.gameOptions.optimization === CONST.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT ? this._bindRenderLayerWM : this._bindRenderLayer;\n    }\n\n    get screenPageData() {\n        return this.#screenPageData;\n    }\n\n    get systemSettings() {\n        return this.#systemSettings;\n    }\n\n    get loader() {\n        return this.#loader;\n    }\n\n    /**\n     * a getter to retrieve all attached renderObjects\n     */\n    get renderObjects() {\n        return this.#renderObjects;\n    }\n\n    get canvas() {\n        return this.#canvas;\n    }\n\n    /**\n     * Retrieve specific objects instances\n     * @param {Object} instance - drawObjectInstance to retrieve \n     * @returns {Array<Object>}\n     */\n    getObjectsByInstance(instance) {\n        return this.#renderObjects.filter((object) => object instanceof instance);\n    }\n\n    /**\n     * @returns {Array<RenderLayer>}\n     */\n    get _renderLayers() {\n        return this.#renderLayers;\n    }\n\n    set _renderObject(object) {\n        this.#renderObjects.push(object);\n    } \n\n    set _renderObjects(objects) {\n        this.#renderObjects = objects;\n    } \n\n    /**\n     * @param {RenderLayer} layer\n     */\n    set _renderLayers(layer) {\n        this.#renderLayers.push(layer);\n    }\n\n    set _isCleared(value) {\n        this.#isCleared = value;\n    }\n\n    get _isCleared() {\n        return this.#isCleared;\n    }\n\n    _createBoundariesPrecalculations() {\n        const promises = [];\n        for (const layer of this.#renderLayers) {\n            promises.push(this.#layerBoundariesPrecalculation(layer).catch((err) => {\n                Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);\n            }));\n        }\n        return promises;\n    }\n\n    /**\n     * @ignore\n     */\n    _enableMapBoundaries() {\n        this.#isWorldBoundariesEnabled = true;\n    }\n\n    _initiateWebGlContext() {\n        const webgl = this.#canvas.getContext(\"webgl\");\n        if (webgl) {\n            this.#drawContext = webgl;\n            this.#webGlInterface = new WebGlInterface(this.#drawContext, this.#systemSettings.gameOptions.checkWebGlErrors);\n            \n            return Promise.all([this.#webGlInterface._initiateImagesDrawProgram(),\n                this.#webGlInterface._initPrimitivesDrawProgram()]);\n        } else {\n            Exception(ERROR_CODES.WEBGL_ERROR, \"webgl is not supported in this browser\");\n        }\n    }\n\n    _clearWebGlContext() {\n        this.#webGlInterface._clearView();\n        this.#isCleared = true;\n    }\n\n    _executeTileImagesDraw() {\n        return this.#webGlInterface._executeTileImagesDraw();\n    }\n\n    _setCanvasSize(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        if (this.#webGlInterface) {\n            this.#webGlInterface._fixCanvasSize(width, height);\n        }\n    }\n\n    _sortRenderObjectsByZIndex() {\n        this.#renderObjects = this.#renderObjects.sort((obj1, obj2) => obj2.zIndex - obj1.zIndex);\n    }\n\n    _prepareBindRenderLayerPromises() {\n        for (const layer of this.#renderLayers) {\n            this.#bindTileMapPromises.push(this.bindRenderLayerMethod(layer).catch((err) => {\n                Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);\n            }));\n        }\n    }\n\n    _executeBindRenderLayerPromises() {\n        return Promise.allSettled(this.#bindTileMapPromises).then((bindResults) => {\n            this.#clearTileMapPromises();\n            return Promise.resolve(bindResults);\n        });\n    }\n\n    /**\n     * \n     * @param {RenderLayer} renderLayer \n     * @returns {Promise<void>}\n     */\n    _bindRenderLayerWM(renderLayer) {\n        return new Promise((resolve, reject) => {\n            const tilemap = this.loader.getTileMap(renderLayer.tileMapKey),\n                tilesets = tilemap.tilesets,\n                tilesetImages = tilesets.map((tileset) => this.#getImage(tileset.data.name)),\n                layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                setBoundaries = false;//, //renderLayer.setBoundaries,\n                //[ worldW, worldH ] = this.screenPageData.worldDimensions,\n                //[ canvasW, canvasH ] = this.screenPageData.drawDimensions,\n                //[ xOffset, yOffset ] = this.screenPageData.worldOffset;\n                \n            if (!layerData) {\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                reject();\n            }\n            for (let i = 0; i <= tilesets.length - 1; i++) {\n                const tileset = tilesets[i].data,\n                    //tilesetImages = this.loader.getTilesetImageArray(tileset.name),\n                    tilewidth = tileset.tilewidth,\n                    tileheight = tileset.tileheight,\n                    //atlasRows = tileset.imageheight / tileheight,\n                    atlasColumns = tileset.imagewidth / tilewidth,\n                    layerCols = layerData.width,\n                    layerRows = layerData.height,\n                    //visibleCols = Math.ceil(canvasW / tilewidth),\n                    //visibleRows = Math.ceil(canvasH / tileheight),\n                    //offsetCols = layerCols - visibleCols,\n                    //offsetRows = layerRows - visibleRows,\n                    atlasImage = tilesetImages[i],\n                    atlasWidth = atlasImage.width,\n                    atlasHeight = atlasImage.height;\n                    \n                //const [verticesBufferData, texturesBufferData] = calculateBufferData(layerRows, layerCols, layerData.data, dtwidth, dtheight, tilewidth, tileheight, atlasColumns, atlasWidth, atlasHeight, setBoundaries);\n                \n                this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tileset.name);\n                if (setBoundaries) {\n                    this.screenPageData._mergeBoundaries();\n                    renderLayer.setBoundaries = false;\n                }\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * \n     * @param {RenderLayer} renderLayer \n     * @returns {Promise<void>}\n     */\n    _bindRenderLayer(renderLayer) {\n        return new Promise((resolve, reject) => {\n            const tilemap = this.loader.getTileMap(renderLayer.tileMapKey),\n                tilesets = tilemap.tilesets,\n                tilesetImages = tilesets.map((tileset) => this.#getImage(tileset.data.name)),\n                layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\n                { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                tilewidth = dtwidth,\n                tileheight = dtheight,\n                [ settingsWorldWidth, settingsWorldHeight ] = this.screenPageData.worldDimensions,\n                [ canvasW, canvasH ] = this.screenPageData.canvasDimensions,\n                [ xOffset, yOffset ] = this.#isOffsetTurnedOff === true ? [0,0] : this.screenPageData.worldOffset,\n                boundariesCalculations = this.systemSettings.gameOptions.render.boundaries.realtimeCalculations,\n                setBoundaries = renderLayer.setBoundaries && boundariesCalculations;\n                \n            let boundariesRowsIndexes = new Map(),\n                boundaries = [];\n\n            if (!layerData) {\n                Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                reject();\n            }\n            \n            for (let i = 0; i < tilesets.length; i++) {\n                const tileset = tilesets[i].data,\n                    firstgid = tilesets[i].firstgid,\n                    nextTileset = tilesets[i + 1],\n                    nextgid = nextTileset ? nextTileset.firstgid : null,\n                    tilesetwidth = tileset.tilewidth,\n                    tilesetheight = tileset.tileheight,\n                    atlasImage = tilesetImages[i],\n                    //atlasWidth = atlasImage.width,\n                    //atlasHeight = atlasImage.height,\n                    atlasWidth = tileset.imagewidth,\n                    atlasHeight = tileset.imageheight,\n                    //atlasRows = atlasHeight / tileheight,\n                    atlasColumns = Math.floor(atlasWidth / tilesetwidth),\n                    layerCols = layerData.width,\n                    layerRows = layerData.height,\n                    worldW = tilewidth * layerCols,\n                    worldH = tileheight * layerRows,\n                    moduloTop = yOffset % tileheight,\n                    moduleLeft = xOffset % tilewidth,\n                    skipRowsTop = yOffset !== 0 ? Math.floor(yOffset / tileheight) : 0,\n                    skipColsLeft = xOffset !== 0 ? Math.floor(xOffset / tilewidth) : 0,\n                    // sometimes canvasW/H may be bigger than world itself\n                    screenRows = worldH > canvasH ? Math.ceil(canvasH / tileheight) + 1 : layerRows,\n                    screenCols = worldW > canvasW ? Math.ceil(canvasW / tilewidth) + 1 : layerCols,\n                    skipColsRight = layerCols - screenCols - skipColsLeft,\n\n                    verticesBufferData = [],\n                    texturesBufferData = [];\n                if (setBoundaries) {\n                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\n                        Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\n                        this.screenPageData._setWorldDimensions(worldW, worldH);\n                    }\n                    \n                    // boundaries cleanups every draw circle, we need to set world boundaries again\n                    if (this.#isWorldBoundariesEnabled) {\n                        this.screenPageData._setMapBoundaries();\n                    }\n                }\n\n                let mapIndex = skipRowsTop * layerCols;\n\n                for (let row = 0; row < screenRows; row++) {\n                    mapIndex += skipColsLeft;\n                    let currentRowIndexes = new Map();\n\n                    for (let col = 0; col < screenCols; col++) {\n                        let tile = layerData.data[mapIndex];\n                        //if (tile !== 0)\n                        if (tile >= firstgid && (nextgid === null || tile < nextgid)) {\n                            const mapPosX = col * dtwidth - moduleLeft,\n                                mapPosY = row * dtheight - moduloTop;\n\n                            tile -= firstgid;\n                            const atlasPosX = tile % atlasColumns * tilesetwidth,\n                                atlasPosY = Math.floor(tile / atlasColumns) * tilesetheight,\n                                vecX1 = mapPosX,\n                                vecY1 = mapPosY,\n                                vecX2 = mapPosX + tilesetwidth,\n                                vecY2 = mapPosY + tilesetheight,\n                                texX1 = 1 / atlasWidth * atlasPosX,\n                                texY1 = 1 / atlasHeight * atlasPosY,\n                                texX2 = texX1 + (1 / atlasWidth * tilesetwidth),\n                                texY2 = texY1 + (1 / atlasHeight * tilesetheight);\n                            verticesBufferData.push(\n                                vecX1, vecY1,\n                                vecX2, vecY1,\n                                vecX1, vecY2,\n                                vecX1, vecY2,\n                                vecX2, vecY1,\n                                vecX2, vecY2);\n                            texturesBufferData.push(\n                                texX1, texY1,\n                                texX2, texY1,\n                                texX1, texY2,\n                                texX1, texY2,\n                                texX2, texY1,\n                                texX2, texY2\n                            );\n                            \n                            if (setBoundaries) {\n                                let rightLine = [ mapPosX + tilesetwidth, mapPosY, mapPosX + tilesetwidth, mapPosY + tilesetheight ],\n                                    bottomLine = [ mapPosX + tilesetwidth, mapPosY + tilesetheight, mapPosX, mapPosY + tilesetheight ],\n                                    topLine = [ mapPosX, mapPosY, mapPosX + tilesetwidth, mapPosY],\n                                    leftLine = [ mapPosX, mapPosY + tilesetheight, mapPosX, mapPosY ],\n                                    currentAddedCellIndexes = [null, null, null, null];\n                                \n                                const topRow = row !== 0 ? boundariesRowsIndexes.get(row - 1) : undefined;\n                                if (topRow ) {\n                                    const topCellIndexes = topRow.get(col);\n                                    if (topCellIndexes) {\n                                        //remove double lines from top\n                                        const bottomTopCellIndex = topCellIndexes[INDEX_BOTTOM_LINE],\n                                            bottomTopCell = boundaries[bottomTopCellIndex];\n                                        if (bottomTopCell) {\n                                            const bottomTopCellX1 = bottomTopCell[INDEX_X1],\n                                                bottomTopCellY1 = bottomTopCell[INDEX_Y1],\n                                                bottomTopCellX2 = bottomTopCell[INDEX_X2],\n                                                bottomTopCellY2 = bottomTopCell[INDEX_Y2],\n                                                topX1 = topLine[INDEX_X1],\n                                                topY1 = topLine[INDEX_Y1],\n                                                topX2 = topLine[INDEX_X2],\n                                                topY2 = topLine[INDEX_Y2];\n                                            \n                                            if (topX1 === bottomTopCellX2 && topY1 === bottomTopCellY2 &&\n                                                topX2 === bottomTopCellX1 && topY2 === bottomTopCellY1) {\n                                                boundaries[bottomTopCellIndex] = undefined;\n                                                topLine = undefined;\n                                            }\n                                        }\n\n                                        // merge line from top right\n                                        const rightTopCellIndex = topCellIndexes[INDEX_RIGHT_LINE],\n                                            rightTopCell = boundaries[rightTopCellIndex];\n                                        if (rightTopCell) {\n                                            const rightTopCellX1 = rightTopCell[INDEX_X1],\n                                                rightTopCellY1 = rightTopCell[INDEX_Y1],\n                                                rightTopCellX2 = rightTopCell[INDEX_X2],\n                                                rightX1 = rightLine[INDEX_X1],\n                                                rightX2 = rightLine[INDEX_X2];\n                                            if (rightTopCellX1 === rightX2 && rightTopCellX2 === rightX1) {\n                                                boundaries[rightTopCellIndex] = undefined;\n                                                rightLine[INDEX_X1] = rightTopCellX1;\n                                                rightLine[INDEX_Y1] = rightTopCellY1;\n                                            }\n                                        }\n                                        // merge line from top left\n                                        const leftTopCellIndex = topCellIndexes[INDEX_LEFT_LINE],\n                                            leftTopCell = boundaries[leftTopCellIndex];\n                                        if (leftTopCell) {\n                                            const leftTopCellX1 = leftTopCell[INDEX_X1],\n                                                leftTopCellX2 = leftTopCell[INDEX_X2],\n                                                leftTopCellY2 = leftTopCell[INDEX_Y2],\n                                                leftX1 = leftLine[INDEX_X1],\n                                                leftX2 = leftLine[INDEX_X2];\n                                            if (leftTopCellX1 === leftX2 && leftTopCellX2 === leftX1) {\n                                                boundaries[leftTopCellIndex] = undefined;\n                                                leftLine[INDEX_X2] = leftTopCellX2;\n                                                leftLine[INDEX_Y2] = leftTopCellY2;\n                                            }\n                                        }\n                                    }\n                                }\n                                const leftCellIndexes = col !== 0 ? currentRowIndexes.get(col - 1) : undefined;\n                                if (leftCellIndexes) {\n\n                                    //remove double lines from left\n                                    const rightLeftCellIndex = leftCellIndexes[INDEX_RIGHT_LINE],\n                                        rightLeftCell = boundaries[rightLeftCellIndex],\n                                        rightLeftCellX1 = rightLeftCell[INDEX_X1],\n                                        rightLeftCellY1 = rightLeftCell[INDEX_Y1],\n                                        rightLeftCellX2 = rightLeftCell[INDEX_X2],\n                                        rightLeftCellY2 = rightLeftCell[INDEX_Y2],\n                                        leftX1 = leftLine[INDEX_X1],\n                                        leftY1 = leftLine[INDEX_Y1],\n                                        leftX2 = leftLine[INDEX_X2],\n                                        leftY2 = leftLine[INDEX_Y2];\n\n                                    if (leftX1 === rightLeftCellX2 && leftY1 === rightLeftCellY2 &&\n                                        leftX2 === rightLeftCellX1 && leftY2 === rightLeftCellY1) {\n                                        boundaries[rightLeftCellIndex] = undefined;\n                                        leftLine = undefined;\n                                    }\n\n                                    //merge long lines from left top\n                                    const topLeftCellIndex = leftCellIndexes[INDEX_TOP_LINE],\n                                        topLeftCell = boundaries[topLeftCellIndex];\n                                    if (topLeftCell && topLine) {\n                                        const topLeftCellX1 = topLeftCell[INDEX_X1],\n                                            topLeftCellY1 = topLeftCell[INDEX_Y1],\n                                            topLeftCellY2 = topLeftCell[INDEX_Y2],\n                                            topY1 = topLine[INDEX_Y1],\n                                            topY2 = topLine[INDEX_Y2];\n                                        if (topLeftCellY1 === topY2 && topLeftCellY2 === topY1 ) {\n                                            boundaries[topLeftCellIndex] = undefined;\n                                            topLine[INDEX_X1] = topLeftCellX1;\n                                            topLine[INDEX_Y1] = topLeftCellY1;\n                                        }\n                                    }\n\n                                    // merge long lines from left bottom\n                                    const bottomLeftCellIndex = leftCellIndexes[INDEX_BOTTOM_LINE],\n                                        bottomLeftCell = boundaries[bottomLeftCellIndex];\n                                    if (bottomLeftCell) {\n                                        const bottomLeftCellY1 = bottomLeftCell[INDEX_Y1],\n                                            bottomLeftCellX2 = bottomLeftCell[INDEX_X2],\n                                            bottomLeftCellY2 = bottomLeftCell[INDEX_Y2],\n                                            bottomY1 = bottomLine[INDEX_Y1],\n                                            bottomY2 = bottomLine[INDEX_Y2];\n                                        if (bottomLeftCellY1 === bottomY2 && bottomLeftCellY2 === bottomY1 ) {\n                                            boundaries[bottomLeftCellIndex] = undefined;\n                                            //opposite direction\n                                            bottomLine[INDEX_X2] = bottomLeftCellX2;\n                                            bottomLine[INDEX_Y2] = bottomLeftCellY2;\n                                        }\n                                    }\n\n                                }\n\n                                if (topLine) {\n                                    boundaries.push(topLine);\n                                    currentAddedCellIndexes[INDEX_TOP_LINE] = boundaries.length - 1;\n                                }\n                                boundaries.push(rightLine);\n                                currentAddedCellIndexes[INDEX_RIGHT_LINE] = boundaries.length - 1;\n                                boundaries.push(bottomLine);\n                                currentAddedCellIndexes[INDEX_BOTTOM_LINE] = boundaries.length - 1;\n                                if (leftLine) {\n                                    boundaries.push(leftLine);\n                                    currentAddedCellIndexes[INDEX_LEFT_LINE] = boundaries.length - 1;\n                                }\n                                //save values indexes cols info\n                                currentRowIndexes.set(col, currentAddedCellIndexes);\n                            }\n\n                        }\n                        mapIndex++;\n                    }\n                    if (currentRowIndexes.size > 0) {\n                        //save values indexes rows info\n                        boundariesRowsIndexes.set(row, currentRowIndexes);\n                    }\n                    mapIndex += skipColsRight;\n                }\n                if (verticesBufferData.length > 0 && texturesBufferData.length > 0) {\n                    this.#bindTileImages(verticesBufferData, texturesBufferData, atlasImage, tileset.name);\n                }\n            }\n            \n            if (setBoundaries) {\n                // filter undefined value\n                const filtered = boundaries.filter(array => array);\n                this.screenPageData._addBoundariesArray(filtered);\n            }\n            resolve();\n        });\n    }\n    \n    _prepareBindRenderObjectPromises() {\n        for (let i = 0; i < this.#renderObjects.length; i++) {\n            const object = this.#renderObjects[i];\n            if (object.isRemoved) {\n                this.#renderObjects.splice(i, 1);\n                i--;\n            }\n            //if (object.isAnimations) {\n            //    object._processActiveAnimations();\n            //}\n            const promise = this.#bindRenderObject(object).catch((err) => {\n                Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, err);\n                return Promise.reject(err);\n            });\n            this.#bindRenderObjectPromises.push(promise);\n        }\n    }\n\n    _prepareBindBoundariesPromise() {\n        this.#bindRenderObjectPromises.push(this.#drawBoundariesWebGl().catch((err) => {\n            Exception(ERROR_CODES.UNHANDLED_PREPARE_EXCEPTION, err);\n        }));\n    }\n\n    _executeBindRenderObjectPromises () {\n        return Promise.allSettled(this.#bindRenderObjectPromises).then((bindResults) => {\n            this.#clearRenderObjectPromises();\n            return Promise.resolve(bindResults);\n        });\n    }\n\n    _postRenderActions() {\n        const images = this.getObjectsByInstance(DrawImageObject);\n        for (let i = 0; i < images.length; i++) {\n            const object = images[i];\n            if (object.isAnimations) {\n                object._processActiveAnimations();\n            }\n        }\n    }\n\n    #getImage(key) {\n        return this.loader.getImage(key);\n    }\n\n    #bindTileImages(verticesBufferData, texturesBufferData,  atlasImage, image_name, drawMask, rotation, translation) {\n        this.#webGlInterface._bindTileImages(verticesBufferData, texturesBufferData, atlasImage, image_name, drawMask, rotation, translation);\n    }\n\n    #clearTileMapPromises() {\n        this.#bindTileMapPromises = [];\n    }\n\n    /**\n     * \n     * @param {RenderLayer} renderLayer \n     * @returns {Promise<void>}\n     */\n    #layerBoundariesPrecalculation(renderLayer) {\n        return new Promise((resolve, reject) => {\n            if (renderLayer.setBoundaries) {\n                const tilemap = this.loader.getTileMap(renderLayer.tileMapKey),\n                    tilesets = tilemap.tilesets,\n                    layerData = tilemap.layers.find((layer) => layer.name === renderLayer.layerKey),\n                    { tileheight:dtheight, tilewidth:dtwidth } = tilemap,\n                    tilewidth = dtwidth,\n                    tileheight = dtheight,\n                    [ settingsWorldWidth, settingsWorldHeight ] = this.screenPageData.worldDimensions;\n                \n                let boundaries = [];\n\n                if (!layerData) {\n                    Warning(WARNING_CODES.NOT_FOUND, \"check tilemap and layers name\");\n                    reject();\n                }\n                \n                for (let i = 0; i < tilesets.length; i++) {\n                    const layerCols = layerData.width,\n                        layerRows = layerData.height,\n                        worldW = tilewidth * layerCols,\n                        worldH = tileheight * layerRows;\n\n                    if (worldW !== settingsWorldWidth || worldH !== settingsWorldHeight) {\n                        Warning(WARNING_CODES.UNEXPECTED_WORLD_SIZE, \" World size from tilemap is different than settings one, fixing...\");\n                        this.screenPageData._setWorldDimensions(worldW, worldH);\n                    }\n                    \n                    if (this.#isWorldBoundariesEnabled) {\n                        this.screenPageData._setWholeWorldMapBoundaries();\n                    }\n\n                    //calculate boundaries\n                    let mapIndex = 0;\n\n                    for (let row = 0; row < layerRows; row++) {\n                        for (let col = 0; col < layerCols; col++) {\n                            let tile = layerData.data[mapIndex],\n                                mapPosX = col * tilewidth,\n                                mapPosY = row * tileheight;\n                            if (tile !== 0) {\n                                tile -= 1;\n                                \n                                boundaries.push([mapPosX, mapPosY, mapPosX + tilewidth, mapPosY]);\n                                boundaries.push([mapPosX + tilewidth, mapPosY, mapPosX + tilewidth, mapPosY + tileheight]);\n                                boundaries.push([mapPosX + tilewidth, mapPosY + tileheight, mapPosX, mapPosY + tileheight]);\n                                boundaries.push([mapPosX, mapPosY + tileheight, mapPosX, mapPosY ]);\n    \n                            }\n                            mapIndex++;\n                        }\n                    }\n                }\n                this.screenPageData._setWholeMapBoundaries(boundaries);\n                this.screenPageData._mergeBoundaries(true);\n                console.warn(\"precalculated boundaries set\");\n                console.log(this.screenPageData.getWholeWorldBoundaries());\n                resolve();\n            } else {\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * \n     * @param {DrawImageObject | DrawCircleObject | DrawConusObject | DrawLineObject | DrawPolygonObject | DrawRectObject | DrawTextObject} renderObject \n     * @returns {Promise<void>}\n     */\n    #bindRenderObject(renderObject) {\n        return new Promise((resolve) => {\n            const [ xOffset, yOffset ] = this.#isOffsetTurnedOff === true ? [0,0] : this.screenPageData.worldOffset,\n                x = renderObject.x - xOffset,\n                y = renderObject.y - yOffset;\n\n            if (renderObject.type === CONST.DRAW_TYPE.IMAGE) {\n                const atlasImage = this.#getImage(renderObject.key),\n                    animationIndex = renderObject.imageIndex;\n                let imageX = 0,\n                    imageY = 0;\n                if (animationIndex !== 0) {\n                    const imageColsNumber = atlasImage.width / renderObject.width;\n                    imageX = animationIndex % imageColsNumber * renderObject.width,\n                    imageY = Math.floor(animationIndex / imageColsNumber) * renderObject.height;\n                }\n                const posX = x - renderObject.width / 2,\n                    posY = y - renderObject.height / 2;\n                const vecX1 = posX,\n                    vecY1 = posY,\n                    vecX2 = vecX1 + renderObject.width,\n                    vecY2 = vecY1 + renderObject.height,\n                    texX1 = 1 / atlasImage.width * imageX,\n                    texY1 = 1 / atlasImage.height * imageY,\n                    texX2 = texX1 + (1 / atlasImage.width * renderObject.width),\n                    texY2 = texY1 + (1 / atlasImage.height * renderObject.height);\n                const verticesBufferData = [\n                        vecX1, vecY1,\n                        vecX2, vecY1,\n                        vecX1, vecY2,\n                        vecX1, vecY2,\n                        vecX2, vecY1,\n                        vecX2, vecY2\n                    ],\n                    texturesBufferData = [\n                        texX1, texY1,\n                        texX2, texY1,\n                        texX1, texY2,\n                        texX1, texY2,\n                        texX2, texY1,\n                        texX2, texY2\n                    ];\n                this.#webGlInterface._bindAndDrawTileImages(verticesBufferData, texturesBufferData, atlasImage, renderObject.key, renderObject.rotation, [x, y]);\n                if (renderObject.vertices && this.systemSettings.gameOptions.boundaries.drawObjectBoundaries) {\n                    const shiftX = x,// - renderObject.boundaries[0],\n                        shiftY = y,// - renderObject.boundaries[1],\n                        rotation = renderObject.rotation ? renderObject.rotation : 0;\n                    this.#webGlInterface._drawPolygon(renderObject.vertices, this.systemSettings.gameOptions.boundaries.boundariesColor, this.systemSettings.gameOptions.boundaries.boundariesWidth, rotation, [shiftX, shiftY]);\n                }\n                //ctx.restore();\n            } else if (renderObject.type === CONST.DRAW_TYPE.TEXT) {\n                this.#webGlInterface._bindText(x, y, renderObject);\n            } else if (renderObject.type === CONST.DRAW_TYPE.CIRCLE || renderObject.type === CONST.DRAW_TYPE.CONUS) {\n                this.#webGlInterface._bindConus(renderObject, renderObject.rotation, [x, y]);\n            } else if (renderObject.type === CONST.DRAW_TYPE.LINE) {\n                this.#webGlInterface._drawLines(renderObject.vertices, renderObject.bgColor, this.systemSettings.gameOptions.boundariesWidth, renderObject.rotation, [x, y]);\n            } else {\n                this.#webGlInterface._bindPrimitives(renderObject, renderObject.rotation, [x, y]);\n            }\n            return resolve();\n        });\n    }\n\n    #clearRenderObjectPromises() {\n        this.#bindRenderObjectPromises = [];\n    }\n\n    /**\n     * \n     * @returns {Promise<void>}\n     */\n    #drawBoundariesWebGl() {\n        return new Promise((resolve) => {\n            const b = this.screenPageData.getBoundaries(),\n                len = b.length,\n                linesArray = [];\n        \n            for (let i = 0; i < len; i++) {\n                const item = b[i];\n                linesArray.push(item[0], item[1]);\n                linesArray.push(item[2], item[3]);\n            }\n            this.#webGlInterface._drawLines(linesArray, this.systemSettings.gameOptions.boundaries.boundariesColor, this.systemSettings.gameOptions.boundaries.boundariesWidth);\n            resolve();\n        });\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Conus object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawCircleObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #radius;\n\n    /**\n     * @type {Array<number>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, radius, bgColor, cut) {\n        super(CONST.DRAW_TYPE.CIRCLE, x, y, bgColor, cut);\n        this.#radius = radius;\n        this.#vertices = this._calculateConusVertices(radius);\n    }\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get radius() {\n        return this.#radius;\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Conus object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawConusObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #radius;\n\n    /**\n     * @type {number}\n     */\n    #angle;\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    #vertices;\n    #fade_min;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, radius, bgColor, angle, cut, fade = 0) {\n        super(CONST.DRAW_TYPE.CONUS, x, y, bgColor, cut);\n        this.#radius = radius;\n        this.#angle = angle;\n        this.#fade_min = fade;\n        this.#vertices = this._calculateConusVertices(radius, angle);\n    }\n\n    /**\n     * Array of [x,y] cords.\n     * @type {Array<number>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get radius() {\n        return this.#radius;\n    }\n\n    /**\n     * @type {number}\n     */\n    get angle() {\n        return this.#angle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get fade_min() {\n        return this.#fade_min;\n    }\n\n    /**\n     * @param {number} value - fade start pos in px\n     */\n    set fade_min(value) {\n        this.#fade_min = value;\n    }\n}","import { AnimationEventImageObj } from \"./AnimationEventImageObj.js\";\nimport { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n/**\n * Image object to draw\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawImageObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #w;\n    /**\n     * @type {number}\n     */\n    #h;\n    /**\n     * Image sprite key\n     * @type {string}\n     */\n    #key;\n    /**\n     * @type {EventTarget}\n     */\n    #emitter;\n    /**\n     * @type {Map<string, AnimationEventImageObj>}\n     */\n    #animations;\n    /**\n     * @type {number}\n     */\n    #imageIndex;\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(mapX, mapY, width, height, key, imageIndex = 0, boundaries) {\n        super(CONST.DRAW_TYPE.IMAGE, mapX, mapY);\n        this.#key = key;\n        this.#emitter = new EventTarget();\n        this.#animations = new Map();\n        this.#imageIndex = imageIndex;\n        this.#w = width;\n        this.#h = height;\n        this.#vertices = boundaries ? this._convertVerticesArray(boundaries) : this._calculateRectVertices(width, height);\n    }\n\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n\n    set width(w) {\n        this.#w = w;\n    }\n\n    set height(h) {\n        this.#h = h;\n    }\n\n    /**\n     * A key should match an image loaded through AssetsManager\n     * @type {string}\n     */\n    get key() {\n        return this.#key;\n    }\n\n    /**\n     * Current image index\n     * @type {number}\n     */\n    get imageIndex() {\n        return this.#imageIndex;\n    }\n\n    set imageIndex(value) {\n        this.#imageIndex = value;\n    }\n\n    /**\n     * Determines if image is animated or not\n     * @type {boolean}\n     */\n    get isAnimations() {\n        return this.#animations.size > 0;\n    }\n\n    /**\n     * @deprecated - use .vertices instead \n     * @type {Array<Array<number>>}\n     */\n    get boundaries() {\n        return this.#vertices;\n    }\n\n    get vertices() {\n        return this.#vertices;\n    }\n\n    /**\n     * @ignore\n     */\n    _processActiveAnimations() {\n        for (let animationEvent of this.#animations.values()) {\n            if (animationEvent.isActive) {\n                animationEvent.iterateSprite();\n                this.#imageIndex = animationEvent.currentSprite;\n            }\n        }\n    }\n\n    /**\n     * Emit event\n     * @param {string} eventName \n     * @param  {...any} eventParams \n     */\n    emit(eventName, ...eventParams) {\n        const event = new Event(eventName);\n        event.data = [...eventParams];\n        this.#emitter.dispatchEvent(event);\n    }\n\n    /**\n     * Subscribe\n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*} options \n     */\n    addEventListener(eventName, listener, options) {\n        this.#emitter.addEventListener(eventName, listener, options);\n    }\n\n    /**\n     * Unsubscribe\n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*} options \n     */\n    removeEventListener(eventName, listener, options) {\n        this.#emitter.removeEventListener(eventName, listener, options);\n    }\n\n    /**\n     * Adds image animations\n     * @param { string } eventName -animation name\n     * @param { Array<number> } animationSpriteIndexes - animation image indexes\n     * @param { boolean } [isRepeated = false] - animation is circled or not, circled animation could be stopped only with stopRepeatedAnimation();\n     */\n    addAnimation (eventName, animationSpriteIndexes, isRepeated) {\n        const animationEvent = new AnimationEventImageObj(eventName, animationSpriteIndexes, isRepeated);\n        this.#animations.set(eventName, animationEvent);\n        this.addEventListener(eventName, this.#activateAnimation);\n    }\n\n    #activateAnimation = (event) => {\n        const animationEvent = this.#animations.get(event.type);\n        animationEvent.activateAnimation();\n        this.#imageIndex = animationEvent.currentSprite;\n    }; \n\n    /**\n     *\n     * @param {string} eventName - animation name\n     */\n    stopRepeatedAnimation (eventName) {\n        this.#animations.get(eventName).deactivateAnimation();\n    }\n\n    /**\n     * Removes animations\n     */\n    removeAllAnimations() {\n        for (let [eventName, animationEvent] of this.#animations.entries()) {\n            this.removeEventListener(eventName, animationEvent.activateAnimation);\n            animationEvent.deactivateAnimation();\n        }\n        this.#animations.clear();\n        this.#animations = undefined;\n    }\n\n    destroy() {\n        this.removeAllAnimations();\n        super.destroy();\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * Line object to draw.\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawLineObject extends DrawShapeObject {\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(vertices, bgColor) {\n        super(CONST.DRAW_TYPE.LINE, vertices[0][0], vertices[0][1], bgColor);\n        this.#vertices = vertices;\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n}","import { DrawRectObject } from \"./DrawRectObject.js\";\nimport { DrawTextObject } from \"./DrawTextObject.js\";\nimport { DrawConusObject } from \"./DrawConusObject.js\";\nimport { DrawImageObject } from \"./DrawImageObject.js\";\nimport { DrawLineObject } from \"./DrawLineObject.js\";\nimport { DrawPolygonObject } from \"./DrawPolygonObject.js\";\nimport { DrawCircleObject } from \"./DrawCircleObject.js\";\n\n/**\n * Creates drawObjects instances.<br>\n * accessible via ScreenPage.draw <br>\n * @see {@link ScreenPage} a part of ScreenPage\n */\nexport class DrawObjectFactory {\n\n    /**\n     * @param {number} x \n     * @param {number} y \n     * @param {number} width \n     * @param {number} height \n     * @param {string} backgroundColor - rgba(r,g,b,a)\n     * @param {boolean=} cut\n     * @returns {DrawRectObject}\n     */\n    rect(x, y, width, height, backgroundColor, cut) {\n        return new DrawRectObject(x, y, width, height, backgroundColor, cut); \n    }\n\n    /**\n     * @param {number} x \n     * @param {number} y \n     * @param {string} text \n     * @param {string} font - size fontFamily\n     * @param {string} color - rgba(r,g,b,a)\n     * @returns {DrawTextObject}\n     */\n    text(x, y, text, font, color) {\n        return new DrawTextObject(x, y, text, font, color);\n    }\n\n    /**\n     * \n     * @param {number} radius \n     * @param {string} bgColor - rgba(r,g,b,a)\n     * @param {number=} angle\n     * @param {boolean=} [cut=false]\n     * @param {number=} [fade=0] (0 - 1)\n     * @returns {DrawConusObject}\n     */\n    conus(x, y, radius, bgColor, angle, cut=false, fade = 0) {\n        return new DrawConusObject(x, y, radius, bgColor, angle, cut, fade);\n    }\n\n    /**\n     * \n     * @param {number} radius \n     * @param {string} bgColor - rgba(r,g,b,a)\n     * @param {boolean=} cut\n     * @returns {DrawCircleObject}\n     */\n    circle(x, y, radius, bgColor, cut) {\n        return new DrawCircleObject(x, y, radius, bgColor, cut);\n    }\n\n    /**\n     * @param {number} x \n     * @param {number} y \n     * @param {number} width \n     * @param {number} height \n     * @param {string} key \n     * @param {number} [imageIndex = 0]\n     * @param {Array<{x:Number, y:Number}>=} boundaries \n     * @returns {DrawImageObject}\n     */\n    image(x, y, width, height, key, imageIndex = 0, boundaries) {\n        return new DrawImageObject(x, y, width, height, key, imageIndex, boundaries);\n    }\n\n    /**\n     * @param {Array<number>} vertices \n     * @param {string} color - rgba(r,g,b,a)\n     * @returns {DrawLineObject}\n     */\n    line(vertices, color) {\n        return new DrawLineObject(vertices, color);\n    }\n\n    /**\n     * @param {Array<{x:number, y:number}>} vertices - should go in anticlockwise order\n     * @param {string} bgColor - rgba(r,g,b,a) \n     * @param {boolean=} cut\n     * @returns {DrawPolygonObject}\n     */\n    polygon(vertices, bgColor, cut) {\n        return new DrawPolygonObject(vertices, bgColor, cut);\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawPolygonObject extends DrawShapeObject {\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(vertices, bgColor, cut) {\n        super(CONST.DRAW_TYPE.POLYGON, vertices[0].x, vertices[0].y, bgColor, cut);\n        this.#vertices = this._convertVerticesArray(vertices);\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n\n    set vertices(value) {\n        this.#vertices = value;\n    }\n}","import { CONST } from \"../constants.js\";\nimport { DrawShapeObject } from \"./DrawShapeObject.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawRectObject extends DrawShapeObject {\n    /**\n     * @type {number}\n     */\n    #w;\n    /**\n     * @type {number}\n     */\n    #h;\n    /**\n     * @type {Array<Array<number>>}\n     */\n    #vertices;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(x, y, w, h, bgColor, cut) {\n        super(CONST.DRAW_TYPE.RECTANGLE, x, y, bgColor, cut);\n        this.#w = w;\n        this.#h = h;\n        this.#vertices = this._calculateRectVertices(w,h);\n    }\n\n    /**\n     * @type {Array<Array<number>>}\n     */\n    get vertices () {\n        return this.#vertices;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n\n    set width(w) {\n        this.#w = w;\n    }\n\n    set height(h) {\n        this.#h = h;\n    }\n}","import { CONST } from \"../constants.js\";\nimport { utils } from \"../index.js\";\n\n/**\n * A base draw object.\n */\nexport class DrawShapeObject {\n    #x;\n    #y;\n    #bg;\n    /**\n     * @type {string}\n     * @enum {CONST.DRAW_TYPE}\n     */\n    #type;\n    #cut;\n    /**\n     * Is used for blending pixel arithmetic\n     * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/blendFunc.\n     * @type {Array<number>}\n     */\n    #blendFunc;\n    \n    /**\n     * @type {number}\n     */\n    #zIndex = 0;\n    /**\n     * @type {number}\n     */\n    #rotation = 0;\n    /**\n     * @type {number}\n     */\n    #id = utils.generateUniqId();\n    /**\n     * @type {boolean}\n     */\n    #isRemoved = false;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(type, mapX, mapY, bgColor, cut) {\n        this.#x = mapX;\n        this.#y = mapY;\n        this.#bg = bgColor;\n        this.#type = type;\n        this.#cut = cut;\n    }\n\n    /**\n     * Background color as rgba(r,g,b,a).\n     * @type {string}\n     */\n    get bgColor() {\n        return this.#bg;\n    }\n\n    set bgColor(value) {\n        this.#bg = value;\n    }\n\n    /**\n     * @type {string}\n     * @enum {CONST.DRAW_TYPE}\n     */\n    get type() {\n        return this.#type;\n    }\n\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n\n    /**\n     * @type {number}\n     */\n    get y () {\n        return this.#y;\n    }\n\n    set x(posX) {\n        this.#x = posX;\n    }\n\n    set y(posY) {\n        this.#y = posY;\n    }\n\n    /**\n     * @type {boolean}\n     */\n    get cut() {\n        return this.#cut;\n    }\n\n    /**\n     * @type {number}\n     */\n    get zIndex () {\n        return this.#zIndex;\n    }\n\n    set zIndex(value) {\n        this.#zIndex = value;\n    }\n\n    get blendFunc () {\n        return this.#blendFunc;\n    }\n\n    set blendFunc(value) {\n        this.#blendFunc = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get rotation() {\n        return this.#rotation;\n    }\n\n    set rotation(value) {\n        this.#rotation = value;\n    }\n\n    /**\n     * @type {number}\n     */\n    get id() {\n        return this.#id;\n    }\n\n    /**\n     * @type {boolean}\n     */\n    get isRemoved() {\n        return this.#isRemoved;\n    }\n\n    /**\n     * Destroy object on next render iteration.\n     */\n    destroy() {\n        this.#isRemoved = true;\n    }\n\n    /**\n     * @param {number} width \n     * @param {number} height \n     * @returns {Array<Array<number>>}\n     */\n    _calculateRectVertices = (width, height) => {\n        const halfW = width/2,\n            halfH = height/2;\n        return [[-halfW, -halfH], [halfW, -halfH], [halfW, halfH], [-halfW, halfH]];\n    };\n\n    /**\n     * @param {number} radius \n     * @param {number} [angle = 2 * Math.PI]\n     * @param {number} [step = Math.PI/12] \n     * @returns {Array<number>}\n     * @ignore\n     */\n    _calculateConusVertices(radius, angle = 2*Math.PI, step = Math.PI/14) {\n        let conusPolygonCoords = [0, 0];\n\n        for (let r = 0; r <= angle; r += step) {\n            let x2 = Math.cos(r) * radius,\n                y2 = Math.sin(r) * radius;\n\n            conusPolygonCoords.push(x2, y2);\n        }\n\n        return conusPolygonCoords;\n    }\n\n    /**\n     * @param {Array<Array<number>> | Array<{x:number, y:number}>} boundaries\n     * @returns {Array<Array<number>>}\n     * @ignore\n     */\n    _convertVerticesArray(boundaries) {\n        if (typeof boundaries[0].x !== \"undefined\" && typeof boundaries[0].y !== \"undefined\") {\n            return utils.verticesArrayToArrayNumbers(boundaries);\n        } else {\n            return boundaries;\n        }\n    }\n}","import { DrawShapeObject } from \"./DrawShapeObject.js\";\nimport { Rectangle } from \"./Primitives.js\";\nimport { CONST } from \"../constants.js\";\n\n/**\n * @extends DrawShapeObject\n * @see {@link DrawObjectFactory} should be created with factory method\n */\nexport class DrawTextObject extends DrawShapeObject {\n    #font;\n    #textAlign;\n    #textBaseline;\n    #fillStyle;\n    #strokeStyle;\n    #text;\n    #textMetrics;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(mapX, mapY, text, font, fillStyle) {\n        super(CONST.DRAW_TYPE.TEXT, mapX, mapY);\n        this.#text = text;\n        this.#font = font;\n        this.#fillStyle = fillStyle;\n        this.#textMetrics;\n    }\n\n    /**\n     * Rectangle text box.\n     * @type {Rectangle}\n     */\n    get boundariesBox() {\n        const width = this.textMetrics ? this.textMetrics.width : 300,\n            height = this.textMetrics ? this.textMetrics.actualBoundingBoxAscent + /*this.textMetrics.actualBoundingBoxDescent*/ 5: 30;\n        return new Rectangle(this.x, this.y - height, width, height);\n    }\n\n    get vertices() {\n        const bb = this.boundariesBox;\n        return this._calculateRectVertices(bb.width, bb.height);\n    }\n\n    /**\n     * @type {string}\n     */\n    get text() {\n        return this.#text;\n    }\n\n    set text(value) {\n        this.#text = value;\n    }\n\n    /**\n     * @type {string}\n     */\n    get font() {\n        return this.#font;\n    }\n\n    set font(value) {\n        this.#font = value;\n    }\n\n    /**\n     * @type {string}\n     */\n    get textAlign() {\n        return this.#textAlign;\n    }\n\n    set textAlign(value) {\n        this.#textAlign = value;\n    }\n\n    /**\n     * @type {string}\n     */\n    get textBaseline() {\n        return this.#textBaseline;\n    }\n\n    set textBaseline(value) {\n        this.#textBaseline = value;\n    }\n\n    /**\n     * @type {string}\n     */\n    get fillStyle() {\n        return this.#fillStyle;\n    }\n\n    set fillStyle(value) {\n        this.#fillStyle = value;\n    }\n\n    /**\n     * @type {string}\n     */\n    get strokeStyle() {\n        return this.#strokeStyle;\n    }\n\n    set strokeStyle(value) {\n        this.#strokeStyle = value;\n    }\n\n    /**\n     * @type {TextMetrics}\n     */\n    get textMetrics() {\n        return this.#textMetrics;\n    }\n\n    set _textMetrics(value) {\n        this.#textMetrics = value;\n    }\n}","import { CONST, ERROR_CODES } from \"../../constants.js\";\nimport { Exception } from \"../Exception.js\";\n\nexport class SystemEvent extends Event {\n    #data;\n    constructor(eventValue, data){\n        super(eventValue);\n        if (!this.#isEventExist(eventValue)) {\n            Exception(ERROR_CODES.UNEXPECTED_EVENT_NAME, \", Please check if event is exist\");\n        }\n        this.#data = data;\n    }\n\n    #isEventExist(eventValue) {\n        return Object.values(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT).find(eventVal => eventVal === eventValue);\n    }\n\n    get data () {\n        return this.#data;\n    }\n}","export function Exception (code, message) {\n    throw new Error(code + \": \" + message);\n}\n\nexport function Warning (code, message) {\n    console.warn(code, message);\n}","import { SystemSettings } from \"../configs.js\";\nimport { CONST } from \"../constants.js\";\n\nexport class Logger {\n    static debug(...args) {\n        if (SystemSettings.mode === CONST.MODE.DEBUG)\n            args.forEach(message => console.log(message));\n    }\n}","class Vertex {\n    #x;\n    #y;\n    constructor(x, y) {\n        this.#x = x;\n        this.#y = y;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n}\n\nclass Rectangle {\n    #x;\n    #y;\n    #w;\n    #h;\n    constructor(x, y, w, h) {\n        this.#x = x;\n        this.#y = y;\n        this.#w = w;\n        this.#h = h; \n    }\n    /**\n     * @type {number}\n     */\n    get x() {\n        return this.#x;\n    }\n    /**\n     * @type {number}\n     */\n    get y() {\n        return this.#y;\n    }\n    /**\n     * @type {number}\n     */\n    get width() {\n        return this.#w;\n    }\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this.#h;\n    }\n}\n\nclass Vector {\n    #x;\n    #y;\n    constructor(x1, y1, x2, y2) {\n        this.#x = x2 - x1;\n        this.#y = y2 - y1;\n    }\n\n    get x() {\n        return this.#x;\n    }\n\n    get y() {\n        return this.#y;\n    }\n\n    get length() {\n        return Math.sqrt(Math.pow(this.#x, 2) + Math.pow(this.#y, 2));\n    }\n\n    get tetaAngle() {\n        return Math.atan2(this.#y, this.#x);\n    }\n}\n\nexport { Vertex, Rectangle, Vector };","export class RenderLayer {\n    #layerKey;\n    #tileMapKey;\n    #setBoundaries;\n    #drawBoundaries;\n\n    constructor(layerKey, tileMapKey, setBoundaries = false) {\n        this.#layerKey = layerKey;\n        this.#tileMapKey = tileMapKey;\n        this.#setBoundaries = setBoundaries;\n        this.#drawBoundaries = setBoundaries ? setBoundaries : false;\n    }\n\n    /**\n     * A layer name.\n     * @type {string}\n     */\n    get layerKey() {\n        return this.#layerKey;\n    }\n\n    /**\n     * A tilemap layer key, should match key from the tilemap.\n     * @type {string}\n     */\n    get tileMapKey() {\n        return this.#tileMapKey;\n    }\n\n    /**\n     * Should the layer borders used as boundaries, or not\n     * Can be set in ScreenPage.addRenderLayer() method.\n     * @type {boolean}\n     */\n    get setBoundaries() {\n        return this.#setBoundaries;\n    }\n\n    /**\n     * Should draw a boundaries helper, or not\n     * Can be set in SystemSettings.\n     * @type {boolean}\n     */\n    get drawBoundaries() {\n        return this.#drawBoundaries;\n    }\n\n    set drawBoundaries(value) {\n        this.#drawBoundaries = value;\n    }\n}\n","import { CONST, ERROR_CODES, WARNING_CODES } from \"../constants.js\";\nimport { ScreenPageData } from \"./ScreenPageData.js\";\nimport { Exception, Warning } from \"./Exception.js\";\nimport { Logger } from \"./Logger.js\";\nimport AssetsManager from \"../../modules/assetsm/dist/assetsm.min.js\";\nimport { RenderLayer } from \"./RenderLayer.js\";\nimport { CanvasView } from \"./CanvasView.js\";\nimport { DrawObjectFactory } from \"./DrawObjectFactory.js\";\nimport { DrawCircleObject } from \"./DrawCircleObject.js\";\nimport { DrawConusObject } from \"./DrawConusObject.js\";\nimport { DrawImageObject } from \"./DrawImageObject.js\";\nimport { DrawLineObject } from \"./DrawLineObject.js\";\nimport { DrawPolygonObject } from \"./DrawPolygonObject.js\";\nimport { DrawRectObject } from \"./DrawRectObject.js\";\nimport { DrawTextObject } from \"./DrawTextObject.js\";\nimport { SystemInterface } from \"./SystemInterface.js\";\nimport { SystemAudioInterface } from \"./SystemAudioInterface.js\";\nimport { SystemSettings } from \"../configs.js\";\nimport { isPointLineIntersect, isPolygonLineIntersect, angle_2points } from \"../utils.js\";\nimport { Vector } from \"./Primitives.js\";\n\n/**\n * Represents the page of the game,<br>\n * Register and holds CanvasView.<br>\n * Contains pages logic.<br>\n * Instances should be created and registered with System.registerPage() factory method\n * \n * @see {@link System} instances of this class holds by the System class\n * @hideconstructor\n */\nexport class ScreenPage {\n    /**\n     * @type {string}\n     */\n    #name;\n    /**\n     * @type {boolean}\n     */\n    #isInitiated = false;\n    /**\n     * @type {boolean}\n     */\n    #isActive;\n    /**\n     * @type {SystemInterface}\n     */\n    #system;\n    /**\n     * @type {Map<String, CanvasView>}\n     */\n    #views;\n    /**\n     * @type {ScreenPageData}\n     */\n    #screenPageData;\n    /**\n     * @type {DrawObjectFactory}\n     */\n    #drawObjectFactory = new DrawObjectFactory();\n    /**\n     * @type {Array<number>}\n     */\n    #tempFPStime;\n    /**\n     * @type {NodeJS.Timer}\n     */\n    #fpsAverageCountTimer;\n    /**\n     * @type {EventTarget}\n     */\n    #emitter = new EventTarget();\n    /**\n     * @type {boolean}\n     */\n    #isBoundariesPrecalculations = false;\n    #minCircleTime;\n\n    constructor() {\n        this.#isActive = false;\n        this.#views = new Map();\n        this.#screenPageData = new ScreenPageData();\n        this.#tempFPStime = [];\n    }\n\n    /**\n     * \n     * @param {string} eventName \n     * @param  {...any} eventParams \n     */\n    emit = (eventName, ...eventParams) => {\n        const event = new Event(eventName);\n        event.data = [...eventParams];\n        this.#emitter.dispatchEvent(event);\n    };\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    addEventListener = (eventName, listener, options) => {\n        this.#emitter.addEventListener(eventName, listener, options);\n    };\n\n    /**\n     * \n     * @param {string} eventName \n     * @param {*} listener \n     * @param {*=} options \n     */\n    removeEventListener = (eventName, listener, options) => {\n        this.#emitter.removeEventListener(eventName, listener, options);\n    };\n\n    /**\n     * Register stage\n     * @param {string} name\n     * @param {SystemInterface} system \n     * @ignore\n     */\n    _register(name, system) {\n        this.#name = name;\n        this.#system = system;\n        this.#isBoundariesPrecalculations = this.systemSettings.gameOptions.render.boundaries.wholeWorldPrecalculations;\n        this.#minCircleTime = this.systemSettings.gameOptions.render.minCircleTime;\n        this.#setWorldDimensions();\n        this.#setCanvasSize();\n        this.register();\n    }\n\n    /**\n     * Initialization stage\n     * @ignore\n     */\n    _init() {\n        this.init();\n        this.#isInitiated = true;\n    }\n\n    /**\n     * @tutorial screen_pages_stages\n     * Custom logic for register stage\n     */\n    register() {}\n    /**\n     * @tutorial screen_pages_stages\n     * Custom logic for init stage\n     */\n    init() {}\n    /**\n     * Custom logic for start stage\n     * @param {Object=} options\n     */\n    start(options) {}\n    /**\n     * @tutorial screen_pages_stages\n     * Custom logic for stop stage\n     */\n    stop() {}\n    /**\n     * Custom logic for resize stage\n     */\n    resize() {}\n\n    /**\n     * @tutorial assets_manager\n     * @type {AssetsManager}\n     */\n    get loader() {\n        return this.#system.loader;\n    }\n\n    /**\n     * @type {DrawObjectFactory}\n     */\n    get draw() {\n        return this.#drawObjectFactory;\n    }\n\n    /**\n     * Creates new canvas layer\n     * and set it to the #views\n     * @param {string} name\n     * @param {boolean} [isOffsetTurnedOff = false] - determines if offset is affected on this layer or not\n     */\n    createCanvasView = (name, isOffsetTurnedOff = false) => {\n        if (name && name.trim().length > 0) {\n            const newView = new CanvasView(name, this.#system.systemSettings, this.#screenPageData, this.loader, isOffsetTurnedOff);\n            this.#views.set(name, newView);\n        } else\n            Exception(ERROR_CODES.UNEXPECTED_INPUT_PARAMS);\n    };\n\n    /**\n     * Attach all canvas elements from the #views to container\n     * @param {HTMLElement} container\n     * @ignore\n     */\n    _attachViewsToContainer(container) {\n        for (const view of this.#views.values()) {\n            this.#attachElementToContainer(view.canvas, container);\n        }\n    }\n\n    /**\n     * Add render object to the view\n     * @param {string} canvasKey \n     * @param { DrawConusObject | DrawImageObject | \n     *          DrawLineObject | DrawPolygonObject | \n     *          DrawRectObject | DrawCircleObject | \n     *          DrawTextObject } renderObject \n     */\n    addRenderObject = (canvasKey, renderObject) => {\n        if (!canvasKey) {\n            Exception(ERROR_CODES.CANVAS_KEY_NOT_SPECIFIED, \", should pass canvasKey as 3rd parameter\");\n        } else if (!this.#views.has(canvasKey)) {\n            Exception(ERROR_CODES.CANVAS_WITH_KEY_NOT_EXIST, \", should create canvas view, with \" + canvasKey + \" key first\");\n        } else {\n            const view = this.#views.get(canvasKey);\n            view._renderObject = renderObject;\n            view._sortRenderObjectsByZIndex();\n        }\n    };\n\n    /**\n     * Add render layer to the view\n     * @param {string} canvasKey \n     * @param {string} layerKey \n     * @param {string} tileMapKey \n     * @param {boolean=} setBoundaries \n     */\n    addRenderLayer = (canvasKey, layerKey, tileMapKey, setBoundaries) => {\n        if (!canvasKey) {\n            Exception(ERROR_CODES.CANVAS_KEY_NOT_SPECIFIED, \", should pass canvasKey as 3rd parameter\");\n        } else if (!this.#views.has(canvasKey)) {\n            Exception(ERROR_CODES.CANVAS_WITH_KEY_NOT_EXIST, \", should create canvas view, with \" + canvasKey + \" key first\");\n        } else {\n            const view = this.#views.get(canvasKey);\n            view._renderLayers = new RenderLayer(layerKey, tileMapKey, setBoundaries);\n            if (setBoundaries && this.systemSettings.gameOptions.render.boundaries.mapBoundariesEnabled) {\n                view._enableMapBoundaries();\n            }\n        }\n    };\n\n    /**\n     * Determines if this page render is Active or not\n     * @type {boolean}\n     */\n    get isActive() {\n        return this.#isActive;\n    }\n\n    /**\n     * Determines if this page is initialized or not\n     * @type {boolean}\n     */\n    get isInitiated() {\n        return this.#isInitiated;\n    }\n\n    /**\n     * Current page name\n     * @type {string}\n     */\n    get name () {\n        return this.#name;\n    }\n\n    /**\n     * Determines if all added files was loaded or not\n     * @returns {boolean}\n     */\n    isAllFilesLoaded = () => {\n        return this.loader.filesWaitingForUpload === 0;\n    };\n\n    /**\n     * @type {ScreenPageData}\n     */\n    get screenPageData() {\n        return this.#screenPageData;\n    }\n\n    /**\n     * @type {SystemSettings}\n     */\n    get systemSettings() {\n        return this.#system.systemSettings;\n    }\n\n    /**\n     * @type {SystemAudioInterface}\n     */\n    get audio() {\n        return this.#system.audio;\n    }\n\n    /**\n     * @type {SystemInterface}\n     */\n    get system() {\n        return this.#system;\n    }\n\n    /**\n     * @method\n     * @param {string} key \n     * @returns {CanvasView | undefined}\n     */\n    getView = (key) => {\n        const ctx = this.#views.get(key);\n        if (ctx) {\n            return this.#views.get(key);\n        } else {\n            Exception(ERROR_CODES.CANVAS_WITH_KEY_NOT_EXIST, \", cannot find canvas with key \" + key);\n        }\n    };\n\n    /**\n     * Start page render\n     * @param {Object=} options \n     * @ignore\n     */\n    _start(options) {\n        this.#isActive = true;\n        window.addEventListener(\"resize\", this._resize);\n        this._resize();\n        if (this.#views.size > 0) {\n            requestAnimationFrame(this.#render);\n        }\n        this.emit(CONST.EVENTS.SYSTEM.START_PAGE);\n        this.start(options);\n    }\n\n    /**\n     * Stop page render\n     * @ignore\n     */\n    _stop() {\n        this.#isActive = false;\n        window.removeEventListener(\"resize\", this._resize);\n        this.emit(CONST.EVENTS.SYSTEM.STOP_PAGE);\n        this.#removeCanvasFromDom();\n        clearInterval(this.#fpsAverageCountTimer);\n        this.stop();\n    }\n\n    /**\n     * Resize event\n     * @ignore\n     */\n    _resize = () => {\n        this.#setCanvasSize();\n        this.resize();\n    };\n\n    /**\n     * \n     * @param {HTMLCanvasElement} htmlElement \n     * @param {HTMLElement} container \n     */\n    #attachElementToContainer(htmlElement, container) {\n        container.appendChild(htmlElement);\n    }\n\n    #removeCanvasFromDom() {\n        for (const view of this.#views.values()) {\n            document.getElementById(view.canvas.id).remove();\n        }\n    }\n\n    #setWorldDimensions() {\n        const width = this.systemSettings.worldSize ? this.systemSettings.worldSize.width : 0,\n            height = this.systemSettings.worldSize ? this.systemSettings.worldSize.height : 0;\n            \n        this.screenPageData._setWorldDimensions(width, height);\n    }\n\n    #isPolygonToObjectsCollision(x, y, polygonVertices, polygonRotation, objects) {\n        const len = objects.length;\n        let collisions = [];\n        for (let i = 0; i < len; i++) {\n            const mapObject = objects[i],\n                drawMapObjectType = mapObject.type;\n\n            let coll;\n            \n            switch(drawMapObjectType) {\n            case CONST.DRAW_TYPE.TEXT:\n            case CONST.DRAW_TYPE.RECTANGLE:\n            case CONST.DRAW_TYPE.CONUS:\n            case CONST.DRAW_TYPE.IMAGE:\n                coll = this.#isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject);\n                break;\n            case CONST.DRAW_TYPE.CIRCLE:\n                console.warn(\"isObjectCollision.circle check is not implemented yet!\");\n                break;\n            case CONST.DRAW_TYPE.LINE:\n                console.warn(\"isObjectCollision.line check is not implemented, please use rect instead\");\n                break;\n            default:\n                console.warn(\"unknown object type!\");\n            }\n            if (coll) {\n                collisions.push(coll);\n            }\n        }\n        if (collisions.length > 0) {\n            return this.#takeTheClosestCollision(collisions);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * @param {number} x\n     * @param {number} y\n     * @param {Array<Array<number>>} polygon\n     * @param {number} rotation \n     * @returns {{x:number, y:number, p:number} | boolean}\n     */\n    #isPolygonToBoundariesCollision(x, y, polygon, rotation) {\n        //console.log(\"angle: \", rotation);\n        //console.log(\"boundaries before calculations: \");\n        //console.log(polygon);\n        const mapObjects = this.screenPageData.getBoundaries(),\n            [mapOffsetX, mapOffsetY] = this.screenPageData.worldOffset,\n            xWithOffset = x - mapOffsetX,\n            yWithOffset = y - mapOffsetY,\n            polygonWithOffsetAndRotation = polygon.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, rotation))),\n            len = mapObjects.length;\n            \n        for (let i = 0; i < len; i+=1) {\n            const item = mapObjects[i];\n            const object = {\n                    x1: item[0],\n                    y1: item[1],\n                    x2: item[2],\n                    y2: item[3]\n                },\n                intersect = isPolygonLineIntersect(polygonWithOffsetAndRotation, object);\n            if (intersect) {\n                //console.log(\"rotation: \", rotation);\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\n                //console.log(\"intersect: \", intersect);\n                return intersect;\n            }\n        }\n        return false;\n    }\n\n    #takeTheClosestCollision(collisions) {\n        return collisions.sort((a,b) => a.p < b.p)[0];\n    }\n\n    #isPolygonToPolygonCollision(x, y, polygonVertices, polygonRotation, mapObject) {\n        const [mapOffsetX, mapOffsetY] = this.screenPageData.worldOffset,\n            xWithOffset = x - mapOffsetX,\n            yWithOffset = y - mapOffsetY,\n            mapObjXWithOffset = mapObject.x - mapOffsetX,\n            mapObjYWithOffset = mapObject.y - mapOffsetY,\n            mapObjVertices = mapObject.vertices, \n            mapObjRotation = mapObject.rotation,\n            polygonWithOffsetAndRotation = polygonVertices.map((vertex) => (this.#calculateShiftedVertexPos(vertex, xWithOffset, yWithOffset, polygonRotation))),\n            len = mapObjVertices.length;\n        //console.log(\"map object check:\");\n        //console.log(mapObject);\n        for (let i = 0; i < len; i+=1) {\n            const mapObjFirstVertex = mapObjVertices[i];\n            let mapObjNextVertex = mapObjVertices[i + 1];\n            if (!mapObjNextVertex) {\n                mapObjNextVertex = mapObjVertices[0];\n            }\n            const vertex = this.#calculateShiftedVertexPos(mapObjFirstVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\n                nextVertex = this.#calculateShiftedVertexPos(mapObjNextVertex, mapObjXWithOffset, mapObjYWithOffset, mapObjRotation),\n                edge = {\n                    x1: vertex[0],\n                    y1: vertex[1],\n                    x2: nextVertex[0],\n                    y2: nextVertex[1]\n                },\n                intersect = isPolygonLineIntersect(polygonWithOffsetAndRotation, edge);\n            if (intersect) {\n                //console.log(\"polygon: \", polygonWithOffsetAndRotation);\n                //console.log(\"intersect: \", intersect);\n                return intersect;\n            }\n        }\n        return false;\n    }\n\n    #calculateShiftedVertexPos(vertex, centerX, centerY, rotation) {\n        const vector = new Vector(0, 0, vertex[0], vertex[1]),\n            vertexAngle = angle_2points(0, 0, vertex[0], vertex[1]),\n            len = vector.length;\n        //console.log(\"coords without rotation: \");\n        //console.log(x + vertex.x);\n        //console.log(y + vertex.y);\n        //console.log(\"len: \", len);\n        //console.log(\"angle: \", rotation);\n        const newX = centerX + (len * Math.cos(rotation + vertexAngle)),\n            newY = centerY + (len * Math.sin(rotation + vertexAngle));\n        return [newX, newY];\n    }\n\n    /**\n     * \n     * @param {number} x \n     * @param {number} y \n     * @param {DrawImageObject} drawObject \n     * @returns {{x:number, y:number, p:number} | boolean}\n     */\n    isBoundariesCollision = (x, y, drawObject) => {\n        const drawObjectType = drawObject.type,\n            vertices = drawObject.vertices;\n        switch(drawObjectType) {\n        case CONST.DRAW_TYPE.TEXT:\n        case CONST.DRAW_TYPE.RECTANGLE:\n        case CONST.DRAW_TYPE.CONUS:\n        case CONST.DRAW_TYPE.IMAGE:\n            return this.#isPolygonToBoundariesCollision(x, y, vertices, drawObject.rotation);\n        case CONST.DRAW_TYPE.CIRCLE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\n            break;\n        case CONST.DRAW_TYPE.LINE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\n            break;\n        default:\n            Warning(CONST.WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\n        }\n        return false;\n    };\n\n    /**\n     * \n     * @param {number} x \n     * @param {number} y \n     * @param {DrawImageObject} drawObject\n     * @param {Array<DrawImageObject>} objects - objects array to check\n     * @returns {{x:number, y:number, p:number} | boolean} - the closest collision\n     */\n    isObjectsCollision = (x, y, drawObject, objects) => {\n        const drawObjectType = drawObject.type,\n            drawObjectBoundaries = drawObject.vertices;\n        switch(drawObjectType) {\n        case CONST.DRAW_TYPE.TEXT:\n        case CONST.DRAW_TYPE.RECTANGLE:\n        case CONST.DRAW_TYPE.CONUS:\n        case CONST.DRAW_TYPE.IMAGE:\n            return this.#isPolygonToObjectsCollision(x, y, drawObjectBoundaries, drawObject.rotation, objects);\n        case CONST.DRAW_TYPE.CIRCLE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.circle check is not implemented yet!\");\n            break;\n        case CONST.DRAW_TYPE.LINE:\n            Warning(CONST.WARNING_CODES.METHOD_NOT_IMPLEMENTED, \"isObjectCollision.line check is not implemented yet, please use .rect instead line!\");\n            break;\n        default:\n            Warning(CONST.WARNING_CODES.UNKNOWN_DRAW_OBJECT, \"unknown object type!\");\n        }\n        return false;\n    };\n\n    #checkCollisions(renderObjects) {\n        const boundaries = this.screenPageData.getBoundaries(),\n            boundariesLen = boundaries.length,\n            objectsLen = renderObjects.length;\n        //console.log(this.screenPageData.worldOffset);\n        for (let i = 0; i < objectsLen; i++) {\n            const renderObject = renderObjects[i];\n            for (let j = 0; j < objectsLen; j++) {\n                if (i === j) {\n                    continue;\n                }\n                // const renderObjectCheck = renderObjects[j];\n                // check object - object collisions\n            }\n\n            for (let k = 0; k < boundariesLen; k+=1) {\n                const item = boundaries[k],\n                    object = {\n                        x1: item[0],\n                        y1: item[1],\n                        x2: item[2],\n                        y2: item[3]\n                    };\n                const objectBoundaries = object.boundaries;\n                if (objectBoundaries) {\n                    if (isPolygonLineIntersect(objectBoundaries, object)) {\n                        this.emit(CONST.EVENTS.GAME.BOUNDARIES_COLLISION, renderObject);\n                    }\n                } else {\n                    if (isPointLineIntersect({ x: renderObject.x, y: renderObject.y }, object)) {\n                        this.emit(CONST.EVENTS.GAME.BOUNDARIES_COLLISION, renderObject);\n                        console.log(\"boundaries collision detected\");\n                    }\n                }\n            }\n        }\n    }\n\n    #setCanvasSize() {\n        const canvasWidth = this.systemSettings.canvasMaxSize.width && (this.systemSettings.canvasMaxSize.width < window.innerWidth) ? this.systemSettings.canvasMaxSize.width : window.innerWidth,\n            canvasHeight = this.systemSettings.canvasMaxSize.height && (this.systemSettings.canvasMaxSize.height < window.innerHeight) ? this.systemSettings.canvasMaxSize.height : window.innerHeight;\n        this.screenPageData._setCanvasDimensions(canvasWidth, canvasHeight);\n        for (const view of this.#views.values()) {\n            view._setCanvasSize(canvasWidth, canvasHeight);\n        }\n    }\n\n    #countFPSaverage() {\n        const timeLeft = this.systemSettings.gameOptions.render.averageFPStime,\n            steps = this.#tempFPStime.length;\n        let fullTime = 0;\n\n        for(let i = 0; i < steps; i++) {\n            const timeStep = this.#tempFPStime[i];\n            fullTime += timeStep;\n        }\n        console.log(\"FPS average for \", timeLeft/1000, \"sec, is \", fullTime / steps);\n\n        // cleanup\n        this.#tempFPStime = [];\n    }\n\n    #render = async (/*time*/) => {\n        Logger.debug(\"_render \" + this.name + \" class\");\n        if (this.#isActive) {\n            switch (this.systemSettings.gameOptions.library) {\n            case CONST.LIBRARY.WEBGL:\n                if (this.isAllFilesLoaded()) {\n                    //render\n                    await this.#prepareViews();\n                } else {\n                    Warning(WARNING_CODES.ASSETS_NOT_READY, \"Is page initialization phase missed?\");\n                    this.#isActive = false;\n                }\n                // wait for the end of the execution stack, before start next iteration\n                setTimeout(() => requestAnimationFrame(this.#drawViews));\n                break;\n            }\n            this.#fpsAverageCountTimer = setInterval(() => this.#countFPSaverage(), this.systemSettings.gameOptions.render.averageFPStime);\n        }\n    };\n\n    /**\n     * \n     * @returns {Promise<void>}\n     */\n    #prepareViews() {\n        return new Promise((resolve, reject) => {\n            let viewPromises = [];\n            const isBoundariesPrecalculations = this.#isBoundariesPrecalculations;\n            for (const view of this.#views.values()) {\n                viewPromises.push(view._initiateWebGlContext());\n                if (isBoundariesPrecalculations) {\n                    viewPromises.push(view._createBoundariesPrecalculations());\n                }\n            }\n            Promise.allSettled(viewPromises).then((drawingResults) => {\n                drawingResults.forEach((result) => {\n                    if (result.status === \"rejected\") {\n                        const error = result.reason;\n                        Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, error);\n                        reject(error);\n                    }\n                });\n                resolve();\n            });\n        });\n    }\n\n    #drawViews = (/*drawTime*/) => {\n        const pt0 = performance.now(),\n            minCircleTime = this.#minCircleTime;\n            \n        let viewPromises = [];\n        this.emit(CONST.EVENTS.SYSTEM.RENDER.START);\n        this.screenPageData._clearBoundaries();\n\n        for (const [key, view] of this.#views.entries()) {\n            viewPromises.push(this.#executeRender(key, view));\n        }\n        Promise.allSettled(viewPromises).then((drawingResults) => {\n            drawingResults.forEach((result) => {\n                if (result.status === \"rejected\") {\n                    Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, result.reason);\n                }\n            });\n            const r_time = performance.now() - pt0,\n                r_time_less = minCircleTime - r_time,\n                wait_time = r_time_less > 0 ? r_time_less : 0,\n                fps = 1000 / (r_time + wait_time);\n            //console.log(\"draw circle done, take: \", (r_time), \" ms\");\n            //console.log(\"fps: \", fps);\n            this.emit(CONST.EVENTS.SYSTEM.RENDER.END);\n            this.#tempFPStime.push(fps);\n            if (this.#isActive) {\n                setTimeout(() => requestAnimationFrame(this.#drawViews), wait_time);\n            }\n        });\n    };\n\n    /**\n     * \n     * @param {string} key \n     * @param {CanvasView} view \n     * @returns {Promise<void>}\n     */\n    #executeRender (key, view) {\n        return new Promise((resolve, reject) => {\n            if (!view._isCleared) {\n                view._clearWebGlContext();\n            }\n            if (view._renderLayers.length !== 0) {\n                view._prepareBindRenderLayerPromises();\n            }\n            view._executeBindRenderLayerPromises()\n                .then((bindResults) => {\n                    bindResults.forEach((result) => {\n                        if (result.status === \"rejected\") {\n                            Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, result.reason);\n                            this.#isActive = false;\n                            return reject(WARNING_CODES.UNHANDLED_DRAW_ISSUE + \", reason: \" + result.reason);\n                        }\n                    });\n                    return view._executeTileImagesDraw();\n                })\n                .then(() => {\n                    if (view.renderObjects.length !== 0) {\n                        //this.#checkCollisions(view.renderObjects);\n                        view._prepareBindRenderObjectPromises();\n                    }\n                    if (key === CONST.LAYERS.BOUNDARIES) {\n                        view._prepareBindBoundariesPromise();\n                    }\n                    return view._executeBindRenderObjectPromises();\n                })\n                .then((bindResults) => {\n                    bindResults.forEach((result) => {\n                        if (result.status === \"rejected\") {\n                            Warning(WARNING_CODES.UNHANDLED_DRAW_ISSUE, result.reason);\n                            this.#isActive = false;\n                        }\n                    });\n\n                    view._postRenderActions();\n                    \n                    view._isCleared = false;\n                    resolve();\n                });\n        });\n    }\n}","import { WARNING_CODES } from \"../constants.js\";\nimport { Warning } from \"./Exception.js\";\n/**\n * An interface for common views data such as\n * boundaries, world dimensions, options\n * accessible via ScreenPage.screenPageData \n * @see {@link ScreenPage} a part of ScreenPage\n * @hideconstructor\n */\nexport class ScreenPageData {\n    #worldWidth;\n    #worldHeight;\n    #viewWidth;\n    #viewHeight;\n    #xOffset = 0;\n    #yOffset = 0;\n    #centerX = 0;\n    #centerY = 0;\n    #rotate = 0;\n    /**\n     * current screen boundaries, recalculated every render circle\n     * @type {Array<Array<number>>}\n     */\n    #boundaries = [];\n\n    /**\n     * whole world boundaries, calculated once on prepare stage\n     * @type {Array<Array<number>>}\n     */\n    #wholeWorldBoundaries = [];\n\n    /**\n     * Add a Boundaries line\n     * @param {{x1:number,y1:number,x2:number, y2:number}} boundaries \n     */\n    #addBoundaries(boundaries) {\n        this.#boundaries.push([boundaries.x1, boundaries.y1, boundaries.x2, boundaries.y2]);\n    }\n\n    /**\n     * Add array of boundaries lines\n     * @param {Array<Array<number>>} boundaries \n     * @ignore\n     */\n    _addBoundariesArray(boundaries) {\n        this.#boundaries.push(...boundaries);\n    }\n\n    /**\n     * Clear map boundaries\n     * @ignore\n     */\n    _clearBoundaries() {\n        this.#boundaries = [];\n    }\n\n    /**\n     * \n     * @param {number} width \n     * @param {number} height \n     * @ignore\n     */\n    _setWorldDimensions(width, height) {\n        this.#worldWidth = width;\n        this.#worldHeight = height;\n    }\n\n    set mapRotate(value) {\n        this.#rotate = value;\n    }\n\n    /**\n     * \n     * @param {number} width \n     * @param {number} height \n     * @ignore\n     */\n    _setCanvasDimensions(width, height) {\n        this.#viewWidth = width;\n        this.#viewHeight = height;\n    }\n\n    /**\n     * Set map borders\n     * @ignore\n     */\n    _setMapBoundaries() {\n        const [w, h] = [this.#worldWidth, this.#worldHeight];\n        if (!w || !h) {\n            Warning(WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map boundaries.\");\n        }\n        this.#addBoundaries({x1: 0, y1: 0, x2: w, y2: 0});\n        this.#addBoundaries({x1: w, y1: 0, x2: w, y2: h});\n        this.#addBoundaries({x1: w, y1: h, x2: 0, y2: h});\n        this.#addBoundaries({x1: 0, y1: h, x2: 0, y2: 0});\n    }\n\n    _setWholeWorldMapBoundaries() {\n        const [w, h] = [this.#worldWidth, this.#worldHeight];\n        if (!w || !h) {\n            Warning(WARNING_CODES.WORLD_DIMENSIONS_NOT_SET, \"Can't set map boundaries.\");\n        }\n        this.#wholeWorldBoundaries.push([0, 0, w, 0]);\n        this.#wholeWorldBoundaries.push([w, 0, w, h]);\n        this.#wholeWorldBoundaries.push([w, h, 0, h]);\n        this.#wholeWorldBoundaries.push([0, h, 0, 0]);\n    }\n\n    /**\n     * Merge same boundaries\n     * @ignore\n     */\n    _mergeBoundaries(isWholeMapBoundaries = false) {\n        const boundaries = isWholeMapBoundaries ? this.getWholeWorldBoundaries() : this.getBoundaries(),\n            boundariesSet = new Set(boundaries);\n        for (const line of boundariesSet.values()) {\n            const lineX1 = line[0],\n                lineY1 = line[1],\n                lineX2 = line[2],\n                lineY2 = line[3];\n            for (const line2 of boundariesSet.values()) {\n                const line2X1 = line2[0],\n                    line2Y1 = line2[1],\n                    line2X2 = line2[2],\n                    line2Y2 = line2[3];\n                if (lineX1 === line2X2 && lineY1 === line2Y2 &&\n                    lineX2 === line2X1 && lineY2 === line2Y1) {\n                    //remove double lines\n                    boundariesSet.delete(line);\n                    boundariesSet.delete(line2);\n                }\n                if (lineX2 === line2X1 && lineY2 === line2Y1 && (lineX1 === line2X2 || lineY1 === line2Y2)) {\n                    //merge lines\n                    line2[0] = lineX1;\n                    line2[1] = lineY1;\n                    boundariesSet.delete(line);\n                }\n            }\n        }\n\n        if (isWholeMapBoundaries) {\n            this.#boundaries = Array.from(boundariesSet);\n        } else {\n            this.#wholeWorldBoundaries = Array.from(boundariesSet);\n        }\n        boundariesSet.clear();\n    }\n\n    _setWholeMapBoundaries(boundaries) {\n        this.#wholeWorldBoundaries.push(...boundaries);\n    }\n\n    /**\n     * \n     * @returns {Array<Array<number>>}\n     */\n    getBoundaries() {\n        return this.#boundaries;\n    }\n\n    getWholeWorldBoundaries() {\n        return this.#wholeWorldBoundaries;\n    }\n    /**\n     * @type {Array<number>}\n     */\n    get canvasDimensions() {\n        return [this.#viewWidth, this.#viewHeight];\n    }\n\n    /**\n     * @type {Array<number>}\n     */\n    get worldDimensions() {\n        return [this.#worldWidth, this.#worldHeight];\n    }\n    \n    /**\n     * @type {Array<number>}\n     */\n    get worldOffset() {\n        return [this.#xOffset, this.#yOffset];\n    }\n\n    /**\n     * @type {Array<number>}\n     */\n    get mapCenter() {\n        return [this.#centerX, this.#centerY];\n    }\n\n    /**\n     * @type {number}\n     */\n    get mapRotate() {\n        return this.#rotate;\n    }\n\n    /**\n     * @method\n     * @param {number} x \n     * @param {number} y \n     */\n    centerCameraPosition = (x, y) => {\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\n            [mapWidth, mapHeight] = this.worldDimensions,\n            halfScreenWidth = canvasWidth/2,\n            halfScreenHeight = canvasHeight/2,\n            currentCenterX = halfScreenWidth - mapOffsetX,\n            currentCenterY = halfScreenHeight - mapOffsetY;\n        if (currentCenterX < x) {\n            if (x < mapWidth - halfScreenWidth) {\n                const newXOffset = x - halfScreenWidth;\n                if (newXOffset >= 0)\n                    this.#xOffset = Math.round(newXOffset);\n            } else if (mapWidth > canvasWidth) {\n                const newXOffset = mapWidth - canvasWidth;\n                this.#xOffset = Math.round(newXOffset);\n            }\n        }\n        if (currentCenterY < y) {\n            if (y < mapHeight - halfScreenHeight) {\n                const newYOffset = y - halfScreenHeight;\n                if (newYOffset >= 0)\n                    this.#yOffset = Math.round(newYOffset);\n            } else if (mapHeight > canvasHeight) {\n                const newYOffset = mapHeight - canvasHeight;\n                this.#yOffset = Math.round(newYOffset);\n            }\n        }\n\n        this.#centerX = x;\n        this.#centerY = y;\n        //Logger.debug(\"center camera position, offset: \", this.worldOffset);\n        //Logger.debug(\"center: \", this.mapCenter);   \n    };\n\n    personRotatedCenterCamera = (x, y, rotationAngle) => {\n        console.log(\"new centering algorithm\");\n        /*\n        let [mapOffsetX, mapOffsetY] = this.worldOffset;\n        const [canvasWidth, canvasHeight] = this.canvasDimensions,\n            [mapWidth, mapHeight] = this.worldDimensions,\n            halfScreenWidth = canvasWidth/2,\n            halfScreenHeight = canvasHeight/2,\n            currentCenterX = halfScreenWidth - mapOffsetX,\n            currentCenterY = halfScreenHeight - mapOffsetY;\n        if (currentCenterX < x) {\n            if (x < mapWidth - halfScreenWidth) {\n                const newXOffset = x - halfScreenWidth;\n                if (newXOffset >= 0)\n                    this.#xOffset = Math.round(newXOffset);\n            } else if (mapWidth > canvasWidth) {\n                const newXOffset = mapWidth - canvasWidth;\n                this.#xOffset = Math.round(newXOffset);\n            }\n        }\n        if (currentCenterY < y) {\n            if (y < mapHeight - halfScreenHeight) {\n                const newYOffset = y - halfScreenHeight;\n                if (newYOffset >= 0)\n                    this.#yOffset = Math.round(newYOffset);\n            } else if (mapHeight > canvasHeight) {\n                const newYOffset = mapHeight - canvasHeight;\n                this.#yOffset = Math.round(newYOffset);\n            }\n        }\n\n        this.#centerX = x;\n        this.#centerY = y;\n        Logger.debug(\"center camera position, offset: \", this.worldOffset);\n        Logger.debug(\"center: \", this.mapCenter);   \n        */\n    };\n}","import { ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { ScreenPage } from \"./ScreenPage.js\";\nimport { SystemInterface } from \"./SystemInterface.js\";\nimport { SystemSettings } from \"../configs.js\";\n\nimport { LoadingScreen } from \"../design/LoadingScreen.js\";\n\nconst loadingPageName = \"loadingPage\";\n/**\n * A main app class, <br>\n * Holder class for ScreenPage,<br>\n * can register new ScreenPages,<br>\n * init and preload data for them,<br>\n */\nexport class System {\n    #registeredPages;\n    #system;\n    /**\n     * @param {SystemSettings} systemSettings - holds system settings\n     * @param {HTMLElement} [canvasContainer] - If it is not passed, system will create div element and attach it to body\n     */\n    constructor(systemSettings, canvasContainer) {\n        if (!systemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\n        }\n        this.#registeredPages = new Map();\n\n        if (!canvasContainer) {\n            canvasContainer = document.createElement(\"div\");\n            document.body.appendChild(canvasContainer);\n        }\n\n        this.#system = new SystemInterface(systemSettings, canvasContainer, this.#registeredPages);\n        \n        this.registerPage(loadingPageName, LoadingScreen);\n\n        this.#system.loader.addEventListener(\"loadstart\", this.#loadStart);\n        this.#system.loader.addEventListener(\"progress\", this.#loadProgress);\n        this.#system.loader.addEventListener(\"load\", this.#loadComplete);\n    }\n\n    /**\n     * @type {SystemInterface}\n     */\n    get system() {\n        return this.#system;\n    }\n\n    /**\n     * A main factory method for create ScreenPage instances, <br>\n     * register them in a System and call ScreenPage.register() stage\n     * @param {string} screenPageName\n     * @param {ScreenPage} screen \n     */\n    registerPage(screenPageName, screen) {\n        if (screenPageName && typeof screenPageName === \"string\" && screenPageName.trim().length > 0) {\n            const page = new screen();\n            page._register(screenPageName, this.system);\n            this.#registeredPages.set(screenPageName, page);\n        } else {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"valid class name should be provided\");\n        }\n    }\n\n    /**\n     * Preloads assets for all registered pages\n     * @return {Promise<void>}\n     */\n    preloadAllData() {\n        return this.#system.loader.preload();\n    }\n\n    #loadStart = (event) => {\n        this.#system.startScreenPage(loadingPageName, {total: event.total});\n    };\n\n    #loadProgress = (event) => {\n        const uploaded = event.loaded,\n            left = event.total,\n            loadingPage = this.#registeredPages.get(loadingPageName);\n            \n        loadingPage._progress(uploaded, left);\n    };\n\n    #loadComplete = () => {\n        this.#system.stopScreenPage(loadingPageName);\n    };\n}","import AssetsManager from  \"../../modules/assetsm/dist/assetsm.min.js\";\nimport { WARNING_CODES } from \"../constants.js\";\nimport { Warning } from \"./Exception.js\";\n\n/**\n * An audio interface, <br>\n * controls all application audio,<br>\n * holds and retrieves audio, changes volume<br> \n * accessible via ScreenPage.audio\n * @see {@link ScreenPage} a part of ScreenPage\n * @hideconstructor\n */\nexport class SystemAudioInterface {\n    #volume = 0.5;\n    #audio = new Map();\n    /**\n     * @type {AssetsManager}\n     */\n    #loader;\n\n    constructor(loader) {\n        this.#loader = loader;\n    }\n\n    /**\n     * Original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudio = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            Warning(WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            return audio;\n        } else {\n            Warning(WARNING_CODES.AUDIO_NOT_REGISTERED, \"\");\n            return null;\n        }\n    };\n\n    /**\n     * Clone of original track\n     * @param {string} name \n     * @returns {HTMLAudioElement | null}\n     */\n    getAudioCloned = (name) => {\n        const audio = this.#audio.get(name);\n        if (audio === null) {\n            Warning(WARNING_CODES.AUDIO_NOT_LOADED, \"Audio with key \" + name + \" exists, but not actually loaded\");\n            return audio;\n        }\n        if (audio) {\n            const audioCloned = audio.cloneNode();\n            audioCloned.volume = this.#volume;\n            return audioCloned;\n        } else {\n            Warning(WARNING_CODES.AUDIO_NOT_REGISTERED);\n            return null;\n        }\n    };\n\n    set volume(value) {\n        this.#volume = value;\n        this.#updateTracksVolumes(value);\n    }\n    /**\n     * Used to set or get audio volume, \n     * value should be from 0 to 1\n     * @type {number}\n     */\n    get volume() {\n        return this.#volume;\n    }\n\n    #updateTracksVolumes(value) {\n        for (const track of this.#audio.values()) {\n            if (track) {\n                track.volume = value;\n            }\n        }\n    }\n\n    /**\n     * Register audio in the system\n     * @param {string} name\n     */\n    registerAudio(name) {\n        let mediaElement = this.#loader.getAudio(name);\n        this.#audio.set(name, mediaElement);\n    }\n}","import { ERROR_CODES } from \"../constants.js\";\r\nimport { Exception } from \"./Exception.js\";\r\nimport { SystemSocketConnection } from \"./SystemSocketConnection.js\";\r\nimport { SystemAudioInterface } from \"./SystemAudioInterface.js\";\r\nimport { SystemSettings } from \"../configs.js\";\r\nimport AssetsManager from \"../../modules/assetsm/dist/assetsm.min.js\";\r\n/**\r\n * Public interface for a System<br>\r\n * Can be used to start/stop ScreenPage render, <br>\r\n * And provides access to SystemSettings, SystemSocketConnection and SystemAudioInterface <br>\r\n * accessible via ScreenPage.system and System.system\r\n * @see {@link System} a part of System class instance\r\n * @see {@link ScreenPage} a part of ScreenPage class instance\r\n */\r\nexport class SystemInterface {\r\n    #systemSettings;\r\n    #canvasContainer;\r\n    #registeredPages;\r\n    #systemServerConnection;\r\n    #systemAudioInterface;\r\n    #loader;\r\n    /**\r\n     * @hideconstructor\r\n     */\r\n    constructor(systemSettings, canvasContainer, registeredPages) {\r\n        if (!systemSettings) {\r\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\r\n        }\r\n        this.#systemSettings = systemSettings;\r\n        this.#canvasContainer = canvasContainer;\r\n        this.#registeredPages = registeredPages;\r\n        this.#loader = new AssetsManager();\r\n        this.#systemAudioInterface = new SystemAudioInterface(this.loader);\r\n        this.#systemServerConnection = new SystemSocketConnection(systemSettings);\r\n    }\r\n\r\n    /**\r\n     * @type { SystemSocketConnection }\r\n     */\r\n    get network () {\r\n        return this.#systemServerConnection;\r\n    }\r\n\r\n    /**\r\n     * @type { SystemSettings }\r\n     */\r\n    get systemSettings() {\r\n        return this.#systemSettings;\r\n    }\r\n\r\n    /**\r\n     * @type { SystemAudioInterface }\r\n     */\r\n    get audio() {\r\n        return this.#systemAudioInterface;\r\n    }\r\n\r\n    get loader() {\r\n        return this.#loader;\r\n    }\r\n\r\n    /**\r\n     * @method\r\n     * @param {string} screenPageName\r\n     * @param {Object} [options] - options\r\n     */\r\n    startScreenPage = (screenPageName, options) => {\r\n        if (this.#registeredPages.has(screenPageName)) {\r\n            const page = this.#registeredPages.get(screenPageName);\r\n            if (page.isInitiated === false) {\r\n                page._init();\r\n            }\r\n            page._attachViewsToContainer(this.#canvasContainer);\r\n            page._start(options);\r\n        } else {\r\n            Exception(ERROR_CODES.VIEW_NOT_EXIST, \"View \" + screenPageName + \" is not registered!\");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @method\r\n     * @param {string} screenPageName\r\n     */\r\n    stopScreenPage = (screenPageName) => {\r\n        if (this.#registeredPages.has(screenPageName)) {\r\n            this.#registeredPages.get(screenPageName)._stop();\r\n        } else {\r\n            Exception(ERROR_CODES.VIEW_NOT_EXIST, \"View \" + screenPageName + \" is not registered!\");\r\n        }\r\n    };\r\n}","import { CONST, ERROR_CODES } from \"../constants.js\";\nimport { Exception } from \"./Exception.js\";\nimport { Logger } from \"./Logger.js\";\nimport { SystemEvent } from \"./Events/SystemEvent.js\";\n\n/**\n * Represents Socket connection\n */\nexport class SystemSocketConnection extends EventTarget {\n    #systemSettings;\n    #socket;\n\n    /**\n     * @hideconstructor\n     */\n    constructor(systemSettings) {\n        super();\n        if (!systemSettings) {\n            Exception(ERROR_CODES.CREATE_INSTANCE_ERROR, \"systemSettings should be passed to class instance\");\n        }\n        this.#systemSettings = systemSettings;\n    }\n\n    init() {\n        import(\"socket.io-client\").then((module) => {\n            this.#socket = module.io(this.#systemSettings.network.address, {withCredentials: true});\n            \n            this.#registerSocketListeners();\n        });\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    get isServerConnected () {\n        if (this.#socket && this.#socket.connected) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    get playerId() {\n        return this.#socket.id;\n    }\n\n    sendGatherRoomsInfo() {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.ROOMS_INFO_REQUEST);\n    }\n\n    sendCreateOrJoinRoom(roomName, map) {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CREATE_OR_JOIN, roomName , map);\n    }\n\n    sendMessage(message) {\n        this.#socket.emit(CONST.EVENTS.WEBSOCKET.CLIENT_SERVER.CLIENT_MESSAGE, message);\n    }\n\n    #onConnect = () => {\n        Logger.debug(\"connected, socket id: \" + this.#socket.id);\n        this.dispatchEvent(new Event(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onDisconnect = (reason) => {\n        Logger.debug(\"server disconnected, reason: \" + reason);\n        this.dispatchEvent(new Event(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED));\n    };\n\n    #onData = (event) => {\n        console.warn(\"server data: \", event);\n    };\n\n    #onMessage = (message) => {\n        Logger.debug(\"received new message from server: \" + message);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.SERVER_MESSAGE, message));\n    };\n\n    #onRoomsInfo = (rooms) => {\n        Logger.debug(\"received roomsInfo \" + rooms);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.ROOMS_INFO, rooms));\n    };\n\n    #onCreateNewRoom = (room, map) => {\n        Logger.debug(\"CLIENT SOCKET: Created room  \" + room);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.CREATED, {room, map}));\n    };\n\n    #onRoomIsFull = (room) => {\n        Logger.debug(\"CLIENT SOCKET: Room is full, can't join: \" + room);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.FULL, {room}));\n    };\n\n    #onJoinedToRoom = (room, map) => {\n        Logger.debug(\"CLIENT SOCKET: Joined to room: \" + room, \", map: \", map);\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.JOINED, {room, map}));\n    };\n\n    #onUnjoinedFromRoom = (playerId) => {\n        this.dispatchEvent(new SystemEvent(CONST.EVENTS.WEBSOCKET.SERVER_CLIENT.DISCONNECTED, {playerId}));\n    };\n\n    #registerSocketListeners() {\n        this.#socket.on(\"connect\", this.#onConnect);\n        this.#socket.on(\"disconnect\", this.#onDisconnect);\n        this.#socket.on(\"data\", this.#onData);\n\n        this.#socket.on(\"roomsInfo\", this.#onRoomsInfo);\n    \n        this.#socket.on(\"created\", this.#onCreateNewRoom);\n    \n        this.#socket.on(\"full\", this.#onRoomIsFull);\n    \n        this.#socket.on(\"joined\", this.#onJoinedToRoom);\n    \n        this.#socket.on(\"log\", function(array) {\n            console.log.apply(console, array);\n        });\n    \n        this.#socket.on(\"message\", this.#onMessage);\n    \n        this.#socket.on(\"removed\", function(message) {\n            console.log(\"removed message\");\n            console.log(message);\n        });\n\n        this.#socket.on(\"disconnected\", this.#onUnjoinedFromRoom);\n\n        addEventListener(\"beforeunload\", this.#disconnect);\n    }\n\n    #disconnect = () => {\n        this.#socket.disconnect();\n    };\n}","export class WebGlDrawProgramData {\n    /**\n     * @type {string}\n     */\n    #programName;\n    /**\n     * @type {number[]}\n     */\n    #vectors;\n    /**\n     * @type {number[]}\n     */ \n    #textures;\n    /**\n     * @type {}\n     */ \n    #image;\n    /**\n     * @type {string}\n     */ \n    #imageName;\n    /**\n     * @type {string[]}\n     */\n    #drawMask;\n    /**\n     * @type {number}\n     */ \n    #rotation;\n    /**\n     * @type {number[]}\n     */ \n    #translation;\n    /**\n     * @type {number[]}\n     */ \n    #scale;\n    /**\n     * @type {number}\n     */ \n    #programVerticesNum;\n\n    constructor(programName, vectors, textures, image, imageName, drawMask = [\"SRC_ALPHA\", \"ONE_MINUS_SRC_ALPHA\"], rotation = 0, translation = [0,0], scale = [1, 1]) {\n        this.#programName = programName;\n        this.#vectors = vectors;\n        this.#textures = textures;\n        this.#image = image;\n        this.#imageName = imageName;\n        this.#drawMask = drawMask;\n        this.#rotation = rotation;\n        this.#translation = translation;\n        this.#scale = scale;\n        this.#programVerticesNum = vectors.length / 2; \n    }\n\n    get programName() {\n        return this.#programName;\n    }\n    \n    get vectors() {\n        return this.#vectors;\n    }\n    \n    get textures() {\n        return this.#textures;\n    }\n    \n    get image() {\n        return this.#image;\n    }\n    \n    get imageName() {\n        return this.#imageName;\n    }\n    \n    get drawMask() {\n        return this.#drawMask;\n    }\n    \n    get rotation() {\n        return this.#rotation;\n    }\n    \n    get translation() {\n        return this.#translation;\n    }\n    \n    get scale() {\n        return this.#scale;\n    }\n\n    get programVerticesNum() {\n        return this.#programVerticesNum;\n    }\n    \n    isProgramDataCanBeMerged(imageName, drawMask = [\"SRC_ALPHA\", \"ONE_MINUS_SRC_ALPHA\"], rotation = 0, translation = [0,0], scale = [1, 1]) {\n\n        if (this.imageName === imageName \n            && this.drawMask[0] === drawMask[0] \n            && this.drawMask[1] === drawMask[1]\n            && this.rotation === rotation\n            && this.translation[0] === translation[0]\n            && this.translation[1] === translation[1]\n            && this.scale[0] === scale[0]\n            && this.scale[1] === scale[1]) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    mergeProgramData(vectors, textures) {\n        this.#vectors.push(...vectors);\n        this.#textures.push(...textures);\n        this.#programVerticesNum = this.#vectors.length / 2; \n    }\n\n}\n","import { ERROR_CODES, CONST, WARNING_CODES } from \"../constants.js\";\nimport { crossProduct } from \"../utils.js\";\nimport { Exception, Warning } from \"./Exception.js\";\nimport { WebGlDrawProgramData } from \"./WebGlDrawProgramData.js\";\n\nexport class WebGlInterface {\n    /**\n     * @type {string}\n     */\n    #vertexShaderSource;\n    /**\n     * @type {string}\n     */\n    #fragmentShaderSource;\n    /**\n     * @type {Map<string, WebGLProgram>}\n     */\n    #programs;\n    /**\n     * @type {Array<WebGlDrawProgramData>}\n     */\n    #programsData;\n    /**\n     * @type {Map<string, Object>}\n     */\n    #coordsLocations;\n    /**\n     * @type {number}\n     */\n    #verticesNumber;\n    /**\n     * @type {WebGLRenderingContext}\n     */\n    #gl;\n    /**\n     * @type {boolean}\n     */\n    #debug;\n    /**\n     * @type  {Map<string, number>}\n     */\n    #images_bind;\n    /**\n     * @type {WebGLBuffer | null}\n     */\n    #positionBuffer;\n    /**\n     * @type {WebGLBuffer | null}\n     */\n    #texCoordBuffer;\n\n    constructor(context, debug) {\n        if (!context || !(context instanceof WebGLRenderingContext)) {\n            Exception(ERROR_CODES.UNEXPECTED_INPUT_PARAMS, \" context parameter should be specified and equal to WebGLRenderingContext\");\n        }\n        \n        this.#gl = context;\n        this.#debug = debug;\n        this.#programs = new Map();\n        this.#programsData = [];\n        this.#coordsLocations = new Map();\n        this.#images_bind = new Map();\n        this.#verticesNumber = 0;\n        this.#positionBuffer = this.#gl.createBuffer();\n        this.#texCoordBuffer = this.#gl.createBuffer();\n    }\n\n    _fixCanvasSize(width, height) {\n        this.#gl.viewport(0, 0, width, height);\n    }\n\n    _initiateImagesDrawProgram() {\n        this.#vertexShaderSource = `\n        attribute vec2 a_texCoord;\n\n        attribute vec2 a_position;\n\n        uniform vec2 u_translation;\n        uniform float u_rotation;\n        uniform vec2 u_scale;\n\n        uniform vec2 u_resolution;\n\n        varying vec2 v_texCoord;\n\n        void main(void) {\n            float c = cos(-u_rotation);\n            float s = sin(-u_rotation);\n\n            mat3 translationMatrix1 = mat3(\n                1, 0, 0,\n                0, 1, 0,\n                u_translation.x, u_translation.y, 1\n            );\n\n            mat3 translationMatrix2 = mat3(\n                1, 0, 0,\n                0, 1, 0,\n                -u_translation.x, -u_translation.y, 1\n            );\n            \n            mat3 rotationMatrix = mat3(\n                c, -s, 0,\n                s, c, 0,\n                0, 0, 1\n            );\n\n            mat3 scalingMatrix = mat3(\n                u_scale.x, 0, 0,\n                0, u_scale.y, 0,\n                0, 0, 1\n            );\n\n            mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\n            //Scale\n            // vec2 scaledPosition = a_position * u_scale;\n            // Rotate the position\n            // vec2 rotatedPosition = vec2(\n            //    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\n            //    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\n            //);\n            \n            //vec2 position = rotatedPosition + u_translation;\n            vec2 position = (matrix * vec3(a_position, 1)).xy;\n\n            //convert position from pixels to 0.0 to 1.0\n            vec2 zeroToOne = position / u_resolution;\n\n            //convert from 0->1 to 0->2\n            vec2 zeroToTwo = zeroToOne * 2.0;\n\n            //convert from 0->2 to -1->+1\n            vec2 clipSpace = zeroToTwo - 1.0;\n\n            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n            \n            v_texCoord = a_texCoord;\n        }\n        `;\n        this.#fragmentShaderSource = `\n        precision mediump float;\n\n        uniform sampler2D u_image;\n\n        //texCoords passed in from the vertex shader\n        varying vec2 v_texCoord;\n\n        void main() {\n            vec4 color = texture2D(u_image, v_texCoord);\n            gl_FragColor = color;\n        }\n        `;\n        const program = this.#initProgram(),\n            programName = CONST.WEBGL.DRAW_PROGRAMS.IMAGES;\n\n        this.#setProgram(programName, program);\n\n        const gl = this.#gl,\n            translationLocation = gl.getUniformLocation(program, \"u_translation\"),\n            rotationRotation = gl.getUniformLocation(program, \"u_rotation\"),\n            scaleLocation = gl.getUniformLocation(program, \"u_scale\"),\n            resolutionUniformLocation = gl.getUniformLocation(program, \"u_resolution\"),\n            positionAttributeLocation = gl.getAttribLocation(program, \"a_position\"),\n            texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\"),\n            u_imageLocation = gl.getUniformLocation(program, \"u_image\");\n\n        gl.enable(gl.BLEND);\n        // turn attribute on\n\n        this.#coordsLocations.set(programName, {\n            translationLocation,\n            rotationRotation,\n            scaleLocation,\n            resolutionUniformLocation,\n            positionAttributeLocation,\n            texCoordLocation,\n            u_imageLocation\n        });\n        return Promise.resolve();\n    }\n\n    _initPrimitivesDrawProgram() {\n        this.#vertexShaderSource = `\n        precision mediump float;\n\n        attribute vec2 a_position;\n\n        uniform vec2 u_translation;\n        uniform float u_rotation;\n        uniform vec2 u_scale;\n\n        uniform vec2 u_resolution;\n\n        void main(void) {\n            float c = cos(-u_rotation);\n            float s = sin(-u_rotation);\n\n            mat3 translationMatrix1 = mat3(\n                1, 0, 0,\n                0, 1, 0,\n                u_translation.x, u_translation.y, 1\n            );\n\n            //mat3 translationMatrix2 = mat3(\n            //    1, 0, 0,\n            //    0, 1, 0,\n            //    -u_translation.x, -u_translation.y, 1\n            //);\n            \n            mat3 rotationMatrix = mat3(\n                c, -s, 0,\n                s, c, 0,\n                0, 0, 1\n            );\n\n            mat3 scalingMatrix = mat3(\n                u_scale.x, 0, 0,\n                0, u_scale.y, 0,\n                0, 0, 1\n            );\n\n            //mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\n\n            mat3 matrix = translationMatrix1 * rotationMatrix * scalingMatrix;\n\n            //Scale\n            // vec2 scaledPosition = a_position * u_scale;\n            // Rotate the position\n            // vec2 rotatedPosition = vec2(\n            //    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\n            //    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\n            //);\n            \n            //vec2 position = rotatedPosition + u_translation;\n            vec2 position = (matrix * vec3(a_position, 1)).xy;\n\n            //convert position from pixels to 0.0 to 1.0\n            vec2 zeroToOne = position / u_resolution;\n\n            //convert from 0->1 to 0->2\n            vec2 zeroToTwo = zeroToOne * 2.0;\n\n            //convert from 0->2 to -1->+1\n            vec2 clipSpace = zeroToTwo - 1.0;\n\n            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n        }\n        `;\n        this.#fragmentShaderSource = `\n        precision mediump float;\n\n        uniform vec4 u_color;\n        uniform float u_fade_min; \n        uniform float u_fade_max;\n        uniform vec2 a_position;\n        uniform vec2 u_resolution;\n        uniform vec2 u_translation;\n        \n        void main(void) {\n            vec4 p = u_color;\n            if (u_fade_min > 0.0) {\n                vec2 fix_tr = vec2(u_translation.x, u_resolution.y - u_translation.y); \n                float distance = distance(fix_tr.xy, gl_FragCoord.xy);\n                if (u_fade_min <= distance && distance <= u_fade_max) {\n                    float percent = ((distance - u_fade_max) / (u_fade_min - u_fade_max)) * 100.0;\n                    p.a = u_color.a * (percent / 100.0);\n                }\n            }\n\n            gl_FragColor = p;\n        }\n        `;\n        const program = this.#initProgram(),\n            programName = CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES;\n        this.#setProgram(programName, program);\n\n        const gl = this.#gl,\n            translationLocation = gl.getUniformLocation(program, \"u_translation\"),\n            rotationRotation = gl.getUniformLocation(program, \"u_rotation\"),\n            scaleLocation = gl.getUniformLocation(program, \"u_scale\"),\n            resolutionUniformLocation = gl.getUniformLocation(program, \"u_resolution\"),\n            colorUniformLocation = gl.getUniformLocation(program, \"u_color\"),\n            positionAttributeLocation = gl.getAttribLocation(program, \"a_position\"),\n            fadeMinLocation = gl.getUniformLocation(program, \"u_fade_min\"),\n            fadeMaxLocation =  gl.getUniformLocation(program, \"u_fade_max\");\n\n        this.#coordsLocations.set(programName, {\n            translationLocation,\n            rotationRotation,\n            scaleLocation,\n            resolutionUniformLocation,\n            colorUniformLocation,\n            positionAttributeLocation,\n            fadeMinLocation,\n            fadeMaxLocation\n        });\n        return Promise.resolve();\n    }\n    \n    /**\n     * \n     * @param {*} vectors \n     * @param {*} textures \n     * @param {*} image \n     * @param {*} imageName \n     * @param {*} drawMask \n     * @param {*} rotation \n     * @param {*} translation \n     * @param {*} scale \n     * @returns {Promise<void>}\n     */\n    _bindTileImages(vectors, textures, image, imageName, drawMask = [\"SRC_ALPHA\", \"ONE_MINUS_SRC_ALPHA\"], rotation = 0, translation = [0, 0], scale = [1, 1]) {\n        return new Promise((resolve) => {\n            const programName = CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\n                existingProgramData = this.#programsData.filter((data) => data.programName === programName);\n                \n            let isProgramDataMerged = false;\n\n            for(let i = 0; i < existingProgramData.length; i++) {\n                const data = existingProgramData[i];\n                if (data.isProgramDataCanBeMerged(imageName, drawMask)) {\n                    data.mergeProgramData(vectors, textures);\n                    isProgramDataMerged = true;\n                }\n            }\n\n            if (!isProgramDataMerged) {\n                this.#programsData.push(new WebGlDrawProgramData(programName, vectors, textures, image, imageName, drawMask, rotation, translation, scale));\n            }\n\n            resolve();\n        });\n    }\n    \n    /**\n     * \n     * @returns {Promise<void>}\n     */\n    _executeTileImagesDraw() {\n        return new Promise((resolve) => {\n            const programName = CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\n                program = this.#getProgram(programName),\n                { translationLocation,\n                    rotationRotation,\n                    scaleLocation,\n                    resolutionUniformLocation,\n                    positionAttributeLocation,\n                    texCoordLocation,\n                    u_imageLocation } = this.#coordsLocations.get(programName),\n                gl = this.#gl,\n                programsData = this.#programsData.filter(programData => programData.programName === programName);\n           \n            gl.useProgram(program);\n\n            for (let i = 0; i < programsData.length; i++) {\n                const data = programsData[i];\n                // set the resolution\n                gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n                gl.uniform2f(translationLocation, data.translation[0], data.translation[1]);\n                gl.uniform2f(scaleLocation, data.scale[0], data.scale[1]);\n                gl.uniform1f(rotationRotation, data.rotation);\n                \n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.vectors), gl.STATIC_DRAW);\n\n                gl.enableVertexAttribArray(positionAttributeLocation);\n                //Tell the attribute how to get data out of positionBuffer\n                const size = 2,\n                    type = gl.FLOAT, // data is 32bit floats\n                    normalize = false,\n                    stride = 0, // move forward size * sizeof(type) each iteration to get next position\n                    offset = 0; // start of beginning of the buffer\n                gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n                //textures buffer\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\n                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data.textures), gl.STATIC_DRAW);\n\n                gl.enableVertexAttribArray(texCoordLocation);\n                gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, offset);\n\n                let bind_number  = this.#images_bind.get(data.imageName);\n\n                if (!bind_number ) {\n                    bind_number  = this.#images_bind.size + 1;\n                    gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\n                    gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data.image);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n                    this.#images_bind.set(data.imageName, bind_number);\n                } else {\n                    gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\n                }\n                gl.uniform1i(u_imageLocation, bind_number);\n                gl.blendFunc(gl[data.drawMask[0]], gl[data.drawMask[1]]);\n                this.#verticesNumber = data.programVerticesNum;\n                // Upload the image into the texture.\n                this.#executeGlslProgram();\n            }\n\n            resolve();\n        });\n    }\n\n    _bindAndDrawTileImages(vectors, textures, image, image_name, rotation = 0, translation = [0, 0], scale = [1, 1]) {\n        const programName = CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\n            program = this.#getProgram(programName),\n            { translationLocation,\n                rotationRotation,\n                scaleLocation,\n                resolutionUniformLocation,\n                positionAttributeLocation,\n                texCoordLocation,\n                u_imageLocation } = this.#coordsLocations.get(programName),\n            gl = this.#gl;\n\n        gl.useProgram(program);\n\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vectors), gl.STATIC_DRAW);\n\n        this.#verticesNumber += vectors.length / 2;\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        //textures buffer\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures), gl.STATIC_DRAW);\n\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n\n        let bind_number  = this.#images_bind.get(image_name);\n\n        if (!bind_number ) {\n            bind_number  = this.#images_bind.size + 1;\n\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\n            gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());\n            \n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n            this.#images_bind.set(image_name, bind_number);\n        } else {\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\n        }\n        gl.uniform1i(u_imageLocation, bind_number );\n        // make image transparent parts transparent\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        // Upload the image into the texture.\n        this.#executeGlslProgram();\n    }\n\n    _bindText(x, y, renderObject) {\n        const programName = CONST.WEBGL.DRAW_PROGRAMS.IMAGES,\n            program = this.#getProgram(programName),\n            { translationLocation,\n                rotationRotation,\n                scaleLocation,\n                resolutionUniformLocation,\n                positionAttributeLocation,\n                texCoordLocation,\n                u_imageLocation } = this.#coordsLocations.get(programName),\n            gl = this.#gl;\n\n        //@toDo: add additional info to the #images_bind and avoid this call, if image is already created\n        const { boxWidth, boxHeight, ctx } = this.#createCanvasText(renderObject),\n            texture = ctx.canvas,\n            image_name = renderObject.text;\n\n        y = y - boxHeight;\n\n        const rotation = 0, \n            translation = [0, 0], \n            scale = [1, 1];\n        const vecX1 = x,\n            vecY1 = y,\n            vecX2 = vecX1 + boxWidth,\n            vecY2 = vecY1 + boxHeight;\n        const verticesBufferData = [\n                vecX1, vecY1,\n                vecX2, vecY1,\n                vecX1, vecY2,\n                vecX1, vecY2,\n                vecX2, vecY1,\n                vecX2, vecY2\n            ],\n            texturesBufferData = [\n                0, 0,\n                1, 0,\n                0, 1,\n                0, 1,\n                1, 0,\n                1, 1\n            ];\n\n        gl.useProgram(program);\n\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        \n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesBufferData), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        //textures buffer\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texturesBufferData), gl.STATIC_DRAW);\n\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n        \n        this.#verticesNumber += 6;\n        // remove box\n        // fix text edges\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        //gl.depthMask(false);\n        let bind_number = this.#images_bind.get(image_name);\n        if (!bind_number) {\n            bind_number  = this.#images_bind.size + 1;\n\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\n            gl.bindTexture(gl.TEXTURE_2D, gl.createTexture());\n            // Upload the image into the texture.\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            // As image properties such as text stroke changes, image_name still the same,\n            // and image won't replaced\n            //this.#images_bind.set(image_name, bind_number);\n        } else {\n            gl.activeTexture(gl[\"TEXTURE\" + bind_number]);\n        }\n        gl.uniform1i(u_imageLocation, bind_number);\n        //console.log(\"vertex attrib 1 :\", gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING));\n        this.#executeGlslProgram();\n    }\n\n    _bindPrimitives(renderObject, rotation = 0, translation = [0, 0], scale = [1, 1]) {\n        const programName = CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\n            program = this.#getProgram(programName),\n            { \n                translationLocation,\n                rotationRotation,\n                scaleLocation,\n                resolutionUniformLocation,\n                colorUniformLocation,\n                positionAttributeLocation,\n                fadeMinLocation\n            } = this.#coordsLocations.get(programName),\n            gl = this.#gl;\n\n        gl.useProgram(program);\n\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        switch (renderObject.type) {\n        case CONST.DRAW_TYPE.RECTANGLE:\n            this.#setSingleRectangle(renderObject.width, renderObject.height);\n            this.#verticesNumber += 6;\n            break;\n        case CONST.DRAW_TYPE.TEXT:\n            break;\n        case CONST.DRAW_TYPE.CIRCLE: {\n            const coords = renderObject.vertices;\n            gl.bufferData(this.#gl.ARRAY_BUFFER, \n                new Float32Array(coords), this.#gl.STATIC_DRAW);\n            this.#verticesNumber += coords.length / 2;\n            break;\n        }\n        case CONST.DRAW_TYPE.POLYGON: {\n            const triangles = this.#triangulatePolygon(renderObject.vertices);\n            this.#bindPolygon(triangles);\n            const len = triangles.length;\n            if (len % 3 !== 0) {\n                Warning(WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, `polygons ${renderObject.id}, vertices are not correct, skip drawing`);\n                return;\n            }\n            this.#verticesNumber += len / 2;\n            break;\n        }\n        }\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(renderObject.bgColor);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        if (renderObject.blendFunc) {\n            gl.blendFunc(renderObject.blendFunc[0], renderObject.blendFunc[1]);\n        }\n        if (renderObject.cut) {\n            gl.blendEquation(gl.FUNC_SUBTRACT);\n        }\n        //disable attribute which is not used in this program\n        //if (gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_ENABLED)) {\n        //gl.disableVertexAttribArray(1);\n        //}\n        this.#executeGlslProgram(0, null, true);\n    }\n\n    _drawLines(linesArray, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {\n        const programName = CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\n            program = this.#getProgram(programName),\n            { resolutionUniformLocation,\n                colorUniformLocation,\n                positionAttributeLocation,\n            \n                translationLocation,\n                rotationRotation,\n                scaleLocation,\n                fadeMinLocation\n            } = this.#coordsLocations.get(programName),\n            gl = this.#gl;\n\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, 1, 1);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        this.#gl.bufferData(\n            this.#gl.ARRAY_BUFFER, \n            new Float32Array(linesArray),\n            this.#gl.STATIC_DRAW);\n\n        this.#verticesNumber += linesArray.length / 2;\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(color);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        gl.lineWidth(lineWidth);\n\n        //gl.blendFunc(gl.ONE, gl.DST_COLOR );\n        \n        //disable attribute which is not used in this program\n        //if (gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_ENABLED)) {\n        //    gl.disableVertexAttribArray(1);\n        //}\n        this.#executeGlslProgram(0, gl.LINES);\n    }\n\n    _drawPolygon(vertices, color, lineWidth = 1, rotation = 0, translation = [0, 0]) {\n        const programName = CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\n            program = this.#getProgram(programName),\n            { resolutionUniformLocation,\n                colorUniformLocation,\n                positionAttributeLocation,\n            \n                translationLocation,\n                rotationRotation,\n                scaleLocation,\n                fadeMinLocation\n            } = this.#coordsLocations.get(programName),\n            gl = this.#gl;\n\n        gl.useProgram(program);\n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, 1, 1);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, 0);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        const triangles = this.#triangulatePolygon(vertices);\n        \n        const polygonVerticesNum = triangles.length;\n        if (polygonVerticesNum % 3 !== 0) {\n            Warning(WARNING_CODES.POLYGON_VERTICES_NOT_CORRECT, \"polygon boundaries vertices are not correct, skip drawing\");\n            return;\n        }\n        this.#bindPolygon(triangles);\n        this.#verticesNumber += polygonVerticesNum / 2;\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        const colorArray = this.#rgbaToArray(color);\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n\n        this.#executeGlslProgram(0, null);\n    }\n\n    _bindConus(renderObject, rotation = 0, translation = [0, 0], scale = [1, 1]) {\n        const programName = CONST.WEBGL.DRAW_PROGRAMS.PRIMITIVES,\n            program = this.#getProgram(programName),\n            { \n                translationLocation,\n                rotationRotation,\n                scaleLocation,\n                resolutionUniformLocation,\n                colorUniformLocation,\n                positionAttributeLocation,\n                fadeMinLocation,\n                fadeMaxLocation\n            } = this.#coordsLocations.get(programName),\n            gl = this.#gl,\n            coords = renderObject.vertices,\n            fillStyle = renderObject.bgColor,\n            fade_min = renderObject.fade_min,\n            fadeLen = renderObject.radius;\n            \n        gl.useProgram(program);\n        \n        // set the resolution\n        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\n        gl.uniform2f(translationLocation, translation[0], translation[1]);\n        gl.uniform2f(scaleLocation, scale[0], scale[1]);\n        gl.uniform1f(rotationRotation, rotation);\n        gl.uniform1f(fadeMinLocation, fade_min);\n        gl.uniform1f(fadeMaxLocation, fadeLen);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.#positionBuffer);\n\n        gl.bufferData(this.#gl.ARRAY_BUFFER, \n            new Float32Array(coords), this.#gl.STATIC_DRAW);\n\n        gl.enableVertexAttribArray(positionAttributeLocation);\n        //Tell the attribute how to get data out of positionBuffer\n        const size = 2,\n            type = gl.FLOAT, // data is 32bit floats\n            normalize = false,\n            stride = 0, // move forward size * sizeof(type) each iteration to get next position\n            offset = 0; // start of beginning of the buffer\n        gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\n\n        this.#verticesNumber += coords.length / 2;\n\n        if (renderObject.blendFunc) {\n            gl.blendFunc(renderObject.blendFunc[0], renderObject.blendFunc[1]);\n        }\n\n        if (renderObject.cut) {\n            // cut bottom \n            gl.blendEquation(gl.FUNC_SUBTRACT);\n            //gl.blendFunc( gl.ONE, gl.ONE );\n            //gl.blendFunc(gl.ONE, gl.DST_COLOR);\n        } //else {\n        //gl.disable(gl.BLEND);\n        // make transparent\n        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        //}\n\n        const colorArray = this.#rgbaToArray(fillStyle);\n\n        gl.uniform4f(colorUniformLocation, colorArray[0]/255, colorArray[1]/255, colorArray[2]/255, colorArray[3]);\n        \n        //disable attribute which is not used in this program\n        //if (gl.getVertexAttrib(1, gl.VERTEX_ATTRIB_ARRAY_ENABLED)) {\n        //gl.disableVertexAttribArray(1);\n        //}\n        this.#executeGlslProgram(0, gl.TRIANGLE_FAN, true);\n    }\n\n    _clearView() {\n        const gl = this.#gl;\n        // Set clear color to black, fully opaque\n        this.#programsData = [];\n        gl.clearColor(0, 0, 0, 0);\n        // Clear the color buffer with specified clear color\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    }\n\n    #setProgram(name, program) {\n        this.#programs.set(name, program);\n    }\n\n    #getProgram(name) {\n        return this.#programs.get(name);\n    }\n\n    #bindPolygon(vertices) {\n        this.#gl.bufferData(\n            this.#gl.ARRAY_BUFFER, \n            new Float32Array(vertices),\n            this.#gl.STATIC_DRAW);\n    }\n\n    #setSingleRectangle(width, height) {\n        const x1 = 0,\n            x2 = 0 + width,\n            y1 = 0,\n            y2 = 0 + height;\n        this.#gl.bufferData(this.#gl.ARRAY_BUFFER, \n            new Float32Array([\n                x1, y1,\n                x2, y1,\n                x1, y2,\n                x1, y2,\n                x2, y1,\n                x2, y2]), this.#gl.STATIC_DRAW);\n    }\n    \n    #executeGlslProgram(offset = 0, primitiveType, resetEquation) {\n        const primitiveTypeValue = primitiveType ? primitiveType : this.#gl.TRIANGLES,\n            gl = this.#gl;\n            \n        const err = this.#debug ? gl.getError() : 0;\n        if (err !== 0) {\n            console.error(err);\n            throw new Error(\"Error num: \" + err);\n        } else {\n            gl.drawArrays(primitiveTypeValue, offset, this.#verticesNumber);\n            this.#verticesNumber = 0;\n            // set blend to default\n            if (resetEquation) {\n                gl.blendEquation(  gl.FUNC_ADD );\n            }\n        }\n    }\n\n    /**\n     * @returns {WebGLProgram}\n     */\n    #initProgram() {\n        const gl = this.#gl,\n            program = gl.createProgram();\n\n        if (program) {\n            const compVertexShader = this.#compileShader(this.#vertexShaderSource, gl.VERTEX_SHADER);\n            if (compVertexShader) {\n                gl.attachShader(program, compVertexShader);\n            } else {\n                Exception(ERROR_CODES.WEBGL_ERROR, \"#compileShader(vertexShaderSource) is null\");\n            }\n\n            const compFragmentShader = this.#compileShader(this.#fragmentShaderSource, gl.FRAGMENT_SHADER);\n            if (compFragmentShader) {\n                gl.attachShader(program, compFragmentShader);\n            } else {\n                Exception(ERROR_CODES.WEBGL_ERROR, \"#compileShader(fragmentShaderSource) is null\");\n            }\n\n            gl.linkProgram(program);\n            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n                const info = gl.getProgramInfoLog(program);\n                Exception(ERROR_CODES.WEBGL_ERROR, `Could not compile WebGL program. \\n\\n${info}`);\n            }\n        } else {\n            Exception(ERROR_CODES.WEBGL_ERROR, \"gl.createProgram() is null\");\n        }\n        return program;\n    }\n\n    /**\n     * \n     * @param {*} renderObject \n     * @returns {{boxWidth:number, boxHeight:number, ctx:CanvasRenderingContext2D}}\n     */\n    #createCanvasText(renderObject) {\n        const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n        if (ctx) { \n            ctx.font = renderObject.font;\n            renderObject._textMetrics = ctx.measureText(renderObject.text);\n            const boxWidth = renderObject.boundariesBox.width, \n                boxHeight = renderObject.boundariesBox.height;\n            ctx.canvas.width = boxWidth;\n            ctx.canvas.height = boxHeight;\n            ctx.font = renderObject.font;\n            ctx.textBaseline = \"bottom\";// bottom\n            if (renderObject.fillStyle) {\n                ctx.fillStyle = renderObject.fillStyle;\n                ctx.fillText(renderObject.text, 0, boxHeight);\n            } \n            if (renderObject.strokeStyle) {\n                ctx.strokeStyle = renderObject.strokeStyle;\n                ctx.strokeText(renderObject.text, 0, boxHeight);\n            }\n            return { boxWidth, boxHeight, ctx };\n        } else {\n            Exception(ERROR_CODES.WEBGL_ERROR, \"can't getContext('2d')\");\n        }\n    }\n\n    #compileShader(shaderSource, shaderType) {\n        const shader = this.#gl.createShader(shaderType);\n        if (shader) {\n            this.#gl.shaderSource(shader, shaderSource);\n            this.#gl.compileShader(shader);\n\n            if (!this.#gl.getShaderParameter(shader, this.#gl.COMPILE_STATUS)) {\n                const info = this.#gl.getShaderInfoLog(shader);\n                Exception(ERROR_CODES.WEBGL_ERROR, \"Couldn't compile webGl program. \\n\\n\" + info);\n            }\n        } else {\n            Exception(ERROR_CODES.WEBGL_ERROR, `gl.createShader(${shaderType}) is null`);\n        }\n        return shader;\n    }\n\n    /**\n     * \n     * @param {string} rgbaColor \n     * @returns {number[]}\n     */\n    #rgbaToArray (rgbaColor) {\n        return rgbaColor.replace(\"rgba(\", \"\").replace(\")\", \"\").split(\",\").map((/** @param {string} */item) => Number(item.trim()));\n    }\n\n    #triangulatePolygon(vertices) {\n        return this.#triangulate(vertices);\n    }\n\n    /**\n     * \n     * @param {Array<Array<number>>} polygonVertices \n     * @param {Array<number>} triangulatedPolygon \n     * @returns {Array<number>}\n     */\n    #triangulate (polygonVertices, triangulatedPolygon = []) {\n        const len = polygonVertices.length,\n            vectorsCS = (a, b, c) => crossProduct({x:c[0] - a[0], y: c[1] - a[1]}, {x:b[0] - a[0], y: b[1] - a[1]});\n\n        if (len <= 3) {\n            polygonVertices.forEach(vertex => {\n                triangulatedPolygon.push(vertex[0]);\n                triangulatedPolygon.push(vertex[1]);\n            });\n            return triangulatedPolygon;\n        }\n        const verticesSortedByY = [...polygonVertices].sort((curr, next) => next[1] - curr[1]);\n        const topVertexIndex = polygonVertices.indexOf(verticesSortedByY[0]),\n            startVertexIndex = topVertexIndex !== len - 1 ? topVertexIndex + 1 : 0;\n        \n        let processedVertices = polygonVertices,\n            processedVerticesLen = processedVertices.length,\n            skipCount = 0,\n            i = startVertexIndex;\n        \n        while(processedVertices.length > 2) {\n            // if overflowed, start from beginning\n            const currLen = processedVertices.length;\n            if (i >= currLen) {\n                i -= currLen;\n            }\n    \n            const prevVertex = i === 0 ? processedVertices[currLen - 1] : processedVertices[i - 1],\n                currentVertex = processedVertices[i],\n                nextVertex = currLen === i + 1 ? processedVertices[0] : processedVertices[i + 1];\n    \n            \n            const cs = vectorsCS(prevVertex, currentVertex, nextVertex);\n    \n            if (cs < 0) {\n                triangulatedPolygon.push(prevVertex[0]);\n                triangulatedPolygon.push(prevVertex[1]);\n                triangulatedPolygon.push(currentVertex[0]);\n                triangulatedPolygon.push(currentVertex[1]);\n                triangulatedPolygon.push(nextVertex[0]);\n                triangulatedPolygon.push(nextVertex[1]);\n                processedVertices = processedVertices.filter((val, index) => index !== i);\n            } else {\n                skipCount += 1;\n                if (skipCount > processedVerticesLen) {\n                    Exception(ERROR_CODES.DRAW_PREPARE_ERROR, \"Can't extract triangles. Probably vertices input is not correct, or the order is wrong\");\n                }\n            }\n            i++;\n        }\n        \n        return triangulatedPolygon;\n    }\n}","import { CONST } from \"./constants.js\";\r\n\r\n/**\r\n * Settings object, should be passed as a parameter to System.constructor().\r\n */\r\nexport const SystemSettings = {\r\n    mode: CONST.MODE.DEBUG,\r\n    \r\n    gameOptions: {\r\n        library: CONST.LIBRARY.WEBGL,\r\n        checkWebGlErrors: false,\r\n        debugMobileTouch: false,\r\n        optimization: null,\r\n        loadingScreen: {\r\n            backgroundColor:  \"rgba(128, 128, 128, 0.6)\",\r\n            loadingBarBg: \"rgba(128, 128, 128, 1)\",\r\n            loadingBarProgress: \"rgba(128, 128, 128, 0.2)\",\r\n        },\r\n        boundaries: {\r\n            drawLayerBoundaries: false,\r\n            drawObjectBoundaries: false,\r\n            boundariesColor: \"rgba(224, 12, 21, 0.6)\",\r\n            boundariesWidth: 2\r\n        },\r\n        modules: {\r\n        },\r\n        render: {\r\n            averageFPStime: 10000,\r\n            minCircleTime: 16, //ms which is ~60 FPS\r\n            boundaries: {\r\n                mapBoundariesEnabled: true,\r\n                realtimeCalculations: true,\r\n                wholeWorldPrecalculations: false\r\n            }\r\n        }\r\n    },\r\n    \r\n\r\n    network: {\r\n        address: \"https://gameserver.reslc.ru:9009\",\r\n        gatherRoomsInfoInterval: 5000\r\n    },\r\n\r\n    canvasMaxSize: {\r\n        width: 900,\r\n        height: 960\r\n    },\r\n\r\n    worldSize: {\r\n        width: 960,\r\n        height: 960\r\n    },\r\n\r\n    defaultCanvasKey: \"default\"\r\n};","export const CONST = {\n    MODE: {\n        DEBUG: \"DEBUG\",\n        PRODUCTION: \"PRODUCTION\"\n    },\n    SCREENS: {},\n    AUDIO: {},\n    CONNECTION_STATUS: {\n        DISCONNECTED: \"disconnected\",\n        CONNECTED: \"connected\",\n        CONNECTION_LOST: \"connection lost\"\n    },\n    EVENTS: {\n        SYSTEM: {\n            START_PAGE:\"START_PAGE\",\n            STOP_PAGE: \"STOP_PAGE\",\n            RENDER: {\n                START: \"start\",\n                END: \"end\"\n            }\n        },\n        GAME: {\n            BOUNDARIES_COLLISION: \"BOUNDARIES_COLLISION\",\n            OBJECTS_COLLISION: \"OBJECTS_COLLISION\"\n        },\n        WEBSOCKET: {\n            SERVER_CLIENT: {\n                CONNECTION_STATUS_CHANGED: \"CONNECTION_STATUS_CHANGED\",\n                ROOMS_INFO: \"roomsInfo\",\n                CREATED: \"created\",\n                JOINED: \"joined\",\n                FULL: \"full\",\n                DISCONNECTED: \"disconnected\",\n                SERVER_MESSAGE: \"message\",\n                RESTARTED: \"restarted\",\n            },\n            CLIENT_SERVER: {\n                ROOMS_INFO_REQUEST: \"gatherRoomsInfo\",\n                CREATE_OR_JOIN: \"create or join\",\n                RESTART_REQUEST: \"restart\",\n                CLIENT_MESSAGE: \"message\"\n            }\n        }\n    },\n    WEBGL: {\n        DRAW_PROGRAMS: {\n            PRIMITIVES: \"drawPrimitives\",\n            IMAGES: \"drawImages\"\n        }\n    },\n    DRAW_TYPE: {\n        RECTANGLE: \"rect\",\n        CONUS: \"conus\",\n        CIRCLE: \"circle\",\n        POLYGON: \"polygon\",\n        LINE: \"line\",\n        TEXT: \"text\",\n        IMAGE: \"image\"\n    },\n    LAYERS: {\n        DEFAULT: \"default-view-layer\",\n        BOUNDARIES: \"boundaries-view-layer\"\n    },\n    GAME_OPTIONS: {},\n    LIBRARY: {\n        WEBGL: \"webgl\"\n    },\n    OPTIMIZATION: {\n        WEB_ASSEMBLY: {\n            ASSEMBLY_SCRIPT: \"ASSEMBLY_SCRIPT\"\n        }\n    }\n};\n\nexport const ERROR_CODES = {\n    CREATE_INSTANCE_ERROR: \"CREATE_INSTANCE_ERROR\",\n    VIEW_NOT_EXIST: \"VIEW_NOT_EXIST\",\n    ELEMENT_NOT_EXIST: \"ELEMENT_NOT_EXIST\",\n    FILE_NOT_EXIST: \"FILE_NOT_EXIST\",\n    UNEXPECTED_INPUT_PARAMS: \"UNEXPECTED_INPUT_PARAMS\",\n    UNHANDLED_EXCEPTION: \"UNHANDLED_EXCEPTION\",\n    UNHANDLED_PREPARE_EXCEPTION: \"UNHANDLED_PREPARE_EXCEPTION\",\n    CANVAS_KEY_NOT_SPECIFIED: \"CANVAS_KEY_NOT_SPECIFIED\",\n    CANVAS_WITH_KEY_NOT_EXIST: \"CANVAS_WITH_KEY_NOT_EXIST\",\n    WRONG_TYPE_ERROR: \"WRONG_TYPE_ERROR\",\n    UNEXPECTED_WS_MESSAGE: \"UNEXPECTED_WS_MESSAGE\",\n    UNEXPECTED_PLAYER_ID: \"UNEXPECTED_PLAYER_ID\",\n    UNEXPECTED_BULLET_ID: \"UNEXPECTED_BULLET_ID\",\n    UNEXPECTED_EVENT_NAME: \"UNEXPECTED_EVENT_NAME\",\n    WEBGL_ERROR: \"WEBGL_ERROR\",\n    DRAW_PREPARE_ERROR: \"DRAW_PREPARE_ERROR\",\n    UNEXPECTED_TOUCH_AREA: \"UNEXPECTED_TOUCH_AREA\",\n};\n\nexport const WARNING_CODES =  {\n    FILE_LOADING_ISSUE: \"FILE_LOADING_ISSUE\",\n    ASSETS_NOT_READY: \"ASSETS_NOT_READY\",\n    NOT_FOUND: \"NOT_FOUND\",\n    NOT_TESTED: \"NOT_TESTED\",\n    WORLD_DIMENSIONS_NOT_SET: \"WORLD_DIMENSIONS_NOT_SET\",\n    UNHANDLED_DRAW_ISSUE: \"UNHANDLED_DRAW_ISSUE\",\n    UNEXPECTED_WORLD_SIZE: \"UNEXPECTED_WORLD_SIZE\",\n    AUDIO_ALREADY_REGISTERED: \"AUDIO_ALREADY_REGISTERED\",\n    AUDIO_NOT_REGISTERED: \"AUDIO_NOT_REGISTERED\",\n    AUDIO_NOT_LOADED: \"AUDIO_NOT_LOADED\",\n    UNKNOWN_DRAW_OBJECT: \"UNKNOWN_DRAW_OBJECT\",\n    METHOD_NOT_IMPLEMENTED: \"METHOD_NOT_IMPLEMENTED\",\n    POLYGON_VERTICES_NOT_CORRECT: \"POLYGON_VERTICES_NOT_CORRECT\"\n};","import { ScreenPage } from \"../base/ScreenPage.js\";\nimport { CONST } from \"../index.js\";\n\nconst logoKey = \"logoKey\";\nexport class LoadingScreen extends ScreenPage {\n    #total = 0;\n    #loaded = 0;\n    #barWidth = 0;\n    register() {\n        //this.loader.addImage(logoKey, \"./images/icon.png\");\n    }\n\n    init() {\n        const [w, h] = this.screenPageData.canvasDimensions,\n            barWidth = w/3,\n            barHeight = 20;\n        this.createCanvasView(CONST.LAYERS.DEFAULT);\n        //this.logo = this.draw.image(w/2, h/2, 300, 200, logoKey);\n        this.text = this.draw.text(w/2 - 20, h/2 - 2 * barHeight, \"JsGE\", \"24px sans-serif\", \"black\");\n        this.background = this.draw.rect(0, 0, w, h, this.systemSettings.gameOptions.loadingScreen.backgroundColor);  \n        this.loadingBarBg = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarBg);\n        this.loadingBarProgress = this.draw.rect(w/2 - (barWidth/2), h/2 - (barHeight/2), barWidth, barHeight, this.systemSettings.gameOptions.loadingScreen.loadingBarProgress);\n\n        this.#barWidth = barWidth;\n        this.addRenderObject(CONST.LAYERS.DEFAULT, this.background);\n        this.addRenderObject(CONST.LAYERS.DEFAULT, this.text);\n        //this.addRenderObject(CONST.LAYERS.DEFAULT, this.logo);\n        this.addRenderObject(CONST.LAYERS.DEFAULT, this.loadingBarBg);\n        this.addRenderObject(CONST.LAYERS.DEFAULT, this.loadingBarProgress);\n    }\n\n    _progress = (loaded, left) => {\n        const [w, h] = this.screenPageData.canvasDimensions,\n            widthPart = this.#barWidth / this.#total;\n\n        this.#loaded = loaded;\n        \n        this.loadingBarProgress.width = widthPart * this.#loaded;\n    };\n\n    start(options) {\n        this.#total = options.total;\n    }\n\n    // a workaround for checking upload progress before render\n    get loader() {\n        return ({filesWaitingForUpload:0});\n    }\n} ","import { System } from \"./base/System.js\";\r\nimport { ScreenPage } from \"./base/ScreenPage.js\";\r\nimport { DrawImageObject } from \"./base/DrawImageObject.js\";\r\nimport { SystemAudioInterface } from \"./base/SystemAudioInterface.js\";\r\nimport * as Primitives from \"./base/Primitives.js\";\r\nimport { SystemSettings } from \"./configs.js\";\r\nimport { CONST } from \"./constants.js\";\r\nimport * as utils from \"./utils.js\";\r\n\r\nexport { System, SystemSettings, CONST, ScreenPage, DrawImageObject, SystemAudioInterface, Primitives, utils };","import { Vector } from \"./base/Primitives.js\";\n\nfunction isMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent) ;\n}\n\nfunction isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\nfunction pointToCircleDistance(x, y, circle) {\n    const pointToCircleCenterDistance = new Vector(x, y, circle.x, circle.y).length;\n    return pointToCircleCenterDistance - circle.r;\n}\n\nfunction countClosestTraversal(line, sight) {\n    const x1 = sight.x1,\n        y1 = sight.y1,\n        x2 = sight.x2,\n        y2 = sight.y2;\n    const x3 = line.x1,\n        y3 = line.y1,\n        x4 = line.x2,\n        y4 = line.y2;\n\n    const r_px = x1,\n        r_py = y1,\n        r_dx = x2-x1,\n        r_dy = y2-y1;\n\n    const s_px = x3,\n        s_py = y3,\n        s_dx = x4-x3,\n        s_dy = y4-y3;\n\n    const r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy),\n        s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);\n    if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){\n        return null;\n    }\n\n    const T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx),\n        T1 = (s_px+s_dx*T2-r_px)/r_dx;\n\n    if(T1<0 || isNaN(T1)) return null;\n    if(T2<0 || T2>1) return null;\n\n    return {\n        x: r_px+r_dx*T1,\n        y: r_py+r_dy*T1,\n        p: T1\n    };\n}\n\n/**\n * \n * @param {{x1:number, y1:number, x2:number, y2:number}} line1 \n * @param {{x1:number, y1:number, x2:number, y2:number}} line2 \n * @returns {{x:number, y:number, p:number} | undefined}\n * @ignore\n */\nfunction countClosestTraversal2(line1, line2) {\n    const x1 = line2.x1,\n        y1 = line2.y1,\n        x2 = line2.x2,\n        y2 = line2.y2;\n    const x3 = line1.x1,\n        y3 = line1.y1,\n        x4 = line1.x2,\n        y4 = line1.y2;\n\n    const det = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    // lines are parallel, or coincident\n    if (det === 0){\n        return;\n    }\n    let x = ((x1*y2 - y1*x2) * (x3 - x4) - (x1 - x2) * (x3*y4 - y3*x4)) / det;\n    let y = ((x1*y2 - y1*x2) * (y3 - y4) - (y1 - y2) * (x3*y4 - y3*x4)) / det;\n    const point = {x, y};\n    \n    if (isPointOnTheLine(point, line1, 0.0000000000001) && isPointOnTheLine(point, line2, 0.0000000000001)) {\n        const p = Math.sqrt(Math.pow((x - x1), 2) + Math.pow((y - y1), 2));\n        return {x, y, p};\n    } else {\n        return;\n    }\n}\n\nfunction angle_2points(x1, y1, x2, y2) {\n    return Math.atan2(y2 - y1, x2 - x1);\n}\n\nfunction angle_3points(a, b, c) {\n    const x1 = a.x - b.x,\n        x2 = c.x - b.x,\n        y1 = a.y - b.y,\n        y2 = c.y - b.y,\n        d1 = Math.sqrt(x1 * x1 + y1 * y1),\n        d2 = Math.sqrt(x2 * x2 + y2 * y2);\n    //console.log(\"angle: \", (Math.acos((x1* x2 + y1 * y2) / (d1 * d2))* 180) / Math.PI);\n    return Math.acos((x1* x2 + y1 * y2) / (d1 * d2));\n}\n\nfunction dotProductWithAngle(lenA, lenB, angle) {\n    return lenA * lenB * Math.cos(angle);\n}\n\nfunction dotProduct(vec1, vec2) {\n    return vec1.x * vec2.x + vec1.y * vec2.y;\n}\n\nfunction crossProduct(a, b) {\n    return (a.x * b.y - b.x * a.y);\n}\n\nfunction isPointOnTheLine(point, line, m_error = 0) {\n    return  (\n        ((point.x >= (line.x1 - m_error)) && (point.x <= (line.x2 + m_error))) || \n                ((point.x <= (line.x1 + m_error)) && (point.x >= (line.x2 - m_error)))\n    ) && (\n        ((point.y >= (line.y1 - m_error)) && (point.y <= (line.y2 + m_error))) || \n                ((point.y <= (line.y1 + m_error)) && (point.y >= (line.y2 - m_error)))\n    );\n}\n\nfunction countDistance(obj1, obj2) {\n    return new Vector(obj1.x, obj1.y, obj2.x, obj2.y).length;\n}\n\nfunction isLineShorter(line1, line2) {\n    return (new Vector(line1.x1, line1.y1, line1.x2, line1.y2)).length < (new Vector(line2.x1, line2.y1, line2.x2, line2.y2)).length;\n}\n\nfunction isPointLineIntersect(point, line) {\n    const lineL = new Vector(line.x1, line.y1, line.x2, line.y2).length,\n        lengthAB = new Vector(line.x1, line.y1, point.x, point.y).length + new Vector(line.x2, line.y2, point.x, point.y).length;\n\n    if (lengthAB <= lineL + 0.2) {\n        //Logger.debug(\"point to line intersect. line len: \" + lineL + \", line AB len: \" + lengthAB);\n        return true;\n    }\n    return false;\n}\n\n/**\n * \n * @param {Array<Array<number>>} polygon \n * @param {{x1:number, y1:number, x2:number, y2:number}} line \n * @returns {{x:number, y:number, p:number} | null}\n * @ignore\n */\nfunction isPolygonLineIntersect(polygon, line) {\n    const len = polygon.length;\n    for (let i = 0; i < len; i+=1) {\n        let curr = polygon[i],\n            next = polygon[i+1];\n        //if next item not exist and current is not first\n        if (!next) {\n            // if current vertex is not the first one\n            if (!(curr[0] === polygon[0][0] && curr[1] === polygon[0][1])) {\n                next = polygon[0];\n            } else {\n                continue;\n            }\n        }\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\n        const intersection = countClosestTraversal2(edge, line);\n        if (intersection) {\n            return intersection;\n        }\n    }\n    if (polygon[len-1][0] !== polygon[0][0] && polygon[len-1][1] !== polygon[0][1]) {\n        //check one last item\n        const curr = polygon[len - 1],\n            next = polygon[0];\n        const edge = { x1: curr[0], y1: curr[1], x2: next[0], y2: next[1] };\n        const intersection = countClosestTraversal2(edge, line);\n        if (intersection) {\n            return intersection;\n        }\n    }\n    return null;\n}\n\nfunction isPointPolygonIntersect(/*x, y, polygon*/) {\n    //const vertices = polygon.vertices;\n\n    return false;\n}\n\nfunction isPointRectIntersect(x, y, rect) {\n    if (x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.y + rect.height) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isPointCircleIntersect(x, y, circle) {\n    const radius = circle.width,\n        lineToCircleCenter = new Vector(x, y, circle.x, circle.y),\n        pointCircleLineLength = lineToCircleCenter.length;\n    if (pointCircleLineLength < radius)\n        return true;\n    else\n        return false;\n}\n\nfunction generateUniqId() {\n    return Math.round(Math.random() * 1000000); \n}\n\nfunction verticesArrayToArrayNumbers(array) {\n    const len = array.length,\n        numbers = [];\n    for (let i = 0; i < len; i++) {\n        const vertex = array[i];\n        numbers.push([vertex.x, vertex.y]);\n    }\n    return numbers;\n}\n\nexport { \n    isMobile, \n    isSafari, \n    pointToCircleDistance, \n    countClosestTraversal, \n    countClosestTraversal2,\n    angle_2points,\n    angle_3points,\n    dotProductWithAngle,\n    dotProduct,\n    crossProduct,\n    isPointOnTheLine,\n    isLineShorter,\n    isPointLineIntersect,\n    isPointPolygonIntersect,\n    isPointRectIntersect,\n    isPointCircleIntersect,\n    isPolygonLineIntersect,\n    generateUniqId,\n    verticesArrayToArrayNumbers,\n    countDistance };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.es6.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"jsge:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\t\tscript.type = \"module\";\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t};\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (typeof import.meta.url === \"string\") scriptUrl = import.meta.url\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkjsge\"] = self[\"webpackChunkjsge\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.js\");\n",""],"names":[],"sourceRoot":""}