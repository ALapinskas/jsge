var e,t,s={},i={};function r(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={exports:{}};return s[e](n,n.exports,r),n.exports}r.m=s,r.d=(e,t)=>{for(var s in t)r.o(t,s)&&!r.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},r.f={},r.e=e=>Promise.all(Object.keys(r.f).reduce(((t,s)=>(r.f[s](e,t),t)),[])),r.u=e=>e+".index.es6.min.js",r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e={},t="jsge:",r.l=(s,i,n,a)=>{if(e[s])e[s].push(i);else{var o,l;if(void 0!==n)for(var c=document.getElementsByTagName("script"),h=0;h<c.length;h++){var d=c[h];if(d.getAttribute("src")==s||d.getAttribute("data-webpack")==t+n){o=d;break}}o||(l=!0,(o=document.createElement("script")).type="module",o.charset="utf-8",o.timeout=120,r.nc&&o.setAttribute("nonce",r.nc),o.setAttribute("data-webpack",t+n),o.src=s),e[s]=[i];var u=(t,i)=>{o.onerror=o.onload=null,clearTimeout(g);var r=e[s];if(delete e[s],o.parentNode&&o.parentNode.removeChild(o),r&&r.forEach((e=>e(i))),t)return t(i)},g=setTimeout(u.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=u.bind(null,o.onerror),o.onload=u.bind(null,o.onload),l&&document.head.appendChild(o)}},r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e;if("string"==typeof import.meta.url&&(e=import.meta.url),!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),r.p=e})(),(()=>{var e={179:0};r.f.j=(t,s)=>{var i=r.o(e,t)?e[t]:void 0;if(0!==i)if(i)s.push(i[2]);else{var n=new Promise(((s,r)=>i=e[t]=[s,r]));s.push(i[2]=n);var a=r.p+r.u(t),o=new Error;r.l(a,(s=>{if(r.o(e,t)&&(0!==(i=e[t])&&(e[t]=void 0),i)){var n=s&&("load"===s.type?"missing":s.type),a=s&&s.target&&s.target.src;o.message="Loading chunk "+t+" failed.\n("+n+": "+a+")",o.name="ChunkLoadError",o.type=n,o.request=a,i[1](o)}}),"chunk-"+t,t)}};var t=(t,s)=>{var i,n,[a,o,l]=s,c=0;if(a.some((t=>0!==e[t]))){for(i in o)r.o(o,i)&&(r.m[i]=o[i]);l&&l(r)}for(t&&t(s);c<a.length;c++)n=a[c],r.o(e,n)&&e[n]&&e[n][0](),e[n]=0},s=self.webpackChunkjsge=self.webpackChunkjsge||[];s.forEach(t.bind(null,0)),s.push=t.bind(null,s.push.bind(s))})();var n={};r.d(n,{oX:()=>l,QD:()=>ae,xl:()=>a,r4:()=>ye,xP:()=>we,jQ:()=>Re,bq:()=>y,P6:()=>o});var a={};r.r(a),r.d(a,{Rectangle:()=>B,Vector:()=>N,Vertex:()=>M});var o={};r.r(o),r.d(o,{angle_2points:()=>j,angle_3points:()=>V,countClosestTraversal:()=>G,countClosestTraversal2:()=>k,countDistance:()=>H,crossProduct:()=>z,dotProduct:()=>Y,dotProductWithAngle:()=>U,generateUniqId:()=>te,isCircleLineIntersect:()=>ee,isLineShorter:()=>X,isMobile:()=>L,isPointCircleIntersect:()=>$,isPointLineIntersect:()=>Q,isPointOnTheLine:()=>K,isPointPolygonIntersect:()=>J,isPointRectIntersect:()=>q,isPolygonLineIntersect:()=>Z,isSafari:()=>W,pointToCircleDistance:()=>F,verticesArrayToArrayNumbers:()=>se});const l={MODE:{DEBUG:"DEBUG",PRODUCTION:"PRODUCTION"},SCREENS:{},AUDIO:{},CONNECTION_STATUS:{DISCONNECTED:"disconnected",CONNECTED:"connected",CONNECTION_LOST:"connection lost"},EVENTS:{SYSTEM:{START_PAGE:"START_PAGE",STOP_PAGE:"STOP_PAGE",RENDER:{START:"start",END:"end"}},GAME:{BOUNDARIES_COLLISION:"BOUNDARIES_COLLISION",OBJECTS_COLLISION:"OBJECTS_COLLISION"},WEBSOCKET:{SERVER_CLIENT:{CONNECTION_STATUS_CHANGED:"CONNECTION_STATUS_CHANGED",ROOMS_INFO:"roomsInfo",CREATED:"created",JOINED:"joined",FULL:"full",DISCONNECTED:"disconnected",SERVER_MESSAGE:"message",RESTARTED:"restarted"},CLIENT_SERVER:{ROOMS_INFO_REQUEST:"gatherRoomsInfo",CREATE_OR_JOIN:"create or join",RESTART_REQUEST:"restart",CLIENT_MESSAGE:"message"}}},WEBGL:{DRAW_PROGRAMS:{PRIMITIVES:"drawPrimitives",IMAGES:"drawImages"}},DRAW_TYPE:{RECTANGLE:"rect",CONUS:"conus",CIRCLE:"circle",POLYGON:"polygon",LINE:"line",TEXT:"text",IMAGE:"image"},LAYERS:{DEFAULT:"default-view-layer",BOUNDARIES:"boundaries-view-layer"},GAME_OPTIONS:{},LIBRARY:{WEBGL:"webgl"},OPTIMIZATION:{CIRCLE_TIME_CALC:{AVERAGES:"AVERAGES",CURRENT:"CURRENT"},NATIVE_JS:{NOT_OPTIMIZED:"NOT_OPTIMIZED",OPTIMIZED:"OPTIMIZED"},WEB_ASSEMBLY:{ASSEMBLY_SCRIPT:"ASSEMBLY_SCRIPT",WASM:"WASM"}}},c="CREATE_INSTANCE_ERROR",h="VIEW_NOT_EXIST",d="UNEXPECTED_INPUT_PARAMS",u="WEBGL_ERROR",g="NOT_FOUND",m="WORLD_DIMENSIONS_NOT_SET",f="UNHANDLED_DRAW_ISSUE",E="UNEXPECTED_WORLD_SIZE",_="AUDIO_NOT_REGISTERED",S="AUDIO_NOT_LOADED",T="POLYGON_VERTICES_NOT_CORRECT",p="DEPRECATED_PARAMETER";function R(e,t){throw new Error(e+": "+t)}function A(e,t){console.warn(e,t)}class x{#e;#t;#s;#i;#r=0;#n=0;#a=0;#o=0;#l=0;#c=[];#h=[];#d=[];#u;#g=!1;isOffsetTurnedOff(){return this.#u}set mapRotate(e){this.#l=e}#m(e){this.#c.push([e.x1,e.y1,e.x2,e.y2])}_addBoundariesArray(e){this.#c.push(...e)}_clearBoundaries(){this.#c=[]}_setWorldDimensions(e,t){this.#e=e,this.#t=t}_setCanvasDimensions(e,t){this.#s=e,this.#i=t}_setMapBoundaries(){const[e,t]=[this.#e,this.#t],[s,i]=[this.#r,this.#n],r=e-s,n=t-i;e&&t||A(m,"Can't set map boundaries."),this.#m({x1:0,y1:0,x2:r,y2:0}),this.#m({x1:r,y1:0,x2:r,y2:n}),this.#m({x1:r,y1:n,x2:0,y2:n}),this.#m({x1:0,y1:n,x2:0,y2:0})}_setWholeWorldMapBoundaries(){const[e,t]=[this.#e,this.#t];e&&t||A(m,"Can't set map boundaries."),this.#h.push([0,0,e,0]),this.#h.push([e,0,e,t]),this.#h.push([e,t,0,t]),this.#h.push([0,t,0,0])}_mergeBoundaries(e=!1){const t=e?this.getWholeWorldBoundaries():this.getBoundaries(),s=new Set(t);for(const e of s.values()){const t=e[0],i=e[1],r=e[2],n=e[3];for(const a of s.values()){const o=a[0],l=a[1],c=a[2],h=a[3];t===c&&i===h&&r===o&&n===l&&(s.delete(e),s.delete(a)),r!==o||n!==l||t!==c&&i!==h||(a[0]=t,a[1]=i,s.delete(e))}}e?this.#c=Array.from(s):this.#h=Array.from(s),s.clear()}_setWholeMapBoundaries(e){this.#h.push(...e)}_enableMapBoundaries(){this.#g=!0}getBoundaries(){return this.#c}getWholeWorldBoundaries(){return this.#h}get isWorldBoundariesEnabled(){return this.#g}get canvasDimensions(){return[this.#s,this.#i]}get worldDimensions(){return[this.#e,this.#t]}get worldOffset(){return[this.#r,this.#n]}get mapCenter(){return[this.#a,this.#o]}get mapRotate(){return this.#l}centerCameraPosition=(e,t)=>{let[s,i]=this.worldOffset;const[r,n]=this.canvasDimensions,[a,o]=this.worldDimensions,l=r/2,c=n/2,h=c-i;if(l-s<e)if(e<a-l){const t=e-l;t>=0&&(this.#r=Math.round(t))}else if(a>r){const e=a-r;this.#r=Math.round(e)}if(h<t)if(t<o-c){const e=t-c;e>=0&&(this.#n=Math.round(e))}else if(o>n){const e=o-n;this.#n=Math.round(e)}this.#a=e,this.#o=t};personRotatedCenterCamera=(e,t,s)=>{console.log("new centering algorithm")};get renderObjects(){return this.#d}getObjectsByInstance(e){return this.#d.filter((t=>t instanceof e))}_sortRenderObjectsBySortIndex(){this.#d=this.#d.sort(((e,t)=>e.sortIndex-t.sortIndex))}set _renderObject(e){this.#d.push(e)}set _renderObjects(e){this.#d=e}}const y={mode:l.MODE.DEBUG,gameOptions:{library:l.LIBRARY.WEBGL,checkWebGlErrors:!1,debugMobileTouch:!1,optimization:l.OPTIMIZATION.NATIVE_JS.OPTIMIZED,loadingScreen:{backgroundColor:"rgba(128, 128, 128, 0.6)",loadingBarBg:"rgba(128, 128, 128, 1)",loadingBarProgress:"rgba(128, 128, 128, 0.2)"},boundaries:{drawLayerBoundaries:!1,drawObjectBoundaries:!1,boundariesColor:"rgba(224, 12, 21, 0.6)",boundariesWidth:2},render:{minCircleTime:16,circleTimeCalc:{check:l.OPTIMIZATION.CIRCLE_TIME_CALC.AVERAGES,averageFPStime:1e4},boundaries:{mapBoundariesEnabled:!0,realtimeCalculations:!0,wholeWorldPrecalculations:!1}}},network:{address:"https://gameserver.reslc.ru:9009",gatherRoomsInfoInterval:5e3},canvasMaxSize:{width:900,height:960},worldSize:{width:960,height:960},defaultCanvasKey:"default"};class v{static debug(...e){y.mode===l.MODE.DEBUG&&e.forEach((e=>console.log(e)))}}const P={loadstart:"loadstart",progress:"progress",abort:"abort",error:"error",load:"load",timeout:"timeout"};class w{#f;#E;#_=new Map;#S=new Map;constructor(e,t){this.#f=e,this.#E=(e,s,...i)=>{const r=t(e,s,...i);if(r instanceof Promise)return r.then((t=>this.#T(t,e)));I("uploadMethod should be instance of Promise and return upload result value")}}#T=(e,t)=>new Promise(((s,i)=>{e&&0!==e.length||O("uploadMethod for "+this.#f+" should return Promise with upload value"),this.#p(t,e),this.#R(t),s()}));#p(e,t){this.#S.set(e,t)}#R(e){this.#_.delete(e)}get filesWaitingForUpload(){return this.#_.size}get loadingQueue(){return this.#_}get uploadMethod(){return this.#E}_addFile=(e,t)=>{this.#_.has(e)&&O("File "+this.#f+" with key "+e+" is already added"),this.#_.set(e,t)};_isFileInQueue=e=>this.#_.has(e);_getFile=e=>this.#S.get(e)}class b{#A=new EventTarget;#x=new Map;#y=0;constructor(){this.registerLoader("Audio",this._loadAudio),this.registerLoader("Image",this._loadImage),this.registerLoader("TileMap",this._loadTileMap),this.registerLoader("TileSet",this._loadTileSet)}get filesWaitingForUpload(){let e=0;return Array.from(this.#x.values()).map((t=>e+=t.filesWaitingForUpload)),e}registerLoader=(e,t=this._defaultUploadMethod)=>{this["add"+e]=(t,s,...i)=>{this.addFile(e,t,s,...i)},this["get"+e]=t=>this.getFile(e,t),this["is"+e+["InQueue"]]=t=>this.isFileInQueue(e,t);const s=this.#x.get(e)||new w(e,t);this.#x.set(e,s)};preload(){return this.#v(),new Promise(((e,t)=>{this.#P().then((()=>{this.filesWaitingForUpload?this.#P().then((()=>{this.#w(),e()})):(this.#w(),e())}))}))}#P(){let e=[];return Array.from(this.#x.values()).forEach((t=>{Array.from(t.loadingQueue.entries()).forEach((s=>{e.push(t.uploadMethod(s[0],...s[1]))}))})),Promise.allSettled(e).then((e=>{e.forEach((e=>{if("rejected"===e.status){const t=e.reason;O(t),this.#b(t)}}))}))}addEventListener(e,t,...s){P[e]?this.#A.addEventListener(e,t,...s):O("Event type should be one of the ProgressEvent.type")}removeEventListener(e,t,...s){this.#A.removeEventListener(e,t,...s)}_loadTileSet=(e,t,s=1,i)=>(this.#I(t),fetch(i?i+t:t).then((e=>e.json())).then((e=>{const{name:t,image:r}=e;return t&&r&&!this.isFileInQueue("Image",t)&&this.addImage(t,i?i+r:r),e.gid=s,Promise.resolve(e)})).catch((()=>{const e=new Error("Can't load related tileset "+t);return Promise.reject(e)})));_defaultUploadMethod=(e,t)=>fetch(t);_loadTileMap=(e,t,s=!0)=>(this.#O(t),fetch(t).then((e=>e.json())).then((e=>{let i,r=t.split("/"),n=r.length;if(r[n-1].includes(".tmj")||r[n-1].includes(".json")?(r.pop(),i=r.join("/")+"/"):(r[n-2].includes(".tmj")||r[n-2].includes(".json"))&&(r.splice(n-2,2),i=r.join("/")+"/"),!0===s&&e.tilesets&&e.tilesets.length>0){const t=[];return e.tilesets.forEach(((e,s)=>{const{firstgid:r,source:n}=e,a=this._loadTileSet("default-"+r,n,r,i).then((e=>(this.#C(),Promise.resolve(e))));t.push(a)})),Promise.all(t).then((t=>{for(let s=0;s<t.length;s++){const i=t[s];e.tilesets[s].data=i}return Promise.resolve(e)}))}return Promise.resolve(e)})).catch((e=>(e.message.includes("JSON.parse:")&&(e=new Error("Can't load tilemap "+t)),this.#b(e),Promise.reject(e)))));_loadAudio=(e,t)=>new Promise(((e,s)=>{const i=new Audio(t);i.addEventListener("loadeddata",(()=>{this.#C(),e(i)})),i.addEventListener("error",(()=>{const e=new Error("Can't load audio "+t);this.#b(e),s(e)}))}));_loadImage=(e,t,s="anonymous")=>new Promise(((e,i)=>{const r=new Image;r.crossOrigin=s,r.onload=()=>{createImageBitmap(r).then((t=>{this.#C(),e(t)}))},r.onerror=()=>{const e=new Error("Can't load image "+t);this.#b(e),i(e)},r.src=t}));#I(e){e.includes(".tsj")||e.includes(".json")||I("Related Tileset file type is not correct, only .tsj or .json files are supported")}#O(e){e.includes(".tmj")||e.includes(".json")||I("Tilemap file type is not correct, only .tmj or .json files are supported")}addFile(e,t,s,...i){const r=this.#x.get(e);r?(this.#D(t,s),r._addFile(t,[s,...i])):I("Loader for "+e+" is not registered!")}isFileInQueue(e,t){const s=this.#x.get(e);if(s)return s._isFileInQueue(t);I("Loader for "+e+" is not registered!")}getFile(e,t){const s=this.#x.get(e);if(s)return s._getFile(t);I("Loader for "+e+" is not registered!")}#D(e,t){const s="fileKey and url should be provided";e&&0!==e.trim().length||I(s),t&&0!==t.trim().length||I(s)}#v(){let e=this.filesWaitingForUpload;this.#A.dispatchEvent(new ProgressEvent(P.loadstart,{total:e}))}#w(){this.#A.dispatchEvent(new ProgressEvent(P.load))}#C(){const e=this.filesWaitingForUpload;this.#y+=1,this.#A.dispatchEvent(new ProgressEvent(P.progress,{lengthComputable:!0,loaded:this.#y,total:e}))}#b(e){this.#A.dispatchEvent(new ProgressEvent(P.error,{error:e}))}}function I(e){throw new Error(e)}function O(e){console.warn(e)}class C{#M;#B;#N;#L;#W;#F=0;#G=0;#k=te();#j=!1;#V;#U;#u=!1;#Y=!1;constructor(e,t,s,i){this.#M=t,this.#B=s,this.#N=i,this.#L=e}get bgColor(){return this.#N}set bgColor(e){this.#N=e}get type(){return this.#L}get x(){return this.#M}get y(){return this.#B}set x(e){this.#M=e}set y(e){this.#B=e}get sortIndex(){return this.#F}set sortIndex(e){this.#F=e}get blendFunc(){return this.#W}set blendFunc(e){this.#W=e}get rotation(){return this.#G}set rotation(e){this.#G=e}get id(){return this.#k}get isRemoved(){return this.#j}destroy(){this.#j=!0}get isMaskAttached(){return!!this.#V}get _maskId(){return this.#V}setMask(e){e._isMask=!0,this.#V=e.id}removeMask(){this.#V=null}set _isMask(e){this.#U=e}get _isMask(){return this.#U}get isOffsetTurnedOff(){return this.#u}turnOffOffset(){this.#u=!0}_calculateRectVertices=(e,t)=>{const s=e/2,i=t/2;return[[-s,-i],[s,-i],[s,i],[-s,i]]};_calculateConusVertices(e,t=2*Math.PI,s=Math.PI/14){let i=[0,0];for(let r=0;r<=t;r+=s){let t=Math.cos(r)*e,s=Math.sin(r)*e;i.push(t,s)}return i}_calculateConusBoundaries(e,t=2*Math.PI,s=Math.PI/14){let i=[];for(let r=0;r<=t;r+=s){let t=Math.cos(r)*e,s=Math.sin(r)*e;i.push([t,s])}return i}_convertVerticesArray(e){return void 0!==e[0].x&&void 0!==e[0].y?se(e):e}}class D{#z;#K;#H;#X;#Q;#Z;#J;#q;#$;#V;#F=0;#u;constructor(e,t,s,i,r,n,a=!1,o){this.#z=e,this.#K=t,this.#H=s,this.#X=i,this.#Z=[],this.#Q=r,this.#J=n,this.#q=a,this.#$=a||!1,o&&this.setMask(o)}get layerKey(){return this.#z}get tileMapKey(){return this.#K}get tilemap(){return this.#H}get tilesets(){return this.#X}get tilesetImages(){return this.#Q}get layerData(){return this.#J}get setBoundaries(){return this.#q}get drawBoundaries(){return this.#$}set drawBoundaries(e){this.#$=e}get _maskId(){return this.#V}setMask(e){this.#V=e.id}removeMask(){this.#V=null}get sortIndex(){return this.#F}set sortIndex(e){this.#F=e}get isOffsetTurnedOff(){return this.#u}turnOffOffset(){this.#u=!0}get _textureStorages(){return this.#Z}_setTextureStorage(e,t){this.#Z[e]=t}}class M{#M;#B;constructor(e,t){this.#M=e,this.#B=t}get x(){return this.#M}get y(){return this.#B}}class B{#M;#B;#ee;#v;constructor(e,t,s,i){this.#M=e,this.#B=t,this.#ee=s,this.#v=i}get x(){return this.#M}get y(){return this.#B}get width(){return this.#ee}get height(){return this.#v}}class N{#M;#B;constructor(e,t,s,i){this.#M=s-e,this.#B=i-t}get x(){return this.#M}get y(){return this.#B}get length(){return Math.sqrt(Math.pow(this.#M,2)+Math.pow(this.#B,2))}get tetaAngle(){return Math.atan2(this.#B,this.#M)}}function L(){return/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)}function W(){return/^((?!chrome|android).)*safari/i.test(navigator.userAgent)}function F(e,t,s){return new N(e,t,s.x,s.y).length-s.r}function G(e,t){const s=t.x1,i=t.y1,r=t.x2,n=t.y2,a=e.x1,o=e.y1,l=s,c=i,h=r-s,d=n-i,u=a,g=o,m=e.x2-a,f=e.y2-o,E=Math.sqrt(h*h+d*d),_=Math.sqrt(m*m+f*f);if(h/E==m/_&&d/E==f/_)return null;const S=(h*(g-c)+d*(l-u))/(m*d-f*h),T=(u+m*S-l)/h;return T<0||isNaN(T)||S<0||S>1?null:{x:l+h*T,y:c+d*T,p:T}}function k(e,t){const s=t.x1,i=t.y1,r=t.x2,n=t.y2,a=e.x1,o=e.y1,l=e.x2,c=e.y2,h=(s-r)*(o-c)-(i-n)*(a-l);if(0===h)return;let d=((s*n-i*r)*(a-l)-(s-r)*(a*c-o*l))/h,u=((s*n-i*r)*(o-c)-(i-n)*(a*c-o*l))/h;const g={x:d,y:u};return K(g,e,1e-13)&&K(g,t,1e-13)?{x:d,y:u,p:Math.sqrt(Math.pow(d-s,2)+Math.pow(u-i,2))}:void 0}function j(e,t,s,i){return Math.atan2(i-t,s-e)}function V(e,t,s){const i=e.x-t.x,r=s.x-t.x,n=e.y-t.y,a=s.y-t.y,o=Math.sqrt(i*i+n*n),l=Math.sqrt(r*r+a*a);return Math.acos((i*r+n*a)/(o*l))}function U(e,t,s){return e*t*Math.cos(s)}function Y(e,t){return e.x*t.x+e.y*t.y}function z(e,t){return e.x*t.y-t.x*e.y}function K(e,t,s=0){return(e.x>=t.x1-s&&e.x<=t.x2+s||e.x<=t.x1+s&&e.x>=t.x2-s)&&(e.y>=t.y1-s&&e.y<=t.y2+s||e.y<=t.y1+s&&e.y>=t.y2-s)}function H(e,t){return new N(e.x,e.y,t.x,t.y).length}function X(e,t){return new N(e.x1,e.y1,e.x2,e.y2).length<new N(t.x1,t.y1,t.x2,t.y2).length}function Q(e,t){const s=new N(t.x1,t.y1,t.x2,t.y2).length;return new N(t.x1,t.y1,e.x,e.y).length+new N(t.x2,t.y2,e.x,e.y).length<=s+.2}function Z(e,t){const s=e.length;for(let i=0;i<s;i+=1){let s=e[i],r=e[i+1];if(!r){if(s[0]===e[0][0]&&s[1]===e[0][1])continue;r=e[0]}const n=k({x1:s[0],y1:s[1],x2:r[0],y2:r[1]},t);if(n)return n}if(e[s-1][0]!==e[0][0]&&e[s-1][1]!==e[0][1]){const i=e[s-1],r=e[0],n=k({x1:i[0],y1:i[1],x2:r[0],y2:r[1]},t);if(n)return n}return null}function J(){return!1}function q(e,t,s){return e>=s.x&&e<=s.width+s.x&&t>=s.y&&t<=s.y+s.height}function $(e,t,s){const i=s.width;return new N(e,t,s.x,s.y).length<i}function ee(e,t,s,i){const r=i.x1,n=i.y1,a=i.x2,o=i.y2,l={x:r-e,y:n-t},c={x:a-e,y:o-t},h={x:a-r,y:o-n},d={x:r-a,y:n-o},u=Math.sqrt(Math.pow(h.x,2)+Math.pow(h.y,2)),g=Y(l,d),m=Y(c,h);let f;return g>0&&m>0?(f=z(l,c)/u,f<0&&(f*=-1)):f=Math.min(l.length,c.length),f<=s}function te(){return Math.round(1e6*Math.random())}function se(e){const t=e.length,s=[];for(let i=0;i<t;i++){const t=e[i];s.push([t.x,t.y])}return s}class ie{#te;#se;#ie=!0;constructor(e,t=0){this.#se=e,this.#te=t}get _isTextureRecalculated(){return this.#ie}set _isTextureRecalculated(e){this.#ie=e}get _texture(){return this.#se}set _texture(e){this.#se=e}get _textureIndex(){return this.#te}}class re{#re;#ne;#ae;#oe;#le;#ce=new Map;#he=new Map;constructor(e,t){e&&e instanceof WebGLRenderingContext||R(d," context parameter should be specified and equal to WebGLRenderingContext"),this.#re=e,this.#ae=t,this.#ne=t.checkWebGlErrors,this.#oe=e.createBuffer(),this.#le=e.createBuffer()}getProgram(e){return this.#ce.get(e)}getProgramVarLocations(e){return this.#he.get(e)}_fixCanvasSize(e,t){this.#re.viewport(0,0,e,t)}_initWebGlAttributes=()=>{const e=this.#re;return e.enable(e.BLEND),e.enable(e.STENCIL_TEST),e.stencilFunc(e.ALWAYS,1,255),e.stencilOp(e.KEEP,e.KEEP,e.REPLACE),Promise.resolve()};_initiateWasm=()=>new Promise(((e,t)=>{this.layerData=new WebAssembly.Memory({initial:50}),this.layerDataFloat32=new Float32Array(this.layerData.buffer);const s={env:{data:this.layerData,logi:console.log,logf:console.log}};fetch("/src/wa/calculateBufferData.wasm").then((e=>e.arrayBuffer())).then((e=>WebAssembly.instantiate(e,s))).then((t=>{this.calculateBufferData=t.instance.exports.calculateBufferData,e()}))}));_clearView(){const e=this.#re;e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT)}_render(e,t,s=0){const i=this.#re,r=this.#ne?i.getError():0;if(0!==r)throw console.error(r),new Error("Error num: "+r);return i.drawArrays(t,s,e),i.stencilFunc(i.ALWAYS,1,255),Promise.resolve()}_registerAndCompileWebGlProgram(e,t,s,i,r){const n=this.#de(t,s),a=this.#ue(n,i,r);return this.#ce.set(e,n),this.#he.set(e,a),Promise.resolve()}#de(e,t){const s=this.#re,i=s.createProgram();if(i){const r=this.#ge(s,e,s.VERTEX_SHADER);r?s.attachShader(i,r):R(u,"#compileShader(vertexShaderSource) is null");const n=this.#ge(s,t,s.FRAGMENT_SHADER);if(n?s.attachShader(i,n):R(u,"#compileShader(fragmentShaderSource) is null"),s.linkProgram(i),!s.getProgramParameter(i,s.LINK_STATUS)){const e=s.getProgramInfoLog(i);R(u,`Could not compile WebGL program. \n\n${e}`)}}else R(u,"gl.createProgram() is null");return i}#ue(e,t,s){const i=this.#re;let r={};return t.forEach((t=>{r[t]=i.getUniformLocation(e,t)})),s.forEach((t=>{r[t]=i.getAttribLocation(e,t)})),r}#ge(e,t,s){const i=e.createShader(s);if(i){if(e.shaderSource(i,t),e.compileShader(i),!e.getShaderParameter(i,e.COMPILE_STATUS)){const t=e.getShaderInfoLog(i);R(u,"Couldn't compile webGl program. \n\n"+t)}}else R(u,`gl.createShader(${s}) is null`);return i}_bindPrimitives=(e,t,s,i,r)=>{const[n,a]=!0===e.isOffsetTurnedOff?[0,0]:s.worldOffset,o=e.x-n,c=e.y-a,h=[1,1],d=e.rotation,{u_translation:u,u_rotation:g,u_scale:m,u_resolution:f,u_color:E,a_position:_,u_fade_min:S}=r;let p=0;switch(t.useProgram(i),t.uniform2f(f,t.canvas.width,t.canvas.height),t.uniform2f(u,o,c),t.uniform2f(m,h[0],h[1]),t.uniform1f(g,d),t.uniform1f(S,0),t.enableVertexAttribArray(_),t.bindBuffer(t.ARRAY_BUFFER,this.#oe),e.type){case l.DRAW_TYPE.RECTANGLE:this.#me(e.width,e.height),p+=6;break;case l.DRAW_TYPE.TEXT:break;case l.DRAW_TYPE.CIRCLE:{const s=e.vertices;t.bufferData(this.#re.ARRAY_BUFFER,new Float32Array(s),this.#re.STATIC_DRAW),p+=s.length/2;break}case l.DRAW_TYPE.POLYGON:{const t=this.#fe(e.vertices);this.#Ee(t);const s=t.length;if(s%3!=0)return A(T,`polygons ${e.id}, vertices are not correct, skip drawing`),Promise.reject();p+=s/2;break}}const R=t.FLOAT;t.vertexAttribPointer(_,2,R,!1,0,0);const x=this.#_e(e.bgColor);return t.uniform4f(E,x[0]/255,x[1]/255,x[2]/255,x[3]),e.blendFunc&&t.blendFunc(e.blendFunc[0],e.blendFunc[1]),e.isMaskAttached?t.stencilFunc(t.EQUAL,e._maskId,255):e._isMask&&t.stencilFunc(t.ALWAYS,e.id,255),Promise.resolve([p,t.TRIANGLES])};_bindConus=(e,t,s,i,r)=>{const[n,a]=!0===e.isOffsetTurnedOff?[0,0]:s.worldOffset,o=e.x-n,l=e.y-a,c=[1,1],h=e.rotation,{u_translation:d,u_rotation:u,u_scale:g,u_resolution:m,u_color:f,a_position:E,u_fade_max:_,u_fade_min:S}=r,T=e.vertices,p=e.bgColor,R=e.fade_min,A=e.radius;let x=0;t.useProgram(i),t.uniform2f(m,t.canvas.width,t.canvas.height),t.uniform2f(d,o,l),t.uniform2f(g,c[0],c[1]),t.uniform1f(u,h),t.uniform1f(S,R),t.uniform1f(_,A),t.bindBuffer(t.ARRAY_BUFFER,this.#oe),t.bufferData(this.#re.ARRAY_BUFFER,new Float32Array(T),this.#re.STATIC_DRAW),t.enableVertexAttribArray(E);const y=t.FLOAT;t.vertexAttribPointer(E,2,y,!1,0,0),x+=T.length/2,e.blendFunc&&t.blendFunc(e.blendFunc[0],e.blendFunc[1]);const v=this.#_e(p);return t.uniform4f(f,v[0]/255,v[1]/255,v[2]/255,v[3]),e.isMaskAttached?t.stencilFunc(t.EQUAL,e._maskId,255):e._isMask&&t.stencilFunc(t.ALWAYS,e.id,255),Promise.resolve([x,t.TRIANGLE_FAN])};_bindText=(e,t,s,i,r)=>{const{u_translation:n,u_rotation:a,u_scale:o,u_resolution:l,a_position:c,a_texCoord:h,u_image:d}=r,{width:u,height:g}=e.boundariesBox,[m,f]=(e.text,!0===e.isOffsetTurnedOff?[0,0]:s.worldOffset),E=e.x-m,_=e.y-f-g,S=[1,1],T=E+u,p=_+g,R=[E,_,T,_,E,p,E,p,T,_,T,p];let A=0;t.useProgram(i),t.uniform2f(l,t.canvas.width,t.canvas.height),t.uniform2f(n,E,_),t.uniform2f(o,S[0],S[1]),t.uniform1f(a,0),t.bindBuffer(t.ARRAY_BUFFER,this.#oe),t.bufferData(t.ARRAY_BUFFER,new Float32Array(R),t.STATIC_DRAW),t.enableVertexAttribArray(c);const x=t.FLOAT;t.vertexAttribPointer(c,2,x,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.#le),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),t.STATIC_DRAW),t.enableVertexAttribArray(h),t.vertexAttribPointer(h,2,t.FLOAT,!1,0,0),A+=6,t.blendFunc(t.ONE,t.ONE_MINUS_SRC_ALPHA);let y=e._textureStorage;return y||(y=new ie(t.createTexture()),e._textureStorage=y),!0===y._isTextureRecalculated?(this.#Se(t,y._texture,e._textureCanvas),y._isTextureRecalculated=!1):this.#Te(t,y._texture),t.uniform1i(d,y._textureIndex),Promise.resolve([6,t.TRIANGLES])};_bindImage=(e,t,s,i,r)=>{const{u_translation:n,u_rotation:a,u_scale:o,u_resolution:l,a_position:c,a_texCoord:h,u_image:d}=r,[u,g]=!0===e.isOffsetTurnedOff?[0,0]:s.worldOffset,m=e.x-u,f=e.y-g,E=e.image,_=e.imageIndex,S=(e.key,e._maskId),T=[1,1];let p=0,R=0,A=0;if(0!==_){const t=E.width/e.width;p=_%t*e.width,R=Math.floor(_/t)*e.height}const x=m-e.width/2,y=f-e.height/2,v=x+e.width,P=y+e.height,w=1/E.width*p,b=1/E.height*R,I=w+1/E.width*e.width,O=b+1/E.height*e.height,C=[x,y,v,y,x,P,x,P,v,y,v,P],D=[w,b,I,b,w,O,w,O,I,b,I,O];t.useProgram(i),t.uniform2f(l,t.canvas.width,t.canvas.height),t.uniform2f(n,m,f),t.uniform2f(o,T[0],T[1]),t.uniform1f(a,e.rotation),t.bindBuffer(t.ARRAY_BUFFER,this.#oe),t.bufferData(t.ARRAY_BUFFER,new Float32Array(C),t.STATIC_DRAW),A+=C.length/2,t.enableVertexAttribArray(c);const M=t.FLOAT;t.vertexAttribPointer(c,2,M,!1,0,0),t.bindBuffer(t.ARRAY_BUFFER,this.#le),t.bufferData(t.ARRAY_BUFFER,new Float32Array(D),t.STATIC_DRAW),t.enableVertexAttribArray(h),t.vertexAttribPointer(h,2,t.FLOAT,!1,0,0);let B=e._textureStorage;return B||(B=new ie(t.createTexture()),e._textureStorage=B),!0===B._isTextureRecalculated?(this.#Se(t,B._texture,e.image),B._isTextureRecalculated=!1):this.#Te(t,B._texture),t.uniform1i(d,B._textureIndex),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),S&&t.stencilFunc(t.EQUAL,S,255),Promise.resolve([A,t.TRIANGLES])};_bindTileImages=async(e,t,s,i,r)=>{const{u_translation:n,u_rotation:a,u_scale:o,u_resolution:c,a_position:h,a_texCoord:d,u_image:u}=r;let g;switch(t.useProgram(i),this.#ae.optimization){case l.OPTIMIZATION.NATIVE_JS.NOT_OPTIMIZED:g=await this.#pe(e,s);break;case l.OPTIMIZATION.WEB_ASSEMBLY.WASM:g=await this.#Re(e,s);break;case l.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT:A("Sorry, "+l.OPTIMIZATION.WEB_ASSEMBLY.ASSEMBLY_SCRIPT+", is not supported, switching to default");case l.OPTIMIZATION.NATIVE_JS.OPTIMIZED:default:g=await this.#Ae(e,s)}const m=[0,0],f=[1,1],E=["SRC_ALPHA","ONE_MINUS_SRC_ALPHA"],_=e._maskId;let S=0;for(let s=0;s<g.length;s++){const i=g[s],r=i[0],l=i[1],T=(i[2],i[3]);t.uniform2f(c,t.canvas.width,t.canvas.height),t.uniform2f(n,m[0],m[1]),t.uniform2f(o,f[0],f[1]),t.uniform1f(a,0),t.bindBuffer(t.ARRAY_BUFFER,this.#oe),t.bufferData(t.ARRAY_BUFFER,r,t.STATIC_DRAW),t.enableVertexAttribArray(h);const p=2,R=t.FLOAT,A=!1,x=0,y=0;t.vertexAttribPointer(h,p,R,A,x,y),t.bindBuffer(t.ARRAY_BUFFER,this.#le),t.bufferData(t.ARRAY_BUFFER,l,t.STATIC_DRAW),t.enableVertexAttribArray(d),t.vertexAttribPointer(d,2,t.FLOAT,!1,0,y);let v=e._textureStorages[s];v||(v=new ie(t.createTexture(),s),e._setTextureStorage(s,v)),!0===v._isTextureRecalculated?(this.#Se(t,v._texture,T,v._textureIndex),v._isTextureRecalculated=!1):this.#Te(t,v._texture,v._textureIndex),t.uniform1i(u,v._textureIndex),t.blendFunc(t[E[0]],t[E[1]]),S+=r.length/2,_&&t.stencilFunc(t.EQUAL,_,255)}return Promise.resolve([S,t.TRIANGLES])};_drawPolygon(e,t){const[s,i]=!0===e.isOffsetTurnedOff?[0,0]:t.worldOffset,r=e.x-s,n=e.y-i,a=e.rotation||0,o=e.vertices,c=this.#ae.boundaries.boundariesColor,h=this.getProgram(l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),{u_translation:d,u_rotation:u,u_scale:g,u_resolution:m,u_color:f,a_position:E,u_fade_max:_,u_fade_min:S}=this.getProgramVarLocations(l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),p=this.#re;let R=0;p.useProgram(h),p.uniform2f(m,p.canvas.width,p.canvas.height),p.uniform2f(d,r,n),p.uniform2f(g,1,1),p.uniform1f(u,a),p.uniform1f(S,0),p.enableVertexAttribArray(E),p.bindBuffer(p.ARRAY_BUFFER,this.#oe);const x=this.#fe(o),y=x.length;if(y%3!=0)return void A(T,"polygon boundaries vertices are not correct, skip drawing");this.#Ee(x),R+=y/2;const v=p.FLOAT;p.vertexAttribPointer(E,2,v,!1,0,0);const P=this.#_e(c);p.uniform4f(f,P[0]/255,P[1]/255,P[2]/255,P[3]),this._render(R,p.TRIANGLES)}_bindLine=(e,t,s,i,r)=>{const[n,a]=!0===e.isOffsetTurnedOff?[0,0]:s.worldOffset,o=e.x-n,l=e.y-a,c=e.rotation,{u_translation:h,u_rotation:d,u_scale:u,u_resolution:g,u_color:m,a_position:f,u_fade_max:E,u_fade_min:_}=r,S=e.vertices,T=e.bgColor,p=(e.fade_min,e.radius,this.#ae.boundariesWidth);let R=0;t.useProgram(i),t.uniform2f(g,t.canvas.width,t.canvas.height),t.uniform2f(h,o,l),t.uniform2f(u,1,1),t.uniform1f(d,c),t.uniform1f(_,0),t.enableVertexAttribArray(f),t.bindBuffer(t.ARRAY_BUFFER,this.#oe),this.#re.bufferData(this.#re.ARRAY_BUFFER,new Float32Array(S),this.#re.STATIC_DRAW),R+=S.length/2;const A=t.FLOAT;t.vertexAttribPointer(f,2,A,!1,0,0);const x=this.#_e(T);return t.uniform4f(m,x[0]/255,x[1]/255,x[2]/255,x[3]),t.lineWidth(p),Promise.resolve([0,t.LINES])};_drawLines(e,t,s=1,i=0,r=[0,0]){const n=this.getProgram(l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),{u_translation:a,u_rotation:o,u_scale:c,u_resolution:h,u_color:d,a_position:u,u_fade_max:g,u_fade_min:m}=this.getProgramVarLocations(l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),f=this.#re;let E=0;f.useProgram(n),f.uniform2f(h,f.canvas.width,f.canvas.height),f.uniform2f(a,r[0],r[1]),f.uniform2f(c,1,1),f.uniform1f(o,i),f.uniform1f(m,0),f.enableVertexAttribArray(u),f.bindBuffer(f.ARRAY_BUFFER,this.#oe),this.#re.bufferData(this.#re.ARRAY_BUFFER,new Float32Array(e),this.#re.STATIC_DRAW),E+=e.length/2;const _=f.FLOAT;f.vertexAttribPointer(u,2,_,!1,0,0);const S=this.#_e(t);f.uniform4f(d,S[0]/255,S[1]/255,S[2]/255,S[3]),f.lineWidth(s),this._render(E,f.LINES)}#Ae(e,t){return new Promise(((s,i)=>{const r=e.tilemap,n=e.tilesets,a=e.tilesetImages,o=e.layerData,{tileheight:l,tilewidth:c}=r,h=c,d=l,[u,m]=t.worldDimensions,[f,_]=t.canvasDimensions,[S,T]=!0===e.isOffsetTurnedOff?[0,0]:t.worldOffset,p=(this.#ae.render.boundaries.realtimeCalculations,e.setBoundaries);let R=new Map,x=[],y=[];o||(A(g,"check tilemap and layers name"),i());for(let e=0;e<n.length;e++){const s=n[e].data,i=n[e].firstgid,r=n[e+1],g=r?r.firstgid:null,v=s.tilewidth,P=s.tileheight,w=a[e],b=s.imagewidth,I=s.imageheight,O=Math.floor(b/v),C=o.width,D=o.height,M=h*C,B=d*D,N=T%d,L=S%h,W=0!==T?Math.floor(T/d):0,F=0!==S?Math.floor(S/h):0,G=B>_?Math.ceil(_/d)+1:D,k=M>f?Math.ceil(f/h)+1:C,j=C-k-F,V=[],U=[];p&&(M===u&&B===m||(A(E," World size from tilemap is different than settings one, fixing..."),t._setWorldDimensions(M,B)),this.#ae.render.boundaries.mapBoundariesEnabled&&t._setMapBoundaries());let Y=W*C;for(let e=0;e<G;e++){Y+=F;let t=new Map;for(let s=0;s<k;s++){let r=o.data[Y];if(r>=i&&(null===g||r<g)){const n=s*c-L,a=e*l-N;r-=i;const o=n,h=a,d=n+v,u=a+P,g=1/b*(r%O*v),m=1/I*(Math.floor(r/O)*P),f=g+1/b*v,E=m+1/I*P;if(V.push(o,h,d,h,o,u,o,u,d,h,d,u),U.push(g,m,f,m,g,E,g,E,f,m,f,E),p){let i=[n+v,a,n+v,a+P],r=[n+v,a+P,n,a+P],o=[n,a,n+v,a],l=[n,a+P,n,a],c=[null,null,null,null];const h=0!==e?R.get(e-1):void 0;if(h){const e=h.get(s);if(e){const t=e[2],s=x[t];if(s){const e=s[0],i=s[1],r=s[2],n=s[3],a=o[0],l=o[1],c=o[2],h=o[3];a===r&&l===n&&c===e&&h===i&&(x[t]=void 0,o=void 0)}const r=e[1],n=x[r];if(n){const e=n[0],t=n[1],s=n[2],a=i[0];e===i[2]&&s===a&&(x[r]=void 0,i[0]=e,i[1]=t)}const a=e[3],c=x[a];if(c){const e=c[0],t=c[2],s=c[3],i=l[0];e===l[2]&&t===i&&(x[a]=void 0,l[2]=t,l[3]=s)}}}const d=0!==s?t.get(s-1):void 0;if(d){const e=d[1],t=x[e],s=t[0],i=t[1],n=t[2],a=t[3],c=l[0],h=l[1],u=l[2],g=l[3];c===n&&h===a&&u===s&&g===i&&(x[e]=void 0,l=void 0);const m=d[0],f=x[m];if(f&&o){const e=f[0],t=f[1],s=f[3],i=o[1];t===o[3]&&s===i&&(x[m]=void 0,o[0]=e,o[1]=t)}const E=d[2],_=x[E];if(_){const e=_[1],t=_[2],s=_[3],i=r[1];e===r[3]&&s===i&&(x[E]=void 0,r[2]=t,r[3]=s)}}o&&(x.push(o),c[0]=x.length-1),x.push(i),c[1]=x.length-1,x.push(r),c[2]=x.length-1,l&&(x.push(l),c[3]=x.length-1),t.set(s,c)}}Y++}t.size>0&&R.set(e,t),Y+=j}V.length>0&&U.length>0&&y.push([new Float32Array(V),new Float32Array(U),s.name,w])}if(p){const e=x.filter((e=>e));t._addBoundariesArray(e)}s(y)}))}#pe(e,t){return new Promise(((s,i)=>{const r=e.tilemap,n=e.tilesets,a=e.tilesetImages,o=e.layerData,{tileheight:l,tilewidth:c}=r,[h,d]=(e.setBoundaries,t.worldDimensions),[u,m]=t.canvasDimensions,[f,_]=t.worldOffset,S=[],T=[];let p=[];o||(A(g,"check tilemap and layers name"),i());for(let e=0;e<=n.length-1;e++){const s=n[e].data,i=s.tilewidth,r=s.tileheight,g=(s.imageheight,s.imagewidth/i),R=o.width,x=o.height,y=i*R,v=r*x,P=(Math.ceil(u/i),Math.ceil(m/r),a[e]),w=P.width,b=P.height;let I=0;y===h&&v===d||(A(E," World size from tilemap is different than settings one, fixing..."),t._setWorldDimensions(y,v));for(let e=0;e<x;e++)for(let t=0;t<R;t++){let s=o.data[I],n=t*c-f,a=e*l-_;if(0!==s){s-=1;const e=n,t=a,o=n+i,l=a+r,c=1/w*(s%g*i),h=1/b*(Math.floor(s/g)*r),d=c+1/w*i,u=h+1/b*r;S.push(e,t,o,t,e,l,e,l,o,t,o,l),T.push(c,h,d,h,c,u,c,u,d,h,d,u)}I++}const O=new Float32Array(S),C=new Float32Array(T);p.push([O,C,s.name,P])}s(p)}))}#Re=(e,t)=>new Promise(((s,i)=>{const r=e.tilemap,n=r.tilesets,a=e.tilesetImages,o=e.layerData,{tileheight:l,tilewidth:c}=r,h=o.data.length,d=o.data.filter((e=>0!==e)).length,[u,m]=t.worldDimensions,f=[];this.layerDataFloat32.set(o.data),o||(A(g,"check tilemap and layers name"),i());for(let e=0;e<n.length;e++){const s=n[e].data,i=s.tilewidth,r=s.tileheight,g=s.imagewidth/i,_=o.width,S=o.height,T=i*_,p=r*S,R=a[e],x=R.width,y=R.height,v=4,P=12*d,w=12*d;T===u&&p===m||(A(E," World size from tilemap is different than settings one, fixing..."),t._setWorldDimensions(T,p)),this.#ae.render.boundaries.mapBoundariesEnabled&&t._setMapBoundaries(),this.calculateBufferData(v,h,P,S,_,c,l,i,r,g,x,y,!1);const b=this.layerDataFloat32.slice(h,P+h),I=this.layerDataFloat32.slice(P+h,P+w+h);f.push([b,I,s.name,R])}s(f)}));#_e(e){return e.replace("rgba(","").replace(")","").split(",").map((e=>Number(e.trim())))}#fe(e){return this.#xe(e)}#xe(e,t=[]){const s=e.length;if(s<=3)return e.forEach((e=>{t.push(e[0]),t.push(e[1])})),t;const i=[...e].sort(((e,t)=>t[1]-e[1])),r=e.indexOf(i[0]),n=r!==s-1?r+1:0;let a=e,o=a.length,l=0,c=n;for(;a.length>2;){const e=a.length;c>=e&&(c-=e);const s=0===c?a[e-1]:a[c-1],i=a[c],r=e===c+1?a[0]:a[c+1];h=s,d=i,z({x:(u=r)[0]-h[0],y:u[1]-h[1]},{x:d[0]-h[0],y:d[1]-h[1]})<0?(t.push(s[0]),t.push(s[1]),t.push(i[0]),t.push(i[1]),t.push(r[0]),t.push(r[1]),a=a.filter(((e,t)=>t!==c))):(l+=1,l>o&&R("DRAW_PREPARE_ERROR","Can't extract triangles. Probably vertices input is not correct, or the order is wrong")),c++}var h,d,u;return t}#Ee(e){this.#re.bufferData(this.#re.ARRAY_BUFFER,new Float32Array(e),this.#re.STATIC_DRAW)}#me(e,t){const s=0+e,i=0+t;this.#re.bufferData(this.#re.ARRAY_BUFFER,new Float32Array([0,0,s,0,0,i,0,i,s,0,s,i]),this.#re.STATIC_DRAW)}#Se(e,t,s,i=0,r=!1){this.#Te(e,t,i),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,r?e.LINEAR_MIPMAP_LINEAR:e.LINEAR),r&&e.generateMipmap(e.TEXTURE_2D)}#Te(e,t,s=0){e.activeTexture(e.TEXTURE0+s),e.bindTexture(e.TEXTURE_2D,t)}#ye(e,t){e.deleteTexture(t)}}class ne{#ve;#Pe;#we;#be;#Ie;#Oe;#Ce=0;constructor(e,t,s=!1,i,r,n=!1){this.#ve=e,this.#Pe=t,this.#Oe=i,this.#we=r||0,this.#be=n,this.#Ie=s}get isActive(){return this.#be}get currentSprite(){return this.#Pe[this.#we]}get isLastSprite(){return this.#Pe.length-1===this.#we}iterateSprite(){this.#Oe<=this.#Ce?(this.isLastSprite?this.#Ie?this.#we=0:this.deactivateAnimation():this.#we=this.#we+1,this.#Ce=1):this.#Ce+=1}activateAnimation=()=>{this.#be=!0,this.#we=0,this.#Ce=0};deactivateAnimation=()=>{this.#be=!1,this.#Ce=0}}class ae extends C{#ee;#v;#De;#Me;#Be;#Ne;#Le;#We;#Fe;#Ge;constructor(e,t,s,i,r,n=0,a,o){super(l.DRAW_TYPE.IMAGE,e,t),this.#De=r,this.#Be=new EventTarget,this.#Ne=new Map,this.image=o,this.#Le=n,this.#ee=s,this.#v=i,this.#We=a&&!a.r?this._convertVerticesArray(a):a&&a.r?this._calculateConusBoundaries(a.r):this._calculateRectVertices(s,i),this.#Fe=a&&void 0!==a.r?a:null}get width(){return this.#ee}get height(){return this.#v}set width(e){this.#ee=e}set height(e){this.#v=e}get key(){return this.#De}get image(){return this.#Me}set image(e){this.#Ge&&(this.#Ge._isTextureRecalculated=!0),this.#Me=e}get imageIndex(){return this.#Le}set imageIndex(e){this.#Le=e}get isAnimations(){return this.#Ne.size>0}get boundaries(){return this.#We}get vertices(){return this.#We}get circleBoundaries(){return this.#Fe}_processActiveAnimations(){for(let e of this.#Ne.values())e.isActive&&(e.iterateSprite(),this.#Le=e.currentSprite)}get _textureStorage(){return this.#Ge}set _textureStorage(e){this.#Ge=e}emit(e,...t){const s=new Event(e);s.data=[...t],this.#Be.dispatchEvent(s)}addEventListener(e,t,s){this.#Be.addEventListener(e,t,s)}removeEventListener(e,t,s){this.#Be.removeEventListener(e,t,s)}addAnimation(e,t,s,i=1){i<1&&R(d," circlesPerFrame should be >= 1");const r=new ne(e,t,s,i);this.#Ne.set(e,r),this.addEventListener(e,this.#ke)}#ke=e=>{const t=this.#Ne.get(e.type);t.activateAnimation(),this.#Le=t.currentSprite};stopRepeatedAnimation(e){this.#Ne.get(e).deactivateAnimation()}removeAllAnimations(){for(let[e,t]of this.#Ne.entries())this.removeEventListener(e,t.activateAnimation),t.deactivateAnimation();this.#Ne.clear(),this.#Ne=void 0}destroy(){this.removeAllAnimations(),super.destroy()}}class oe extends C{#je;#We;constructor(e,t,s,i){super(l.DRAW_TYPE.CIRCLE,e,t,i),this.#je=s,this.#We=this._calculateConusVertices(s)}get vertices(){return this.#We}set vertices(e){this.#We=e}get radius(){return this.#je}}class le extends C{#je;#Ve;#We;#Ue;constructor(e,t,s,i,r,n=0){super(l.DRAW_TYPE.CONUS,e,t,i),this.#je=s,this.#Ve=r,this.#Ue=n,this.#We=this._calculateConusVertices(s,r)}get vertices(){return this.#We}set vertices(e){this.#We=e}get radius(){return this.#je}get angle(){return this.#Ve}get fade_min(){return this.#Ue}set fade_min(e){this.#Ue=e}}class ce extends C{#We;constructor(e,t){super(l.DRAW_TYPE.LINE,e[0][0],e[0][1],t),this.#We=e}get vertices(){return this.#We}set vertices(e){this.#We=e}}class he extends C{#We;constructor(e,t){super(l.DRAW_TYPE.POLYGON,e[0].x,e[0].y,t),this.#We=this._convertVerticesArray(e)}get vertices(){return this.#We}set vertices(e){this.#We=e}}class de extends C{#ee;#v;#We;constructor(e,t,s,i,r){super(l.DRAW_TYPE.RECTANGLE,e,t,r),this.#ee=s,this.#v=i,this.#We=this._calculateRectVertices(s,i)}get vertices(){return this.#We}get width(){return this.#ee}get height(){return this.#v}set width(e){this.#ee=e}set height(e){this.#v=e}}class ue extends C{#Ye;#ze;#Ke;#He;#Xe;#Qe;#Ze;#Je;#Ge;constructor(e,t,s,i,r){super(l.DRAW_TYPE.TEXT,e,t),this.#Qe=s,this.#Ye=i,this.#He=r,this.#Ze,this.#qe()}get boundariesBox(){const e=this.textMetrics?this.textMetrics.width:300,t=this.textMetrics?this.textMetrics.actualBoundingBoxAscent+5:30;return new B(this.x,this.y-t,e,t)}get vertices(){const e=this.boundariesBox;return this._calculateRectVertices(e.width,e.height)}get text(){return this.#Qe}set text(e){e!==this.#Qe&&(this.#Qe=e,this.#qe())}get font(){return this.#Ye}set font(e){e!==this.#Ye&&(this.#Ye=e,this.#qe())}get textAlign(){return this.#ze}set textAlign(e){e!==this.#ze&&(this.#ze=e,this.#qe())}get textBaseline(){return this.#Ke}set textBaseline(e){e!==this.#Ke&&(this.#Ke=e,this.#qe())}get fillStyle(){return this.#He}set fillStyle(e){e!==this.#He&&(this.#He=e,this.#qe())}get strokeStyle(){return this.#Xe}set strokeStyle(e){e!==this.#Xe&&(this.#Xe=e,this.#qe())}get textMetrics(){return this.#Ze}set _textMetrics(e){this.#Ze=e}get _textureStorage(){return this.#Ge}set _textureStorage(e){this.#Ge=e}get _textureCanvas(){return this.#Je}#qe(){const e=document.createElement("canvas"),t=e.getContext("2d");if(t){t.font=this.font,this._textMetrics=t.measureText(this.text);const s=this.boundariesBox.width,i=this.boundariesBox.height;t.canvas.width=s,t.canvas.height=i,t.font=this.font,t.textBaseline="bottom",this.fillStyle&&(t.fillStyle=this.fillStyle,t.fillText(this.text,0,i)),this.strokeStyle&&(t.strokeStyle=this.strokeStyle,t.strokeText(this.text,0,i)),this.#Je=e,this.#Ge&&(this.#Ge._isTextureRecalculated=!0)}else R("UNHANDLED_EXCEPTION","can't getContext('2d')")}}const ge=["u_translation","u_rotation","u_scale","u_resolution","u_image"],me=["a_position","a_texCoord"],fe=["u_translation","u_rotation","u_scale","u_resolution","u_fade_min","u_fade_max","u_color"],Ee=["a_position"];class _e{#$e;#et;#tt;#be;#st;#it;#rt;#nt;#at;#ot;#lt=!1;#ct;#Be=new EventTarget;#ht;#dt=new Map;#ut=[];constructor(e,t,s){this.#tt=!1,this.#$e=document.createElement("canvas"),s.appendChild(this.#$e),this.#et=this.#$e.getContext("webgl",{stencil:!0}),this.#rt=e,this.#nt=t,this.#at=[],this.#ct=this.systemSettings.gameOptions.render.minCircleTime,this.#lt=this.systemSettings.gameOptions.render.boundaries.wholeWorldPrecalculations,this.#st=new re(this.#et,this.#rt.gameOptions),this.systemSettings.gameOptions.optimization===l.OPTIMIZATION.WEB_ASSEMBLY.WASM&&this._registerRenderInit(this.#st._initiateWasm),this._registerRenderInit(this.fixCanvasSize),this._registerRenderInit((()=>this._registerAndCompileWebGlProgram(l.WEBGL.DRAW_PROGRAMS.IMAGES,"\n    attribute vec2 a_texCoord;\n\n    attribute vec2 a_position;\n\n    uniform vec2 u_translation;\n    uniform float u_rotation;\n    uniform vec2 u_scale;\n\n    uniform vec2 u_resolution;\n\n    varying vec2 v_texCoord;\n\n    void main(void) {\n        float c = cos(-u_rotation);\n        float s = sin(-u_rotation);\n\n        mat3 translationMatrix1 = mat3(\n            1, 0, 0,\n            0, 1, 0,\n            u_translation.x, u_translation.y, 1\n        );\n\n        mat3 translationMatrix2 = mat3(\n            1, 0, 0,\n            0, 1, 0,\n            -u_translation.x, -u_translation.y, 1\n        );\n        \n        mat3 rotationMatrix = mat3(\n            c, -s, 0,\n            s, c, 0,\n            0, 0, 1\n        );\n\n        mat3 scalingMatrix = mat3(\n            u_scale.x, 0, 0,\n            0, u_scale.y, 0,\n            0, 0, 1\n        );\n\n        mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\n        //Scale\n        // vec2 scaledPosition = a_position * u_scale;\n        // Rotate the position\n        // vec2 rotatedPosition = vec2(\n        //    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\n        //    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\n        //);\n        \n        //vec2 position = rotatedPosition + u_translation;\n        vec2 position = (matrix * vec3(a_position, 1)).xy;\n\n        //convert position from pixels to 0.0 to 1.0\n        vec2 zeroToOne = position / u_resolution;\n\n        //convert from 0->1 to 0->2\n        vec2 zeroToTwo = zeroToOne * 2.0;\n\n        //convert from 0->2 to -1->+1\n        vec2 clipSpace = zeroToTwo - 1.0;\n\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n        \n        v_texCoord = a_texCoord;\n    }","\n    precision mediump float;\n\n    uniform sampler2D u_image;\n\n    //texCoords passed in from the vertex shader\n    varying vec2 v_texCoord;\n\n    void main() {\n        vec4 color = texture2D(u_image, v_texCoord);\n        gl_FragColor = color;\n    }",ge,me))),this._registerRenderInit((()=>this._registerAndCompileWebGlProgram(l.WEBGL.DRAW_PROGRAMS.PRIMITIVES,"\n    precision mediump float;\n\n    attribute vec2 a_position;\n\n    uniform vec2 u_translation;\n    uniform float u_rotation;\n    uniform vec2 u_scale;\n\n    uniform vec2 u_resolution;\n\n    void main(void) {\n        float c = cos(-u_rotation);\n        float s = sin(-u_rotation);\n\n        mat3 translationMatrix1 = mat3(\n            1, 0, 0,\n            0, 1, 0,\n            u_translation.x, u_translation.y, 1\n        );\n\n        //mat3 translationMatrix2 = mat3(\n        //    1, 0, 0,\n        //    0, 1, 0,\n        //    -u_translation.x, -u_translation.y, 1\n        //);\n        \n        mat3 rotationMatrix = mat3(\n            c, -s, 0,\n            s, c, 0,\n            0, 0, 1\n        );\n\n        mat3 scalingMatrix = mat3(\n            u_scale.x, 0, 0,\n            0, u_scale.y, 0,\n            0, 0, 1\n        );\n\n        //mat3 matrix = translationMatrix1 * rotationMatrix * translationMatrix2 * scalingMatrix;\n\n        mat3 matrix = translationMatrix1 * rotationMatrix * scalingMatrix;\n\n        //Scale\n        // vec2 scaledPosition = a_position * u_scale;\n        // Rotate the position\n        // vec2 rotatedPosition = vec2(\n        //    scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,\n        //    scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x\n        //);\n        \n        //vec2 position = rotatedPosition + u_translation;\n        vec2 position = (matrix * vec3(a_position, 1)).xy;\n\n        //convert position from pixels to 0.0 to 1.0\n        vec2 zeroToOne = position / u_resolution;\n\n        //convert from 0->1 to 0->2\n        vec2 zeroToTwo = zeroToOne * 2.0;\n\n        //convert from 0->2 to -1->+1\n        vec2 clipSpace = zeroToTwo - 1.0;\n\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    }\n","\n    precision mediump float;\n\n    uniform vec4 u_color;\n    uniform float u_fade_min; \n    uniform float u_fade_max;\n    uniform vec2 a_position;\n    uniform vec2 u_resolution;\n    uniform vec2 u_translation;\n\n    void main(void) {\n        vec4 p = u_color;\n        if (u_fade_min > 0.0) {\n            vec2 fix_tr = vec2(u_translation.x, u_resolution.y - u_translation.y); \n            float distance = distance(fix_tr.xy, gl_FragCoord.xy);\n            if (u_fade_min <= distance && distance <= u_fade_max) {\n                float percent = ((distance - u_fade_max) / (u_fade_min - u_fade_max)) * 100.0;\n                p.a = u_color.a * (percent / 100.0);\n            }\n        }\n\n        gl_FragColor = p;\n    }\n",fe,Ee))),this._registerRenderInit(this.#st._initWebGlAttributes),this._registerObjectRender(ue.name,this.#st._bindText,l.WEBGL.DRAW_PROGRAMS.IMAGES),this._registerObjectRender(de.name,this.#st._bindPrimitives,l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),this._registerObjectRender(he.name,this.#st._bindPrimitives,l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),this._registerObjectRender(oe.name,this.#st._bindConus,l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),this._registerObjectRender(le.name,this.#st._bindConus,l.WEBGL.DRAW_PROGRAMS.PRIMITIVES),this._registerObjectRender(D.name,this.#st._bindTileImages,l.WEBGL.DRAW_PROGRAMS.IMAGES),this._registerObjectRender(ce.name,this.#st._bindLine,l.WEBGL.DRAW_PROGRAMS.PRIMITIVES)}addEventListener=(e,t,s)=>{this.#Be.addEventListener(e,t,s)};removeEventListener=(e,t,s)=>{this.#Be.removeEventListener(e,t,s)};get screenPageData(){return this.#it}get systemSettings(){return this.#rt}get loader(){return this.#nt}get canvas(){return this.#$e}get drawContext(){return this.#et}emit=(e,...t)=>{const s=new Event(e);s.data=[...t],this.#Be.dispatchEvent(s)};isAllFilesLoaded=()=>0===this.loader.filesWaitingForUpload;initiateContext=()=>Promise.all(this.#ut.map((e=>e())));clearContext(){this.#st._clearView()}setCanvasSize(e,t){this.#$e.width=e,this.#$e.height=t,this.#st&&this.#st._fixCanvasSize(e,t)}fixCanvasSize=()=>{const e=this.systemSettings,t=e.canvasMaxSize.width&&e.canvasMaxSize.width<window.innerWidth?e.canvasMaxSize.width:window.innerWidth,s=e.canvasMaxSize.height&&e.canvasMaxSize.height<window.innerHeight?e.canvasMaxSize.height:window.innerHeight;return this.setCanvasSize(t,s),Promise.resolve()};_registerAndCompileWebGlProgram(e,t,s,i,r){return this.#st._registerAndCompileWebGlProgram(e,t,s,i,r),Promise.resolve()}_registerRenderInit(e){this.#ut.push(e)}_registerObjectRender(e,t,s){this.#dt.set(e,{method:t,webglProgramName:s})}async render(){return new Promise((async(e,t)=>{let s=[];const i=this.screenPageData.renderObjects;if(0!==i.length){for(let e=0;e<i.length;e++){const r=i[e];if(r.isRemoved){i.splice(e,1),e--;continue}r.isAnimations&&r._processActiveAnimations();const n=await this._bindRenderObject(r).catch((e=>{t(e)}));s.push(n)}this.systemSettings.gameOptions.boundaries.drawLayerBoundaries&&s.push(this.#gt().catch((e=>{t(e)})))}(await Promise.allSettled(s)).forEach((e=>{"rejected"===e.status&&t(e.reason)})),this.#mt(),this._isCleared=!1,e()}))}set _isCleared(e){this.#tt=e}get _isCleared(){return this.#tt}_createBoundariesPrecalculations(){}#mt(){}#ft(e){return new Promise(((t,s)=>{if(e.setBoundaries){const i=this.loader.getTileMap(e.tileMapKey),r=i.tilesets,n=i.layers.find((t=>t.name===e.layerKey)),{tileheight:a,tilewidth:o}=i,l=o,c=a,[h,d]=this.screenPageData.worldDimensions;let u=[];n||(A(g,"check tilemap and layers name"),s());for(let t=0;t<r.length;t++){const t=n.width,s=n.height,i=l*t,r=c*s;i===h&&r===d||(A(E," World size from tilemap is different than settings one, fixing..."),this.screenPageData._setWorldDimensions(i,r)),e.setBoundaries&&this.systemSettings.gameOptions.render.boundaries.mapBoundariesEnabled&&this.screenPageData._setWholeWorldMapBoundaries();let a=0;for(let e=0;e<s;e++)for(let s=0;s<t;s++){let t=n.data[a],i=s*l,r=e*c;0!==t&&(t-=1,u.push([i,r,i+l,r]),u.push([i+l,r,i+l,r+c]),u.push([i+l,r+c,i,r+c]),u.push([i,r+c,i,r])),a++}}this.screenPageData._setWholeMapBoundaries(u),this.screenPageData._mergeBoundaries(!0),console.warn("precalculated boundaries set"),console.log(this.screenPageData.getWholeWorldBoundaries()),t()}else t()}))}_bindRenderObject(e){const t=e.constructor.name,s=this.#dt.get(t);if(s){const t=s.webglProgramName;if(t){const i=this.#st.getProgram(t),r=this.#st.getProgramVarLocations(t);return s.method(e,this.drawContext,this.screenPageData,i,r).then((e=>this.#st._render(e[0],e[1])))}return s.method(e,this.drawContext,this.screenPageData)}if(e.type===l.DRAW_TYPE.IMAGE){const t=this.#st.getProgram(l.WEBGL.DRAW_PROGRAMS.IMAGES),s=this.#st.getProgramVarLocations(l.WEBGL.DRAW_PROGRAMS.IMAGES);return e.image||(e.image=this.loader.getImage(e.key)),this.#st._bindImage(e,this.drawContext,this.screenPageData,t,s).then((e=>this.#st._render(e[0],e[1]))).then((()=>e.vertices&&this.systemSettings.gameOptions.boundaries.drawObjectBoundaries?this.#st._drawPolygon(e,this.screenPageData):Promise.resolve()))}return console.warn("no registered draw object method for "+t+" skip draw"),Promise.resolve()}#gt(){return new Promise((e=>{const t=this.screenPageData.getBoundaries(),s=t.length,i=[];for(let e=0;e<s;e++){const s=t[e];i.push(s[0],s[1]),i.push(s[2],s[3])}this.#st._drawLines(i,this.systemSettings.gameOptions.boundaries.boundariesColor,this.systemSettings.gameOptions.boundaries.boundariesWidth),e()}))}#Et(){const e=this.systemSettings.gameOptions.render.circleTimeCalc.averageFPStime,t=this.#at.length;let s=0;for(let e=0;e<t;e++)s+=this.#at[e];console.log("FPS average for ",e/1e3,"sec, is ",s/t),this.#at=[]}_startRender=async e=>{this.#be=!0,this.#it=e,this.fixCanvasSize(),this.systemSettings.gameOptions.library===l.LIBRARY.WEBGL&&(await this.#_t(),setTimeout((()=>requestAnimationFrame(this.#St)))),this.systemSettings.gameOptions.render.circleTimeCalc.check===l.OPTIMIZATION.CIRCLE_TIME_CALC.AVERAGES&&(this.#ot=setInterval((()=>this.#Et()),this.systemSettings.gameOptions.render.circleTimeCalc.averageFPStime))};_stopRender=()=>{this.#be=!1,this.#it=null,clearInterval(this.#ot)};#_t(){return new Promise(((e,t)=>{let s=[];const i=this.#lt;s.push(this.initiateContext()),i&&console.warn("isBoundariesPrecalculations() is turned off"),Promise.allSettled(s).then((s=>{s.forEach((e=>{if("rejected"===e.status){const s=e.reason;A(f,s),t(s)}})),e()}))}))}#St=async()=>{const e=performance.now(),t=this.#ct;this.emit(l.EVENTS.SYSTEM.RENDER.START),this.screenPageData._clearBoundaries(),this.clearContext(),this.render().then((()=>{const s=performance.now()-e,i=t-s,r=i>0?i:0,n=1e3/(s+r);this.systemSettings.gameOptions.render.circleTimeCalc.check===l.OPTIMIZATION.CIRCLE_TIME_CALC.CURRENT&&s>t&&console.log("draw circle done, take: ",s," ms"),this.emit(l.EVENTS.SYSTEM.RENDER.END),n===1/0&&console.log("infinity time"),this.#at.push(n),this.#be&&setTimeout((()=>requestAnimationFrame(this.#St)),r)})).catch((e=>{A(f,e),this._stopRender()}))}}class Se{#Tt;#pt;constructor(e){this.#Tt=e}get screenPageData(){return this.#pt}rect(e,t,s,i,r){const n=new de(e,t,s,i,r);return this.#pt._renderObject=n,this.#pt._sortRenderObjectsBySortIndex(),n}text(e,t,s,i,r){const n=new ue(e,t,s,i,r);return this.#pt._renderObject=n,this.#pt._sortRenderObjectsBySortIndex(),n}conus(e,t,s,i,r,n=0){const a=new le(e,t,s,i,r,n);return this.#pt._renderObject=a,this.#pt._sortRenderObjectsBySortIndex(),a}circle(e,t,s,i){const r=new oe(e,t,s,i);return this.#pt._renderObject=r,this.#pt._sortRenderObjectsBySortIndex(),r}image(e,t,s,i,r,n=0,a){const o=this.#Tt.getImage(r),l=new ae(e,t,s,i,r,n,a,o);return this.#pt._renderObject=l,this.#pt._sortRenderObjectsBySortIndex(),l}line(e,t){const s=new ce(e,t);return this.#pt._renderObject=s,this.#pt._sortRenderObjectsBySortIndex(),s}polygon(e,t){const s=new he(e,t);return this.#pt._renderObject=s,this.#pt._sortRenderObjectsBySortIndex(),s}tiledLayer(e,t,s,i){const r=this.#Tt.getTileMap(t),n=r.tilesets,a=n.map((e=>this.#Tt.getImage(e.data.name))),o=r.layers.find((t=>t.name===e)),l=new D(e,t,r,n,a,o,s,i);return this.#pt._renderObject=l,this.#pt._sortRenderObjectsBySortIndex(),l}_addNewObject=(e,t)=>{this[e]=t};_attachPageData=e=>{this.#pt=e};_detachPageData=()=>{this.#pt=null}}class Te extends Event{#Rt;constructor(e,t){super(e),this.#At(e)||R("UNEXPECTED_EVENT_NAME",", Please check if event is exist"),this.#Rt=t}#At(e){return Object.values(l.EVENTS.WEBSOCKET.SERVER_CLIENT).find((t=>t===e))}get data(){return this.#Rt}}class pe extends EventTarget{#xt;#yt;constructor(e){super(),e||R(c,"systemSettings should be passed to class instance"),this.#xt=e}init(){r.e(992).then(r.bind(r,992)).then((e=>{this.#yt=e.io(this.#xt.network.address,{withCredentials:!0}),this.#vt()}))}get isServerConnected(){return!(!this.#yt||!this.#yt.connected)}get playerId(){return this.#yt.id}sendGatherRoomsInfo(){this.#yt.emit(l.EVENTS.WEBSOCKET.CLIENT_SERVER.ROOMS_INFO_REQUEST)}sendCreateOrJoinRoom(e,t){this.#yt.emit(l.EVENTS.WEBSOCKET.CLIENT_SERVER.CREATE_OR_JOIN,e,t)}sendMessage(e){this.#yt.emit(l.EVENTS.WEBSOCKET.CLIENT_SERVER.CLIENT_MESSAGE,e)}#Pt=()=>{v.debug("connected, socket id: "+this.#yt.id),this.dispatchEvent(new Event(l.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED))};#wt=e=>{v.debug("server disconnected, reason: "+e),this.dispatchEvent(new Event(l.EVENTS.WEBSOCKET.SERVER_CLIENT.CONNECTION_STATUS_CHANGED))};#bt=e=>{console.warn("server data: ",e)};#It=e=>{v.debug("received new message from server: "+e),this.dispatchEvent(new Te(l.EVENTS.WEBSOCKET.SERVER_CLIENT.SERVER_MESSAGE,e))};#Ot=e=>{v.debug("received roomsInfo "+e),this.dispatchEvent(new Te(l.EVENTS.WEBSOCKET.SERVER_CLIENT.ROOMS_INFO,e))};#Ct=(e,t)=>{v.debug("CLIENT SOCKET: Created room  "+e),this.dispatchEvent(new Te(l.EVENTS.WEBSOCKET.SERVER_CLIENT.CREATED,{room:e,map:t}))};#Dt=e=>{v.debug("CLIENT SOCKET: Room is full, can't join: "+e),this.dispatchEvent(new Te(l.EVENTS.WEBSOCKET.SERVER_CLIENT.FULL,{room:e}))};#Mt=(e,t)=>{v.debug("CLIENT SOCKET: Joined to room: "+e,", map: ",t),this.dispatchEvent(new Te(l.EVENTS.WEBSOCKET.SERVER_CLIENT.JOINED,{room:e,map:t}))};#Bt=e=>{this.dispatchEvent(new Te(l.EVENTS.WEBSOCKET.SERVER_CLIENT.DISCONNECTED,{playerId:e}))};#vt(){this.#yt.on("connect",this.#Pt),this.#yt.on("disconnect",this.#wt),this.#yt.on("data",this.#bt),this.#yt.on("roomsInfo",this.#Ot),this.#yt.on("created",this.#Ct),this.#yt.on("full",this.#Dt),this.#yt.on("joined",this.#Mt),this.#yt.on("log",(function(e){console.log.apply(console,e)})),this.#yt.on("message",this.#It),this.#yt.on("removed",(function(e){console.log("removed message"),console.log(e)})),this.#yt.on("disconnected",this.#Bt),addEventListener("beforeunload",this.#Nt)}#Nt=()=>{this.#yt.disconnect()}}class Re{#Lt=.5;#Wt=new Map;#nt;constructor(e){this.#nt=e}getAudio=e=>{const t=this.#Wt.get(e);return null===t?(A(S,"Audio with key "+e+" exists, but not actually loaded"),t):t||(A(_,""),null)};getAudioCloned=e=>{const t=this.#Wt.get(e);if(null===t)return A(S,"Audio with key "+e+" exists, but not actually loaded"),t;if(t){const e=t.cloneNode();return e.volume=this.#Lt,e}return A(_),null};set volume(e){this.#Lt=e,this.#Ft(e)}get volume(){return this.#Lt}#Ft(e){for(const t of this.#Wt.values())t&&(t.volume=e)}registerAudio(e){let t=this.#nt.getAudio(e);this.#Wt.set(e,t)}}class Ae{#Gt;constructor(e){this.#Gt=e}registerDrawObject(e,t){this.#Gt.drawObjectFactory._addNewObject(e,t)}registerAndCompileWebGlProgram(e,t,s,i,r){return this.#Gt.renderInterface._registerAndCompileWebGlProgram(e,t,s,i,r)}registerRenderInit(e){this.#Gt.renderInterface._registerRenderInit(e)}registerObjectRender(e,t,s){this.#Gt.renderInterface._registerObjectRender(e,t,s)}}class xe{#xt;#kt;#jt;#Vt;#Tt=new b;#Ut;#Yt=new Se(this.#Tt);#zt=new Map;#Kt;#Be=new EventTarget;constructor(e,t,s){e||R(c,"systemSettings should be passed to class instance"),this.#xt=e,this.#kt=new Ae(this),this.#Vt=new Re(this.loader),this.#jt=new pe(e),this.#Ut=new _e(this.systemSettings,this.loader,s),this.#Kt=t,this.#Ut.addEventListener(l.EVENTS.SYSTEM.RENDER.START,(()=>this.emit(l.EVENTS.SYSTEM.RENDER.START))),this.#Ut.addEventListener(l.EVENTS.SYSTEM.RENDER.END,(()=>this.emit(l.EVENTS.SYSTEM.RENDER.END)))}emit=(e,...t)=>{const s=new Event(e);s.data=[...t],this.#Be.dispatchEvent(s)};addEventListener=(e,t,s)=>{this.#Be.addEventListener(e,t,s)};removeEventListener=(e,t,s)=>{this.#Be.removeEventListener(e,t,s)};get network(){return this.#jt}get systemSettings(){return this.#xt}get audio(){return this.#Vt}get loader(){return this.#Tt}get drawObjectFactory(){return this.#Yt}get renderInterface(){return this.#Ut}get extensionInterface(){return this.#kt}get modules(){return this.#zt}installModule=(e,t,...s)=>{const i=new t(this,...s);return this.#zt.has(e)?(A("MODULE_ALREADY_INSTALLED","module "+e+" is already installed"),this.#zt.get(e)):(this.#zt.set(e,i),i)};startScreenPage=(e,t)=>{if(this.#Kt.has(e)){const s=this.#Kt.get(e),i=s.screenPageData;this.#Yt._attachPageData(i),!1===s.isInitiated&&s._init(),s._start(t),this.emit(l.EVENTS.SYSTEM.START_PAGE),this.#Ut._startRender(i)}else R(h,"View "+e+" is not registered!")};stopScreenPage=e=>{this.#Kt.has(e)?(this.emit(l.EVENTS.SYSTEM.STOP_PAGE),this.drawObjectFactory._detachPageData(),this.#Ut._stopRender(),this.#Kt.get(e)._stop()):R(h,"View "+e+" is not registered!")}}class ye{#Ht;#Xt=!1;#be;#Gt;#Qt;constructor(){this.#be=!1,this.#Qt=new x}_register(e,t){this.#Ht=e,this.#Gt=t,this.#Zt(),this.#Jt(),this.register()}_init(){this.init(),this.#Xt=!0}register(){}init(){}start(e){}stop(){}resize(){}get loader(){return this.#Gt.loader}get draw(){return this.#Gt.drawObjectFactory}createCanvasView=(e,t=!1)=>{if(e&&e.trim().length>0)return console.warn("createCanvasView is deprecated. For layer masks use .setMask(drawObject)."),{};R(d)};_attachCanvasToContainer(e){this.#qt(this.canvasHtmlElement,e)}addRenderObject=(e,t)=>{t?A(p,"canvasKey parameter is deprecated and no longer needed"):t=e;const s=this.screenPageData;-1!==s.renderObjects.indexOf(t)?A("NEW_BEHAVIOR_INTRODUCED","page.draw methods add objects to pageData, no need to call addRenderObject"):(s._renderObject=t,s._sortRenderObjectsBySortIndex())};addRenderLayer=(e,t,s,i,r)=>{if(e){A(p,"page.addRenderLayer is deprecated and will be removed, use page.draw.tiledLayer instead");const e=this.screenPageData;e._renderObject=this.draw.tiledLayer(t,s,i,r),i&&this.systemSettings.gameOptions.render.boundaries.mapBoundariesEnabled&&e._enableMapBoundaries(),e._sortRenderObjectsBySortIndex()}else R("CANVAS_KEY_NOT_SPECIFIED",", should pass canvasKey as 3rd parameter")};get isActive(){return this.#be}get isInitiated(){return this.#Xt}get name(){return this.#Ht}get screenPageData(){return this.#Qt}get systemSettings(){return this.#Gt.systemSettings}get audio(){return this.#Gt.audio}get system(){return this.#Gt}get canvasHtmlElement(){return document.getElementsByTagName("canvas")[0]}addEventListener=(e,t,s)=>{this.system.addEventListener(e,t,s)};removeEventListener=(e,t,s)=>{this.system.removeEventListener(e,t,s)};getView=e=>{console.warn("ScreenPage.getView() is deprecated. Use ScreenPage.system.renderInterface for render, and ScreenPage.screenPageData for data instead")};_start(e){this.start(e),this.#be=!0,window.addEventListener("resize",this._resize),this._resize()}_stop(){this.#be=!1,window.removeEventListener("resize",this._resize),this.stop()}_resize=()=>{this.#Jt(),this.resize()};#qt(e,t){t.appendChild(e)}#$t(){for(const e of document.getElementsByTagName("canvas"))e.remove()}#Zt(){const e=this.systemSettings.worldSize?this.systemSettings.worldSize.width:0,t=this.systemSettings.worldSize?this.systemSettings.worldSize.height:0;this.screenPageData._setWorldDimensions(e,t)}isBoundariesCollision=(e,t,s)=>{const i=s.type,r=s.vertices,n=s.circleBoundaries;switch(i){case l.DRAW_TYPE.TEXT:case l.DRAW_TYPE.RECTANGLE:case l.DRAW_TYPE.CONUS:case l.DRAW_TYPE.IMAGE:return n?this.#es(e,t,s.circleBoundaries.r):this.#ts(e,t,r,s.rotation);case l.DRAW_TYPE.CIRCLE:A(l.WARNING_CODES.METHOD_NOT_IMPLEMENTED,"isObjectCollision.circle check is not implemented yet!");break;case l.DRAW_TYPE.LINE:A(l.WARNING_CODES.METHOD_NOT_IMPLEMENTED,"isObjectCollision.line check is not implemented yet, please use .rect instead line!");break;default:A(l.WARNING_CODES.UNKNOWN_DRAW_OBJECT,"unknown object type!")}return!1};isObjectsCollision=(e,t,s,i)=>{const r=s.type,n=s.vertices,a=s.circleBoundaries;switch(r){case l.DRAW_TYPE.TEXT:case l.DRAW_TYPE.RECTANGLE:case l.DRAW_TYPE.CONUS:case l.DRAW_TYPE.IMAGE:return a?this.#ss(e,t,a,i):this.#is(e,t,n,s.rotation,i);case l.DRAW_TYPE.CIRCLE:A(l.WARNING_CODES.METHOD_NOT_IMPLEMENTED,"isObjectCollision.circle check is not implemented yet!");break;case l.DRAW_TYPE.LINE:A(l.WARNING_CODES.METHOD_NOT_IMPLEMENTED,"isObjectCollision.line check is not implemented yet, please use .rect instead line!");break;default:A(l.WARNING_CODES.UNKNOWN_DRAW_OBJECT,"unknown object type!")}return!1};#is(e,t,s,i,r){const n=r.length;let a=[];for(let o=0;o<n;o++){const n=r[o];let c;switch(n.type){case l.DRAW_TYPE.TEXT:case l.DRAW_TYPE.RECTANGLE:case l.DRAW_TYPE.CONUS:case l.DRAW_TYPE.IMAGE:c=this.#rs(e,t,s,i,n);break;case l.DRAW_TYPE.CIRCLE:console.warn("isObjectCollision.circle check is not implemented yet!");break;case l.DRAW_TYPE.LINE:console.warn("isObjectCollision.line check is not implemented, please use rect instead");break;default:console.warn("unknown object type!")}c&&a.push(c)}return a.length>0?this.#ns(a):null}#ss(e,t,s,i){const r=s.r,n=i.length;let a=[];for(let s=0;s<n;s++){const n=i[s],o=n.type,c=n.circleBoundaries;let h;switch(o){case l.DRAW_TYPE.TEXT:case l.DRAW_TYPE.RECTANGLE:case l.DRAW_TYPE.CONUS:case l.DRAW_TYPE.IMAGE:h=c?this.#as(e,t,r,n.x,n.y,c.r):this.#os(e,t,r,n);break;case l.DRAW_TYPE.CIRCLE:console.warn("isObjectCollision.circle check is not implemented yet!");break;case l.DRAW_TYPE.LINE:console.warn("isObjectCollision.line check is not implemented, please use rect instead");break;default:console.warn("unknown object type!")}h&&a.push(h)}return a.length>0?this.#ns(a):null}#ns(e){return e.sort(((e,t)=>e.p<t.p))[0]}#os(e,t,s,i){const[r,n]=this.screenPageData.worldOffset,a=e-r,o=t-n,l=i.x-r,c=i.y-n,h=i.vertices,d=i.rotation,u=h.length;for(let e=0;e<u;e+=1){const t=h[e];let i=h[e+1];i||(i=h[0]);const r=this.#ls(t,l,c,d),n=this.#ls(i,l,c,d),u=ee(a,o,s,{x1:r[0],y1:r[1],x2:n[0],y2:n[1]});if(u)return u}return!1}#as(e,t,s,i,r,n){const a=new N(e,t,i,r).length;return console.log(a),console.log(s),console.log(n),!(a-(s+n)>0)}#rs(e,t,s,i,r){const[n,a]=this.screenPageData.worldOffset,o=e-n,l=t-a,c=r.x-n,h=r.y-a,d=r.vertices,u=r.rotation,g=s.map((e=>this.#ls(e,o,l,i))),m=d.length;for(let e=0;e<m;e+=1){const t=d[e];let s=d[e+1];s||(s=d[0]);const i=this.#ls(t,c,h,u),r=this.#ls(s,c,h,u),n=Z(g,{x1:i[0],y1:i[1],x2:r[0],y2:r[1]});if(n)return n}return!1}#ls(e,t,s,i){const r=new N(0,0,e[0],e[1]),n=j(0,0,e[0],e[1]),a=r.length;return[t+a*Math.cos(i+n),s+a*Math.sin(i+n)]}#cs(e){const t=this.screenPageData.getBoundaries(),s=t.length,i=e.length;for(let r=0;r<i;r++){const n=e[r];for(let e=0;e<i;e++);for(let e=0;e<s;e+=1){const s=t[e],i={x1:s[0],y1:s[1],x2:s[2],y2:s[3]},r=i.boundaries;r?Z(r,i)&&this.emit(l.EVENTS.GAME.BOUNDARIES_COLLISION,n):Q({x:n.x,y:n.y},i)&&this.emit(l.EVENTS.GAME.BOUNDARIES_COLLISION,n)}}}#es(e,t,s){const i=this.screenPageData.getBoundaries(),[r,n]=this.screenPageData.worldOffset,a=e-r,o=t-n,l=i.length;for(let e=0;e<l;e+=1){const t=i[e],r=ee(a,o,s,{x1:t[0],y1:t[1],x2:t[2],y2:t[3]});if(r)return r}return!1}#ts(e,t,s,i){const r=this.screenPageData.getBoundaries(),[n,a]=this.screenPageData.worldOffset,o=e-n,l=t-a,c=s.map((e=>this.#ls(e,o,l,i))),h=r.length;for(let e=0;e<h;e+=1){const t=r[e],s=Z(c,{x1:t[0],y1:t[1],x2:t[2],y2:t[3]});if(s)return s}return!1}#Jt(){const e=this.systemSettings.canvasMaxSize.width&&this.systemSettings.canvasMaxSize.width<window.innerWidth?this.systemSettings.canvasMaxSize.width:window.innerWidth,t=this.systemSettings.canvasMaxSize.height&&this.systemSettings.canvasMaxSize.height<window.innerHeight?this.systemSettings.canvasMaxSize.height:window.innerHeight;this.screenPageData._setCanvasDimensions(e,t)}}class ve extends ye{#hs=0;#ds=0;#us=0;register(){}init(){const[e,t]=this.screenPageData.canvasDimensions,s=e/3;this.background=this.draw.rect(0,0,e,t,this.systemSettings.gameOptions.loadingScreen.backgroundColor),this.loadingBarBg=this.draw.rect(e/2-s/2,t/2-10,s,20,this.systemSettings.gameOptions.loadingScreen.loadingBarBg),this.loadingBarProgress=this.draw.rect(e/2-s/2,t/2-10,s,20,this.systemSettings.gameOptions.loadingScreen.loadingBarProgress),this.text=this.draw.text(e/2-20,t/2-40,"JsGE","24px sans-serif","black"),this.#us=s}_progress=(e,t)=>{const[s,i]=this.screenPageData.canvasDimensions,r=this.#us/this.#hs;this.#ds=e,this.loadingBarProgress.width=r*this.#ds};start(e){this.#hs=e.total}get loader(){return{filesWaitingForUpload:0}}}const Pe="loadingPage";class we{#gs;#ms;constructor(e,t){e||R(c,"systemSettings should be passed to class instance"),this.#gs=new Map,t||(t=document.createElement("div"),document.body.appendChild(t)),this.#ms=new xe(e,this.#gs,t),this.registerPage(Pe,ve),this.#ms.loader.addEventListener("loadstart",this.#fs),this.#ms.loader.addEventListener("progress",this.#Es),this.#ms.loader.addEventListener("load",this.#_s)}get system(){return this.#ms}registerPage(e,t){if(e&&"string"==typeof e&&e.trim().length>0){const s=new t;s._register(e,this.system),this.#gs.set(e,s)}else R(c,"valid class name should be provided")}preloadAllData(){return this.#ms.loader.preload()}#fs=e=>{this.#ms.startScreenPage(Pe,{total:e.total})};#Es=e=>{const t=e.loaded,s=e.total;this.#gs.get(Pe)._progress(t,s)};#_s=()=>{this.#ms.stopScreenPage(Pe)}}var be=n.oX,Ie=n.QD,Oe=n.xl,Ce=n.r4,De=n.xP,Me=n.jQ,Be=n.bq,Ne=n.P6;export{be as CONST,Ie as DrawImageObject,Oe as Primitives,Ce as ScreenPage,De as System,Me as SystemAudioInterface,Be as SystemSettings,Ne as utils};