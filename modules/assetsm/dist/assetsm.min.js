const PROGRESS_EVENT_TYPE={loadstart:"loadstart",progress:"progress",abort:"abort",error:"error",load:"load",timeout:"timeout"};export default class AssetsManager{#e;#t;#i;#s;#a;#r;#o;#n;constructor(){this.#t=new Map,this.#i=new Map,this.#s=new Map,this.#a=new Map,this.#r=new Map,this.#o=new Map,this.#e=new EventTarget,this.#n=0}get filesWaitingForUpload(){return this.#a.size+this.#o.size+this.#r.size}getAudio(e){const t=this.#t.get(e);if(t)return t;Warning("Audio with key '"+e+"' is not loaded")}getImage(e){const t=this.#i.get(e);if(t)return t;Warning("Image with key '"+e+"' is not loaded")}getTileMap(e){const t=this.#s.get(e);if(t)return t;Warning("Tilemap with key '"+e+"' is not loaded")}preload(){return this.#d(),Promise.allSettled(Array.from(this.#a.entries()).map((e=>this.#l(e[0],e[1])))).then((e=>(e.forEach((e=>{"rejected"===e.status&&Warning(e.reason||e.value)})),Promise.allSettled(Array.from(this.#o.entries()).map((e=>this.#h(e[0],e[1])))).then((e=>(e.forEach((e=>{"rejected"===e.status&&Warning(e.reason||e.value)})),Promise.allSettled(Array.from(this.#r.entries()).map((e=>this.#u(e[0],e[1])))).then((e=>(e.forEach((e=>{"rejected"===e.status&&Warning(e.reason||e.value)})),this.#m(),Promise.resolve())))))))))}addAudio(e,t){this.#c(e,t),this.#a.has(e)&&Warning("Audio with key "+e+" is already registered"),this.#a.set(e,t)}addImage(e,t){this.#c(e,t),this.#r.has(e)&&Warning("Image with key "+e+" is already registered"),this.#r.set(e,t)}addTileMap(e,t){this.#c(e,t),this.#o.has(e)&&Warning("Tilemap with key "+e+" is already registered"),this.#o.set(e,t)}addEventListener(e,t,...i){PROGRESS_EVENT_TYPE[e]?this.#e.addEventListener(e,t,...i):Warning("Event type should be one of the ProgressEvent.type")}removeEventListener(e,t,...i){this.#e.removeEventListener(e,t,...i)}#g(e,t){const{firstgid:i,source:s}=e;return this.#p(s),fetch(t+s).then((e=>e.json())).then((e=>{const{name:s,image:a}=e;return s&&a&&this.addImage(s,t?t+a:a,e),e.gid=i,Promise.resolve(e)})).catch((()=>{const e=new Error("Can't load related tileset ",s);return Promise.reject(e)}))}#h(e,t){return this.#E(t),fetch(t).then((e=>e.json())).then((i=>{let s,a=t.split("/"),r=a.length;if(a[r-1].includes(".tmj")||a[r-1].includes(".json")?(a.pop(),s=a.join("/")+"/"):(a[r-2].includes(".tmj")||a[r-2].includes(".json"))&&(a.splice(r-2,2),s=a.join("/")+"/"),this.#P(e,i),this.#T(e),i.tilesets&&i.tilesets.length>0){const t=[];return i.tilesets.forEach(((i,a)=>{const r=this.#g(i,s).then((t=>(this.#v(e,a,t),this.#w(),Promise.resolve())));t.push(r)})),Promise.all(t)}})).catch((e=>(e.message.includes("JSON.parse:")&&(e=new Error("Can't load tilemap "+t)),this.#Q(e),Promise.reject(e))))}#l(e,t){return new Promise(((i,s)=>{const a=new Audio(t);a.addEventListener("loadeddata",(()=>{this.#f(e,a),this.#L(e),this.#w(),i()})),a.addEventListener("error",(()=>{const e=new Error("Can't load audio "+t);this.#Q(e),s(e)}))}))}#u(e,t){return new Promise(((i,s)=>{const a=new Image;a.onload=()=>{createImageBitmap(a).then((t=>{this.#M(e,t),this.#j(e),this.#w(),i()}))},a.onerror=()=>{const e=new Error("Can't load image "+t);this.#Q(e),s(e)},a.src=t}))}#p(e){e.includes(".tsj")||e.includes(".json")||Exception("Related Tileset file type is not correct, only .tsj or .json files are supported")}#E(e){e.includes(".tmj")||e.includes(".json")||Exception("Tilemap file type is not correct, only .tmj or .json files are supported")}#c(e,t){const i="image key and url should be provided";e&&0!==e.trim().length||Exception(i),t&&0!==t.trim().length||Exception(i)}#f(e,t){this.#t.set(e,t)}#L(e){this.#a.delete(e)}#M(e,t){this.#i.set(e,t)}#j(e){this.#r.delete(e)}#v(e,t,i){this.#s.get(e).tilesets[t].data=i}#P(e,t){this.#s.set(e,t)}#T(e){this.#o.delete(e)}#d(){let e=this.filesWaitingForUpload;this.#e.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.loadstart,{total:e}))}#m(){this.#e.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.load))}#w(){const e=this.filesWaitingForUpload;this.#n+=1,this.#e.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.progress,{lengthComputable:!0,loaded:this.#n,total:e}))}#Q(e){this.#e.dispatchEvent(new ProgressEvent(PROGRESS_EVENT_TYPE.error,{error:e}))}}function Exception(e){throw new Error(e)}function Warning(e){console.warn(e)}